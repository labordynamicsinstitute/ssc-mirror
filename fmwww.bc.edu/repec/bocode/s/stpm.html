<pre>
-------------------------------------------------------------------------------
help for <b>stpm</b>                                                   Patrick Royston
-------------------------------------------------------------------------------
<p>
<b><u>Flexible parametric models for survival-time data</u></b>
<p>
        <b>stpm</b> [<i>varlist</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <i>model_complexity</i>
                 <b><u>sc</u></b><b>ale(</b><b><u>h</u></b><b>azard</b>|<b><u>n</u></b><b>ormal</b>|<b><u>o</u></b><b>dds)</b> [<b>all</b> <b><u>cl</u></b><b>uster(</b><i>cluster_var</i><b>)</b>
                 <b><u>l</u></b><b>eft(</b><i>leftvar</i>)<b>)</b> <b><u>ml</u></b><b>maxopts(</b><i>ml_maximize_options</i><b>)</b> <b><u>nocons</u></b><b>tant</b>
                 <b><u>nolo</u></b><b>g</b> <b><u>noorth</u></b><b>og</b> <b><u>off</u></b><b>set(</b><i>offsetvar</i><b>)</b> <b>q(</b><i>orthog_matrix</i><b>)</b>
                 <b><u>sp</u></b><b>line(</b><i>splinevar derivativevar</i><b>)</b> <b><u>st</u></b><b>ratify(</b><i>strat_varlist</i><b>)</b>
                 <b><u>tech</u></b><b>nique(</b><i>algorithm_spec</i><b>)</b> <b><u>th</u></b><b>eta(est</b>|<i>#</i><b>)</b>]
<p>
    where
<p>
        <i>model_complexity</i> is <b>df(</b><i>#</i><b>)</b> or <b>stpmdf(</b><i>#</i><b>)</b> or <b><u>k</u></b><b>nots(</b>[<b>l</b>|<b>%</b>]<i>knotlist</i><b>)</b> or
        <b><u>k</u></b><b>nots(u</b><i>#1 #2 #3</i><b>)</b>.
<p>
<p>
    <b>stpm</b> is for use with survival-time data; see st.  You must have <b>stset</b>
    your data before using this command; see help st. Weights are to be set
    by <b>stset</b>. All weight-types are supported.
<p>
    The syntax of predict following <b>stpm</b> is
<p>
        <b>predict</b> [<i>type</i>] <i>newvarname</i> [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [<b>,</b> <i>statistic</i> <i>at_stuff</i>
                <b><u>nocons</u></b><b>tant</b> <b><u>nooff</u></b><b>set</b> <b>stdp</b> <b><u>st</u></b><b>ore(</b><i>global_macro_name</i> [<i>#</i>]<b>)</b>
                <b><u>t</u></b><b>ime(</b><i>#</i>|<i>vn</i><b>)</b> <b><u>z</u></b><b>ero</b>]
<p>
<p>
    where <i>at_stuff</i> is <i>varname #</i> |<i>vn</i> [<i>varname #</i>|<i>vn</i> ...]<b>)</b> or <b><u>a</u></b><b>t(@</b><i>varname</i>
    <i>#</i>|<i>string</i><b>)</b> or <b><u>a</u></b><b>t(+</b><i>#</i><b>)</b>
<p>
    and <i>statistic</i> is
<p>
        <b>xb</b>                    index (linear predictor for equation <b>[xb]</b>); the
                              default
        <b><u>cumo</u></b><b>dds</b>               log cumulative odds function
        <b><u>cumh</u></b><b>azard</b>             log cumulative hazard function
        <b><u>n</u></b><b>ormal</b>                Normal deviate function
        <b><u>sp</u></b><b>line</b>                fitted spline function
        <b><u>dz</u></b><b>dy</b>                  derivative of fitted spline function w.r.t.
                              ln(_t)
        <b><u>d</u></b><b>ensity</b>               density function
        <b><u>dev</u></b><b>iance</b>              deviance residuals
        <b><u>h</u></b><b>azard</b>                hazard function
        <b><u>mar</u></b><b>tingale</b>            martingale residuals
        <b><u>s</u></b><b>urvival</b>              survival function
        <b><u>f</u></b><b>ailure</b>               failure (cumulative incidence) function
        <b><u>ce</u></b><b>ntile(</b><i>#</i>|<i>varname</i><b>)</b>    <i>#</i> th centile of survival time distribution (or
                              centiles stored in <i>varname</i>)
        <b><u>tv</u></b><b>c(</b><i>varname</i><b>)</b>          time-varying coefficient for <i>varname</i> (see
                              <i>Options for predict</i>)
<p>
    All statistics are available both in and out of sample; type "<b>predict</b> ...
    <b>if e(sample)</b> ..." if wanted only for the estimation sample. The default
    is linear prediction of the covariate part of the model, i.e. for
    statistic <b>xb</b>.
<p>
    Not all of the options for <b>predict</b> are available with every statistic.
    The SE (<b>stdp</b> option of <b>predict</b>) is not available for every statistic.
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>stpm</b> fits spline-based distributional models to right- or
    interval-censored data. <i>varlist</i> is a set of covariates. Multistate models
    are also supported.
<p>
<p>
<b><u>Options for stpm</u></b>
<p>
    Note that the complexity of the spline part of the model is defined by
    <b>df()</b> or <b>stpmdf()</b> or <b>knots()</b>. Just one of these options must be specified.
<p>
    <b>all</b> includes out-of-sample observations in generated variables which
        contain the spline basis functions.
<p>
    <b>cluster(</b><i>cluster_var</i>)<b>)</b> adjusts standard errors for intra-group
        correlation, where the grouping variable is <i>cluster_var</i>; implies
        <b>robust</b>
<p>
    <b>df(</b><i>#</i><b>)</b> specifies the degrees of freedom for the natural spline function. <i>#</i>
        must be between 1 and 6. The <b>knots()</b> option is not applicable and the
        knots are placed at the following centiles of the distribution of the
        uncensored log times:
<p>
        ---------------------------
        df        Centile positions
        ---------------------------
         1        (no knots)
         2        50
         3        33 67
         4        25 50 75
         5        20 40 60 80
         6        17 33 50 67 83
        &gt;6        (not allowed)
        ---------------------------
<p>
    <b>knots(</b>[<b>l</b>|<b>%</b>]<i>knotlist</i><b>)</b> (syntax 1) defines the internal knot positions for
        the spline.  If you specify <b>knots(</b><i>knotlist</i><b>)</b> then <i>knotlist</i> should
        consist of values of log time. If you specify <b>knots(l</b><i>knotlist</i><b>)</b> then
        the values in <i>knotlist</i> are taken to be times and are automatically
        log transformed by <b>stpm</b>. (This is a convenience feature; it is easier
        to enter times than log times). If you specify <b>knots(%</b><i>knotlist</i><b>)</b> then
        the values in <i>knotlist</i> are taken to be centile positions in the
        distribution of the uncensored log times.
<p>
    <b>knots(u</b><i>#1 #2 #3</i><b>)</b> (syntax 2) also defines the internal knots for the
        spline. <i>#1</i> knots are assigned at random uniformly distributed
        positions between <i>#2</i> and <i>#3</i>, where <i>#2</i> is the lowest centile position
        of the uncensored log times you wish to entertain and <i>#3</i> is the
        highest. A suggested choice is <i>#2</i>=10, <i>#3</i>=90; knots are to be placed
        at random positions between the 10th and 90th centiles of the
        uncensored log times.
<p>
    <b>left(</b><i>leftvar</i><b>)</b> specifies that some or all of the survival-time
        observations are interval-censored. The rules for specifying values
        of <i>leftvar</i> and their meanings in terms of interval censoring are as
        follows:
<p>
        -------------------------------------------------------------------
        Value of <i>leftvar</i>   _d   Meaning
        -------------------------------------------------------------------
        . or _t             0   Right censored at _t
        . or _t             1   Event at _t
        0                   0   Right censored at _t
        0                   1   Interval censored, event in (0,_t]
        &lt;_t                 0   Late entry at <i>leftvar</i>, right censored at _t
        &lt;_t                 1   Interval censored, event in [<i>leftvar</i>,_t]
        -------------------------------------------------------------------
<p>
        Note that <b>stpm</b> support datasets with late entry and interval
        censoring only when late entry is specified through <i>leftvar</i> and the
        value of _d, as given in the above table.
<p>
    <b>mlmaxopts(</b><i>ml_maximize_options</i><b>)</b> control the likelihood maximization
        process; seldom used. The <b>difficult</b> option is probably the most
        important. See ml##ml_maxopts for details.
<p>
    <b>noconstant</b> suppresses the constant term in the <b>[xb]</b> equation.
<p>
    <b>nolog</b> suppresses the iteration log while the model is fit.
<p>
    <b>noorthog</b> suppresses orthogonalisation of the spline basis functions. You
        should rarely need this option, which is provided for compatibility
        with early versions of <b>stpm</b>, and for pedagngic reasons.
<p>
    <b>offset(</b><i>offsetvar</i><b>)</b> defines the offset for the <b>[xb]</b> equation.  <i>offsetvar</i> is
        added to the linear predictor.
<p>
    <b>q(</b><i>orthog_matrix</i><b>)</b> is required with the <b>spline()</b> option, unless the
        <b>noorthog</b> option was used when the model was fitted. The Q-matrix
        <i>orthog_matrix</i> is a linear transformation between the regression
        coefficients on the orthogonalised and original spline basis
        functions. It may be stored following a run of <b>stpm</b> by extracting it
        from <b>e(Q)</b>:
<p>
        <b>stpm ...</b>
        <b>matrix q = e(Q)</b>
<p>
    <b>scale(hazard</b>|<b>normal</b>|<b>odds)</b> is not optional and specifies the scale of the
        model. The <b>hazard</b>, <b>normal</b> and <b>odds</b> options fit models on the scale of
        the log cumulative hazard, normal equivalent deviate or log
        cumulative odds of failure respectively.
<p>
    <b>spline(</b><i>splinevar derivativevar</i><b>)</b> allows you to specify the baseline spline
        function and its derivative with respect to ln(_t). For a given model
        where the spline function has been estimated, <i>splinevar</i> can be
        created by using for example
<p>
        <b>predict</b> <i>splinevar</i><b>, spline zero</b>
<p>
        <i>derivativevar</i> may be created by using for example
<p>
        <b>predict</b> <i>derivativevar</i><b>, dzdy</b>
<p>
        Note also that the <b>noconstant</b> option of <b>predict</b> subtracts the
        constant term from the spline function. This will ensure that if the
        model is refitted using <i>splinevar</i> and <i>derivativevar</i>, the constant
        will be reported as (close to) zero.
<p>
    <b>stpmdf(</b><i>#</i><b>)</b> is identical to <b>df()</b>. <b>stpmdf()</b> is for inputting the df required
        for stpm to mfp, which has its own <b>df()</b> option.
<p>
    <b>stratify(</b><i>strat_varlist</i><b>)</b> stratifies the spline functions according to the
        variables in <i>strat_varlist</i>. It will rarely make sense for the
        variables in <i>strat_varlist</i> not to be among those in <i>varlist</i>, but this
        is not checked.
<p>
    <b>technique()</b> specifies how the likelihood function is to be maximized by
        <b>ml</b>.  The following algorithms are currently implemented in <b>ml</b>: <b>nr</b>
        (the default), <b>bhhh</b>, <b>dfp</b>, <b>bfgs</b>.  For further details, see ml or the
        book <i>Maximum Likelihood Estimation with Stata, 2d Edition</i> (Gould,
        Pitblado, and Sribney 2003).
<p>
    <b>theta(est</b>|<i>#</i><b>)</b> applies only with <b>scale(odds)</b> and estimates the
        transformation parameter (theta) or performs estimation with theta
        set to <i>#</i>. The transformation of the (baseline) survival function
        S_0(t) is then
<p>
        g_theta(S_0(t)) = ln(S_0(t)^(-theta)-1)/theta)
<p>
        theta = 0 corresponds to the cumulative hazards model. With
        <b>theta(est)</b>, theta is estimated and presented on a log scale, i.e.
        ln(theta). With <b>theta(</b><i>#</i><b>)</b>, <i>#</i> must be positive.
<p>
<p>
<b><u>Options for predict</u></b>
<p>
    <b>at(</b><i>varname #</i>|<i>vn</i> [<i>varname #</i>|<i>vn</i> ...]<b>)</b> (syntax 1) computes the various
        statistics at value(s) (<i>#</i> or <i>vn</i>)... of model covariates <i>varname</i>...,
        where <i>vn</i> means "variable name". The <b>at()</b> option is a convenient way
        of specifying out-of-sample prediction for some or all of the
        covariates in the model.  Covariates in <b>stpm</b>'s <i>varlist</i> but NOT listed
        in <b>at()</b> are used in computing predicted values, unless the <b>zero</b>
        option is specified, in which case adjustment is to value 0 of such
        predictors.
<p>
    <b>at(@</b><i>varname #</i>|<i>string</i><b>)</b>(syntax 2) computes the various statistics at the
        mean of the covariate values for observations in which varname equals
        <i>#</i> (if <i>varname</i> is numeric) or in which <i>varname</i> equals <i>string</i> (if
        <i>varname</i> is a string variable). <i>varname</i> may typically be an
        identification number, e.g.  a row number of the dataset. Note that
        <i>varname</i> is not usually one of the covariates in the model (i.e. it is
        not a member of <i>varlist</i>).
<p>
    <b>at(+</b><i>#</i><b>)</b>(syntax 3) computes the various statistics after adding <i>#</i> to the
        linear predictor from the <b>[xb]</b> equation. This can be used to examine
        the effects of applying specific offsets to the predicted values on
        other statisics of interest.
<p>
    <b>deviance</b> creates deviance-like residuals. The same formula is used as in 
        streg.
<p>
    <b>martingale</b> creates martingale-like residuals. The same formula is used as
        in streg.
<p>
    <b>noconstant</b> removes the constant (if any) in equation <b>[xb]</b> when computing
        a statistic of interest. This includes the fitted spline function
        using the <b>spline</b> option.
<p>
    <b>nooffset</b> is relevant only if you specified <b>offset()</b> with <b>stpm</b>.  It
        modifies the calculations made by <b>predict, xb</b> so that they ignore the
        offset variable.  The linear prediction for equation <b>[xb]</b> is treated
        as x*b rather than x*b + offset.
<p>
    <b>stdp</b> computes the standard error of statistics <b>xb</b>, <b>cumhazard</b>, <b>cumodds</b>,
        <b>normal</b>, <b>dzdy</b>, or of the log (note: log) survival time for <b>centile()</b>.
        <b>stdp</b> is also implemented for <b>hazard</b> with hazard-scaled models
        (<b>scale(hazard)</b>) only, when it calculates the S.E. of the log (note:
        log) hazard function. <b>stdp</b> is not implemented for other statistics,
        but note that confidence intervals for the survival function may be
        found by back-transformation of confidence intervals for the
        cumulative hazard or odds or normal function, and those for the
        hazard function similarly, through the formula exp(ln(hazard) +/- z *
        SE(log hazard)).
<p>
    <b>spline</b> computes the fitted spline function. This incorporates all
        covariate effects and by default is evaluated at the observed failure
        times. Use of the <b>zero</b> option evaluates the spline with all covariate
        values set to zero (i.e. the baseline spline). If there are variables
        in the model with time-dependent effects, specified through the
        <b>stratify()</b> option, and the <b>time(</b><i>#</i><b>)</b> option is also used, the result is
        effectively the prognostic index evaluated at time <i>#</i>.
<p>
    <b>store(</b><i>global_macro_name</i> [<i>#</i>]<b>)</b> stores the contents of <i>newvarname</i> in a
        global macro called <i>global_macro_name</i>.  Successive non-missing values
        are stored, separated by spaces.  Optionally, rounding to <i>#</i> decimal
        places is allowed, to save space and make the results more readable.
        The <b>store()</b> option is not often used, but may be helpful when passing
        the output to another program.
<p>
    <b>time(</b><i>#</i>|<i>vn</i><b>)</b> predicts at time <i>#</i> or at the time values in <i>vn</i>. If <b>time()</b> is
        not specified, prediction is made for time _t.
<p>
    <b>tvc(</b><i>varname</i><b>)</b> stands for "time-varying coefficient" and computes the
        estimated coefficient for <i>varname</i>, a covariate in <b>stpm</b>'s <i>varlist</i>. If
        <i>varname</i> is "time-fixed", then <i>newvarname</i> will be a constant, namely
        <b>[xb]_b[</b><i>varname</i><b>]</b>. If <i>varname</i> is included in <i>strat_varlist</i>, then
        <i>newvarname</i> will depend on _t and may be interpreted as the
        time-varying effect of <i>varname</i> on the chosen scale of the model
        (proportional hazards, proportional odds or probit).  For example, in
        a hazards-scale model (<b>scale(hazard)</b>), <i>newvarname</i> multiplied by
        <i>varname</i> will give an estimate of the time-varying log cumulative
        hazard ratio for <i>varname</i> (compared with <i>varname</i> = 0) at every
        observed value of <i>varname</i>. <i>newvarname</i> alone will give the log
        cumulative hazard ratio for a one-unit change in <i>varname</i>. Note that
        the time-varying log cumulative hazard ratio for <i>varname</i> will NOT be
        identical to the time- varying log hazard ratio for <i>varname</i>.
<p>
    <b>zero</b> predicts at zero values of covariates in <i>varlist</i> and similarly for
        <i>strat_varlist</i>, if <b>stratify()</b> is specified. See also option <b>at()</b>.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Let t denote time. <b>stpm</b> works by first calculating the survival function
    S(t) non-parametrically by using the Kaplan-Meier estimator. The
    procedure is illustrated for proportional hazards models, specified by
    option <b>scale(hazard)</b>. S(t) is converted to an estimate of the log
    cumulative hazard function Z(t) by the formula
<p>
        Z(t) = ln(-ln S(t))
<p>
    This Z(t) is then smoothed on ln(t) using regression splines with knots
    placed at certain quantiles of the distribution of t. The knot positions
    are chosen automatically if the spline complexity is specified by the
    <b>df()</b> option, or manually by way of the <b>knots()</b> option. (Note that the
    knots are values of ln(t), not t.) Denote the predicted values of the log
    cumulative hazard function by Zhat(t). The density function f(t) is
<p>
        f(t) = -dS(t)/dt = dS/dZhat dZhat/dt = S(t) exp(Zhat) dZhat(t)/dt
<p>
    dZhat(t)/dt is computed from the regression coefficients of the fitted
    spline function. A smoothed survival function is calculated as
<p>
        Shat(t) = exp(-exp Zhat(t)).
<p>
    The hazard function is calculated as f(t)/Shat(t).
<p>
    If <i>varlist</i> is specified, the baseline survival function (i.e. at zero
    values of the covariates) is used instead of the survival function of the
    raw observations. With <b>df(1)</b> a Weibull model is fitted.
<p>
    With <b>scale(normal)</b>, smoothing is of the Normal quantile function,
    invnorm(1-S(t)), instead of the log cumulative hazard function. With
    <b>df(1)</b> a lognormal model is fitted.
<p>
    With <b>scale(odds)</b>, smoothing is of the log odds of failure function,
    ln((1-S(t))/S(t)), instead of the log cumulative hazard function. With
    <b>df(1)</b> a log-logistic model is fitted.
<p>
    Estimation is performed by maximum likelihood. Optimisation uses the
    default technique (<b>nr</b>, meaning Stata's version of Newton-Raphson
    iteration.
<p>
    As an example of output from <b>stpm</b>, consider the following. A stratifying
    variable <b>nn</b> has two levels, 0 and 1. There are two covariates, <b>x5a</b> and
    <b>x5b</b>, with effects assumed to act proportionately on the cumulative hazard
    function:
<p>
    <b>. stpm x5a x5b nn, stratify(nn) scale(odds) df(2)</b>
<p>
    initial:       log likelihood = -1124.6562
    rescale:       log likelihood = -1124.6562
    rescale eq:    log likelihood = -1124.6562
    Iteration 0:   log likelihood = -1124.6562  
    Iteration 1:   log likelihood =  -1112.096  
    Iteration 2:   log likelihood = -1111.5188  
    Iteration 3:   log likelihood = -1111.5173  
    Iteration 4:   log likelihood = -1111.5173  
    
                                                      Number of obs   =       1
&gt; 289
                                                      Wald chi2(1)    =      10
&gt; .48
    Log likelihood = -1111.5173                       Prob &gt; chi2     =     0.0
&gt; 012
    
    ---------------------------------------------------------------------------
&gt; ---
          _t |      Coef.   Std. Err.       z     P&gt;|z|       [95% Conf. Interv
&gt; al]
    ---------+-----------------------------------------------------------------
&gt; ---
    s0       |
          nn |  -1.735629   .5360622     -3.238   0.001      -2.786292   -.6849
&gt; 664
       _cons |   3.416165   .4057033      8.420   0.000       2.621001    4.211
&gt; 329
    ---------+-----------------------------------------------------------------
&gt; ---
    s1       |
          nn |  -.1167243    .046288     -2.522   0.012      -.2074471   -.0260
&gt; 015
       _cons |   .1590071   .0349978      4.543   0.000       .0904127    .2276
&gt; 016
    ---------+-----------------------------------------------------------------
&gt; ---
    xb       |
         x5a |   .9971947   .1749101      5.701   0.000       .6543773    1.340
&gt; 012
         x5b |   1.844591   .2142359      8.610   0.000       1.424696    2.264
&gt; 486
          nn |  -.5830707   .3702606     -1.575   0.115      -1.308768    .1426
&gt; 267
       _cons |  -2.039426   .2662178     -7.661   0.000      -2.561203   -1.517
&gt; 649
    ---------------------------------------------------------------------------
&gt; ---
    Deviance =  2223.035 (1289 observations.)
<p>
<b><u>Notes on the output</u></b>
<p>
    1. The equations: <b>s0</b> and <b>s1</b> represent the first and second spline basis
    functions, with <b>[s0]_cons</b> and <b>[s1]_cons</b> being the coefficients for value
    0 of the stratifying variable <b>nn</b>, and <b>[s0]_cons</b>+<b>[s0]_b[nn]</b> and
    <b>[s1]_cons</b>+<b>[s1]_b[nn]</b> the coefficients for value 1 of <b>nn</b>.
<p>
    2. If you wanted to test for the need to stratify by <b>nn</b> you could type
    <b>test [s0]nn [s1]nn</b>. This would give a 2 degree of freedom Wald test of
    any difference between the spline functions for <b>nn</b>.
<p>
    3. The value of "Wald chi2(1)" should be ignored.
<p>
<b><u>Reproducing the model</u></b>
<p>
    Sometimes one wishes to reproduce a model, that is, to incorporate the
    linear predictor in <b>[xb]</b> and the spline function representing the
    baseline distribution function without re-fitting any parameters. This
    can be done by using the <b>spline</b>, <b>xb</b> and <b>dzdy</b> options of <b>predict</b> to create
    the necessary variables, and storing the matrix <b>e(Q)</b> for later use. The
    model is reproduced by using the <b>spline()</b>, <b>offset()</b>, <b>noconstant</b> and <b>q()</b>
    options of <b>stpm</b>. The reason for the use of <b>noconstant</b> with <b>predict, xb</b> is
    that the constant of the <b>[xb]</b> equation is already included in the spline
    function by <b>predict, spline</b> and should not be introduced again. A
    specific example:
<p>
        . <b>stpm</b> <i>model_specifications</i>
        . <b>predict sp, spline zero</b>
        . <b>predict dz, dzdy</b>
        . <b>predict xb, xb noconstant</b>
        . <b>matrix Q = e(Q)</b>
<p>
    To refit the model in the subset of the data for which <b>z</b> equals 1 without
    re-estimating any parameters (only the deviance is displayed):
<p>
        . <b>stpm if z==1, offset(xb) spline(sp dz) q(Q) noconstant</b>
<p>
    To re-estimate the constant in the <b>[xb]</b> equation in a subset of the data:
<p>
        . <b>stpm if z==1, offset(xb) spline(sp dz) q(Q)</b>
<p>
    At present, the approach cannot be used to reproduce time-varying models,
    i.e. models fitted with the <b>stratify()</b> option.
<p>
<p>
<b><u>Stored results</u></b>
<p>
    <b>stpm</b> returns the deviance (minus twice the maximised log likelihood) and
    the Akaike Information Criterion (AIC) in scalars <b>e(dev)</b> and <b>e(aic)</b>
    respectively. Additional quantities are stored in <b>e()</b> functions and may
    be inspected by using <b>ereturn list</b>.
<p>
<p>
<b><u>Examples</u></b>
<p>
    <b>. stpm, scale(hazard) df(1)</b>
    <b>. stpm, df(3) scale(normal)</b>
    <b>. stpm, df(3) scale(odds)</b>
    <b>. stpm, df(3) scale(odds) theta(2)</b>
    <b>. stpm, df(3) scale(odds) theta(est)</b>
    <b>. stpm treatmnt, scale(odds) knots(%10 90)</b>
    <b>. xi: stpm x1 x2 x3 i.pop, df(2) scale(o) stratify(i.pop)</b>
    <b>. stpm x1 x2 x3, df(3) scale(h) left(left)</b>
<p>
    <b>. predict s0, survival zero</b>
        [baseline survival function]
    <b>. predict surv3, survival time(3)</b>
        [survival probs at time 3]
    <b>. predict median, centile(50)</b>
        [median survival, given covars]
    <b>. predict semedian, centile(50) stdp</b>
    <b>. predict h0, hazard zero</b>
        [baseline hazard function]
    <b>. predict h1, hazard zero at(z 1)</b>
    <b>. predict lnH, cumhazard at(@@id 25)</b>
        [at covars for obs #id[25]]
<p>
    <b>. gen hr = h1/h0</b>
        [hr is defined for all obs.]
    <b>. predict bz, tvc(z)</b>
        [time-varying coeff for z]
    <b>. predict sbz, tvc(z) stdp</b>
        [SE of bz]
<p>
    <b>. stpm, scale(hazard) df(2)</b>
    <b>. gen times = _n in 1/10</b>
    <b>. predict surv, survival time(times) store(survlist 4)</b>
    <b>. display "$survlist"</b>
<p>
    <b>. stpm x1 x2 x3, df(3) scale(h)</b>
    <b>. matrix q = e(Q)</b>
    <b>. predict spline, spline zero noconstant</b>
    <b>. predict dspline, dzdy</b>
    <b>. stpm x1 x2 x3, spline(spline dspline) scale(h) q(q)</b>
<p>
<p>
<b><u>Auxiliary ado-files</u></b>
<p>
    frac_spl, frac_s3b, mlsurvlf, stpm_p.
<p>
<p>
<b><u>Author</u></b>
<p>
    Patrick Royston, MRC Clinical Trials Unit, London.
    patrick.royston@ctu.mrc.ac.uk
<p>
<p>
<b><u>References</u></b>
<p>
    P. Royston. 2001. Flexible alternatives to the Cox model, and more.  The
    Stata Journal 1:1-28.
<p>
    P. Royston and M. K. B. Parmar. 2002. Flexible proportional-hazards and
    proportional-odds models for censored survival data, with application to
    prognostic modelling and estimation of treatment effects.  Statistics in
    Medicine 21: 2175-2197.
<p>
<p>
<b><u>Also see</u></b>
<p>
</pre>