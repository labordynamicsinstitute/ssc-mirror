<pre>
<p>
-------------------------------------------------------------------------------
            Sequence analysis using Stata -- software demonstration
-------------------------------------------------------------------------------
<p>
<b>Ulrich Kohler, WZB</b>
kohler@wzb.eu
<p>
<b>Christian Brzinsky-Fay, WZB</b>
brzinsky-fay@wzb.eu
<p>
<b>Magdalena Luniak, WZB</b>
<p>
-------------------------------------------------------------------------------
                                   Contents
-------------------------------------------------------------------------------
<p>
<b>Preliminaries</b>
<p>
o Long versus wide
o sqset the data
<p>
<b>The egen functions</b>
<p>
o Generate variables with descriptive information on sequences
o Display contents of e-generated variables
<p>
<b>Descriptive tables</b>
<p>
o Tabulate sequences
o Describe sequences
<p>
<b>Graph sequences</b>
<p>
o Parallel-coordinates plot
o Sequence index plots
<p>
<b>Optimal matching</b>
        
o The sqom command
o Accessing the results
o On speed
<p>
<p>
<a name="datastructure"></a>-------------------------------------------------------------------------------
                               Long versus Wide
-------------------------------------------------------------------------------
<p>
Sequences are entities of their own; i.e., one thinks about sequences in "wide"
form, and that is how datasets are usually structured.
<p>
. use http://www2000.wzb.eu/~kohler/ado/youthemp, clear
<p>
. list id st1-st10 in 1/10
<p>
Many Stata users prefer sequences in "long" form. The programs are therefore
written for data in long form. Hence, to use the programs, one has to reshape
from wide to long.
<p>
. reshape long st, i(id) j(order)
<p>
. list id st in 1/10
<p>
<p>
<a name="sqset"></a>-------------------------------------------------------------------------------
                                sqset the data
-------------------------------------------------------------------------------
<p>
To work with the SQ-Ados, one has to <b>sqset</b> the data. This command works similar
to tsset, stset, or xtset.
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqset</b> <i>elementvar</i> <i>idvar</i> <i>ordervar</i> [<b>,</b> <b>trim</b> <b>rtrim</b> <b>ltrim</b> <b>keeplongest</b>]
<p>
        <b>sqset</b> [<b>,</b> clear]
<p>
<p>
<b><u>Example</u></b>
        
. sqset st id order
<p>
Among other things, <b>sqset</b> checks for gaps, confirms integer order and
uniqueness of sequence-IDs, and confirms order.
<p>
<p>
<a name="sqset"></a>-------------------------------------------------------------------------------
                 Generate variables with summary descriptions
-------------------------------------------------------------------------------
<p>
The SQ-egen functions are used to generate variables that hold a summary
description of each sequence.
<p>
<p>
<b><u>General usage</u></b>
<p>
        <b>egen</b> [<i>type</i>] <i>newvar</i> = <i>sqfcn</i><b>()</b> [<b>,</b> <i>options</i>]
<p>
<p>
<b><u>Examples</u></b>
        
. egen seqlen = sqlength()             &lt;-  Overall length of sequence 
. egen dur1 = sqlength(), element(1)   &lt;-  Overall length of sequence of elemen
&gt; t 1
. egen gaplen = sqgaplength()          &lt;-  Length of gaps
. egen gapcount = sqgapcount()         &lt;-  Number of episodes with gaps
. egen elemnum = sqelemcount()         &lt;-  Number of different elements in sequ
&gt; ence 
. egen chnum = sqepicount()            &lt;-  Number of episodes 
. egen epi1 = sqepicount(), element(1) &lt;-  Number of episodes of element 1
<p>
. describe  
<p>
<p>
Stata keeps track of all variable names that are generated with the SQ-egen
functions. Other SQ-commands automatically use the e-generated variables. The
names of the e-generated variables are stored as together with the dataset.
<p>
<a name="sqstat"></a>-------------------------------------------------------------------------------
                   Display contents of e-generated variables
-------------------------------------------------------------------------------
<p>
The <b>sqstat</b> bundle provides convenient displays for the variables generated with
the SQ-egen functions.
<p>
<p>
<b><u>List features of sequences</u></b>
<p>
. sqstatlist if sex 
. sqstatlist dur1 elemnum chnum, ranks(1/10)
<p>
. preserve
. sqstatlist sex dur1, replace
. describe
. tab sex, sum(dur1)
. restore
<p>
<p>
<b><u>Summarize features of sequences</u></b>
<p>
. sqstatsum
. sqstatsum dur1 epi1 if sex 
<p>
<p>
<b><u>Tabulate features of sequences</u></b>
<p>
. sqstattab1
. sqstattab1 dur1 gaplen
<p>
. sqstattab2 elemnum sex
<p>
. sqstattabsum sex
. sqstattabsum sex, sum(dur1)
<p>
<a name="sqtab"></a>-------------------------------------------------------------------------------
                              Tabulate sequences
-------------------------------------------------------------------------------
<p>
<b>sqtab</b> is used to produce a frequency table of the sequences in the dataset.
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqtab</b> [<i>varname</i>] [<i>if</i>] [<i>in</i>] [<b>,</b> <b>ranks(</b><i>numlist</i><b>)</b> <b>se</b> <b>so</b> <b>nosort</b> <b>gapinclude</b>
            <i>tabulate_options</i>]
<p>
<b><u>Example</u></b>
<p>
. sqtab         
. sqtab, ranks(1/10)         
<p>
<b><u>"Same order" and "Same elements"</u></b>
<p>
<b>sqtab</b> allows a simple definition of similarity of sequences. With the option
<b>so</b>, all sequences that have the same order of elements are collapsed together.
The option<b> se</b> collapses sequences that consist of the same elements.
<p>
. sqtab, so         
. sqtab, se         
<p>
<a name="sqdes"></a>-------------------------------------------------------------------------------
                              Describe sequences
-------------------------------------------------------------------------------
<p>
<b>sqdes</b> produces a descriptive overview of the sequences in the dataset. More
specifically, it shows
<p>
          o the number of elements observable over all sequences (k),
<p>
          o the maximum length of the sequences (l),
<p>
          o the number of possible sequences that might be formed
            with k elements of length l,
<p>
          o the number of different sequences in the dataset, and
<p>
          o the number of sequences that are shared by ... persons
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqdes</b> [<i>if</i>] [<i>in</i>] [<b>,</b> <b>so</b> <b>se</b> <b>graph</b> <b><u>gap</u></b><b>include</b>]
<p>
<p>
<b><u>Examples</u></b>
<p>
. sqdes
. sqdes, so
. sqdes, se graph
<p>
<a name="sqparcoord"></a>-------------------------------------------------------------------------------
                 Graph sequences as parallel-coordinates plot
-------------------------------------------------------------------------------
<p>
<b>sqparcoord</b> produces parallel-coordinates plots of the sequences in the dataset.
In its simplest form, such plots are useful only for very small numbers of
sequences. Therefore, <b>sqparcoord</b> provides several options to produce meaningful
displays even with larger numbers of sequences.
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqparcoord</b> [<i>if</i>] [<i>in</i>] [<b>,</b> <b>ranks(</b><i>numlist</i><b>)</b> <b>so</b> <b>offset(</b><i>#</i><b>)</b> <b>wlines(</b><i>#</i><b>)</b>
            <b>gapinclude</b> <i>twoway_options</i>]
<p>
<p>
<b><u>Examples</u></b>
<p>
. sqparcoord                            &lt;- All sequences (useless) 
. sqparcoord, ranks(1/10) offset(.5)    &lt;- 10 most frequent sequences, with off
&gt; set
. sqparcoord, wlines(7)                 &lt;- Plot frequent sequences much thicker
&gt;  
<p>
. sqparcoord, so ranks(1/10) offset(.5) &lt;- Using "same order" sequences
. sqparcoord, so wlines(7)              &lt;- Plot frequent sequences much thicker
&gt;  
<p>
<p>
<a name="sqindexplot"></a>-------------------------------------------------------------------------------
                    Graph sequences as sequence index plot
-------------------------------------------------------------------------------
<p>
<b>sqparcoord</b> produces a sequence index plot (Brüderl and Scherer 2006).  In these
plots, the episodes of the sequences are plotted as stacked horizontal bars
with colors to separate the different elements.
<p>
As stressed elsewhere, the results of sequence index plots depend on the order
the sequences in the graph. A simple algorithm is used to order of the
sequences in the plot, but results of more sophisticated algorithms can also be
used (for example, results from sqom).
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqindexplot</b> [<i>if</i>] [<i>in</i>] [<b>,</b> <b>ranks(</b><i>numlist</i><b>)</b> <b>se</b> <b>so</b> <b>order(</b><i>varname</i><b>)</b> <b>by(</b>
            <i>varname</i><b>)</b> <b>color(</b><i>colorstyle</i><b>)</b> <b>gapinclude</b> <i>twoway_options</i>]
<p>
<p>
<b><u>Examples</u></b>
<p>
. sqindexplot, color(blue green black yellow red)
. sqindexplot, ranks(1/10)
. sqindexplot, so
. sqindexplot, se
<p>
<p>
<b><u>Note</u></b>
<p>
With sequence index plots, one might overstate the frequency of elements on
"high" levels. This can be minimized by (a) decent ordering and (b) tuning the
aspect ratio.
<p>
<a name="sqom"></a>-------------------------------------------------------------------------------
                           Perform optimal matching
-------------------------------------------------------------------------------
<p>
<b>sqom</b> performs a cluster analysis of sequences on the basis of a distance matrix
produced by the Needleman-Wunsch algorithm. It allows free specification of
"Indel" and "substitution" cost, as well as different kinds of
standardizations. Results are stored for later use.
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>sqom</b> [<i>if</i>] [<i>in</i>] [<b>,</b> <b><u>indel</u></b><b>cost(#)</b> <b><u>sub</u></b><b>cost(</b><i>#</i>|<b>rawdistance</b>|<i>matexp</i>|<i>matname</i>)}
            <b>name(</b><i>varname</i><b>)</b> <b><u>ref</u></b><b>seqid(</b><i>spec</i><b>)</b> <b>full</b> <b>k(</b><i>#</i><b>)</b>
            <b><u>st</u></b><b>andard(</b><i>#</i>|<b>cut</b>|<b>longer</b>|<b>longest</b>|<b>none)</b>
<p>
<p>
<b><u>Examples</u></b>
<p>
. sqom                       &lt;- Default: Indel = 1, subcost = 2
. sqom, indelcost(3)         &lt;- Indel = 3, subcost = indelcost*2
. sqom, subcost(rawdistance) &lt;- Indel = 1, subcost = abs(value1-value2)
<p>
. matrix sub = 0,8,7,3,2\8,0,8,7,3\7,8,0,8,7\3,7,8,0,7\2,3,7,7,0
. sqom, subcost(sub)         &lt;- subcosts from matrix "sub"
<p>
. sqom, standard(cut)         &lt;- cut at length of shortest    
. sqom, standard(6)           &lt;- cut at length of 6
. sqom, standard(longer)      &lt;- divide by the longer of two
<p>
. sqom, full k(2)             &lt;- full dissimilarity matrix
<p>
        
<a name="sqom_results"></a>-------------------------------------------------------------------------------
                     Accessing results of optimal matching
-------------------------------------------------------------------------------
<p>
Results from <b>sqom</b> can be accessed for further analysis. Distances are either
saved as a variable or as a Stata matrix named <b>SQdist</b>. The convenience programs
<b>sqclusterdat</b> and <b>mdsadd</b> helps adding results of cluster analyses and/or
multidimensional scaling to the sequence data.
<p>
<p>
<b><u>Examples</u></b>
<p>
. sqom, name(om1)
. describe om1 
. sqindexplot, order(om1)
<p>
. sqom, full k(2)
. matrix dir
. sqclusterdat
. clustermat wardslinkage SQdist, name(myname) add
. cluster tree myname, cutnumber(20)
. sqclusterdat, return
<p>
. mdsmat SQdist
. predict mdsdim1, saving(mds)
. sqmdsadd using mds
<p>
<p>
</pre>