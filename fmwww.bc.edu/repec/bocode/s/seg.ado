* 2.01 sfr August 2002program define seg    version 6.0    syntax varlist (min=2 max=999 num) [if] [in] /**/     [, Dseg Gseg Hseg Cseg Rseg Pseg Xseg Sseg Nseg /**/     BY(varlist) Unit(varname) BAse(numlist integer miss max=1 >1) /**/     noDISplay GENerate(string) File(string) REPLACE]*------------------------------------------------------------*NOTE: weights are not allowed in this version of seg*NOTE: add population weight by multiplying each unit by pwt*------------------------------------------------------------local ind = "`dseg' `gseg' `hseg' `cseg' `rseg' `pseg' `xseg' `sseg' `nseg'"local nind: word count `ind'if `nind' == 0 {	di in re "at least one of d g h c r p x s n options required"	exit 198}tokenize `generat'local i = 1while "``i''" ~= "" {	local j=`i'+1	if "``i''" == "d" {            local dout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "g" {            local gout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "h" {            local hout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "c" {            local cout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "r" {            local rout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "p" {            local pout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "x" {            local xout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "s" {            local sout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "n" {            local nout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "i" {            local iout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "e" {            local eout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "t" {            local tout ``j''		if "`file'" == "" {confirm new var ``j''}		}	if "``i''" == "u" {            local uout ``j''		if "`file'" == "" {confirm new var ``j''}		}	local i = `i' + 2}if "`file'" ~= "" & "`replace'" == "" {confirm new file `file'}local sorted: sortedbylocal nvars: word count `varlist'local nby: word count `by'if "`base'"=="" {	local base = `nvars'	}if "`generat'" == "" & "`file'" ~= "" {	tokenize `by'	local i = 1	while `i' <= `nby' {		if "``i''" == "Total" {			di in re "Name collision with Total: use generate option to name t"			exit 110 		}		if "``i''" == "nunits" {			di in re "Name collision with nunits: use generate option to name u"			exit 110 		}		if "`dseg'" ~= "" & "``i''" == "Dseg" {			di in re "Name collision with Dseg: use generate option to name d"			exit 110 		}		if "`gseg'" ~= "" & "``i''" == "Gseg" {			di in re "Name collision with Gseg: use generate option to name g"			exit 110 		}		if "`hseg'" ~= "" & "``i''" == "Hseg" {			di in re "Name collision with Hseg: use generate option to name h"			exit 110 		}		if "`cseg'" ~= "" & "``i''" == "Cseg" {			di in re "Name collision with Cseg: use generate option to name c"			exit 110 		}		if "`rseg'" ~= "" & "``i''" == "Rseg" {			di in re "Name collision with Rseg: use generate option to name r"			exit 110 		}		if "`pseg'" ~= "" & "``i''" == "Pseg" {			di in re "Name collision with Pseg: use generate option to name p"			exit 110 		}		if "`xseg'" ~= "" & "``i''" == "Xseg" {			di in re "Name collision with Xseg: use generate option to name x"			exit 110 		}		if "`sseg'" ~= "" & "``i''" == "Sseg" {			di in re "Name collision with Sseg: use generate option to name s"			exit 110 		}		if "`nseg'" ~= "" & "``i''" == "Nseg" {			di in re "Name collision with Nseg: use generate option to name n"			exit 110 		}		if "`dseg'`gseg'`rseg'" ~= "" & "``i''" == "Idiv" {			di in re "Name collision with Idiv: use generate option to name i"			exit 110 		}		if "`hseg'" ~= "" & "``i''" == "Ediv" {			di in re "Name collision with Ediv: use generate option to name e"			exit 110 		}		local i = `i' + 1	}}tokenize `varlist'if "`display'" == "" & `nby' > 1 {	di _n in re "Note: " in bl "Results too complex for display" 	if "`file'" == "" & "`generat'" == "" {      	di in re "Results not stored"		di in re "Use Generate or File option to store results"		exit 198	}}if "`display'" ~= "" & "`file'" == "" & "`generat'" == "" {	di in re "Results will not be stored or displayed"	di in re "Use Generate or File option to store results"	exit 198}marksample tousequi count if `touse'if r(N)==0 {	di in re "no observations"	exit 2000	}*check for no negative valueslocal i = 1while `i' <= `nvars' {	capture assert ``i'' >= 0 if `touse' 	if _rc {		di in r "``i'' has negative values"		exit 411      }	local i = `i'+1}*define unit (default=individual record)tempvar u dqui {if "`unit'" == "" { gen long `u' = _n if `touse' }else { gen double `u' = `unit' if `touse' }*define BY variable (default=all)if "`by'" == "" {	gen str8 `d' = "Total" if `touse'	label var `d' "--------"	local by "`d'"	local noby = 1	}else local noby = 0preserve* end of housekeeping; begin calculation of indices*make unit-level data set of group countssort `by' `u'collapse (sum) `varlist' if `touse', by(`by' `u') cw fast*calculate unit and group totals and percentagestempvar totu totdegen `totu' = rsum(`varlist')egen `totd' = sum(`totu'), by(`by')local r = 1while `r' <= `nvars' {	tempvar pctu`r' totd`r' pctd`r'	gen `pctu`r'' = ``r'' / `totu'	egen `totd`r'' = sum(``r''), by(`by')	gen `pctd`r'' = `totd`r''/`totd'	local r = `r' + 1	}*check for small unit counts (only check if using multiracial indices)tempvar nunitsegen `nunits' = count(`totu'), by(`by')tempvar minunegen `minun' = min(`nunits')local min = `minun'[1]if `min' < `nvars' & "`dseg'`gseg'`hseg'`cseg'`rseg'`pseg'" ~= "" {	if `noby' == 1 {		di in re "Note: Data have fewer units than groups."		di in re "Multigroup indices should be interpreted with caution."		}	else {		di in re "Note: Some by-groups have fewer units than groups."		di in re "Multigroup indices for these by-groups should be interpreted with caution."		}	}*calculate segregation indicesif "`gseg'" ~= "" {*calculate gini index numerator	tempvar gnum	gen `gnum' = 0	local r = 1	while `r' <= `nvars' {		tempvar gur gsumur		sort `by' `pctu`r''		by `by': /**/ gen `gur' = ( `totu' * `pctu`r'' * sum(`totu') - `totu' * /**/ sum( `totu' * `pctu`r'' ) ) / `totd'^2		by `by': gen `gsumur' = sum(`gur')		by `by': replace `gnum' = `gnum' + `gsumur'[_N]		drop `gur' `gsumur'		local r = `r' + 1	}}if "`dseg'" ~= "" {*calculate dissimilarity index numerator	tempvar dnum	gen `dnum' = 0	local r = 1	while `r' <= `nvars' {		tempvar dur dsumur 		gen `dur' = `totu' * abs(`pctu`r''-`pctd`r'') / (2*`totd')		sort `by'		by `by': gen `dsumur' = sum(`dur')		by `by': replace `dnum' = `dnum' + `dsumur'[_N]		drop `dur' `dsumur'		local r = `r' + 1	}}if "`hseg'" ~= "" {*calculate entropy index numerator	tempvar hnum	gen `hnum' = 0	local r = 1	while `r' <= `nvars' {		tempvar hur hsumur 		gen `hur' = `totu' * `pctu`r'' * log(1 / `pctu`r'') / /**/ (`totd' * log(`base'))		replace `hur' = 0 if `pctu`r'' == 0		sort `by'		by `by': gen `hsumur' = sum(`hur')		by `by': replace `hnum' = `hnum' + `hsumur'[_N]		drop `hur' `hsumur'		local r = `r' + 1	}}if "`cseg'`rseg'`pseg'" ~= "" {*calculate c, r, p 	tempvar rnum ctemp ptemp	gen `ctemp' = 0	gen `ptemp' = 0	gen `rnum' = 0	local r = 1	while `r' <= `nvars' {		tempvar crpur		gen `crpur' = `totu' * (`pctd`r'' - `pctu`r'')^2 / `totd'		if "`cseg'" ~= "" {			tempvar cur csumr			gen `cur' = `crpur' / ((`nvars' - 1) * `pctd`r'')			replace `cur' = 0 if `pctd`r'' == 0			sort `by'			by `by': gen `csumr' = sum(`cur')			by `by': replace `ctemp' = `ctemp' + `csumr'[_N]			drop `cur' `csumr'		}		if "`rseg'" ~= "" {			tempvar rsumr			sort `by'			by `by': gen `rsumr' = sum(`crpur')			by `by': replace `rnum' = `rnum' + `rsumr'[_N]			drop `rsumr'		}		if "`pseg'" ~= "" {			tempvar pur psumr			gen `pur' = `crpur' / (1 - `pctd`r'')			replace `pur' = 0 if `pctd`r'' == 1			sort `by'			by `by': gen `psumr' = sum(`pur')			by `by': replace `ptemp' = `ptemp' + `psumr'[_N]			drop `pur' `psumr'		}		drop `crpur'		local r = `r' + 1	}}if "`xseg'`nseg'" ~= "" {*calculate exposure indices	tempvar xu xtemp 	gen `xu' = `pctu1' * `pctu2' * `totu' / (`pctd1' * `totd')	sort `by'	by `by': gen `xtemp' = sum(`xu')	by `by': replace `xtemp' = `xtemp'[_N]	if "`nseg'" ~= "" {		tempvar ntemp		gen `ntemp' = 1 - (`xtemp' / `pctd2') if `pctd2'~=0		replace `ntemp' = 0 if `pctd2'==0 	}	drop `xu'}if "`sseg'" ~= "" {*calculate isolation index	tempvar su stemp	gen `su' = `totu' * `pctu1'^2 / (`pctd1' * `totd')	sort `by'	by `by': gen `stemp' = sum(`su')	by `by': replace `stemp' = `stemp'[_N]	drop `su'}	*make BY-level data set of group countssort `by'collapse (sum) `varlist' (mean) `dnum' `gnum' `hnum' `rnum' `ctemp' `ptemp' /**/ `xtemp' `stemp' `ntemp' `totd' `nunits', by(`by') cw fastlabel var `totd' "Total Count"label var `nunits' "Total Units"if "`dseg'`gseg'`cseg'`rseg'`pseg'" ~= "" {	local r = 1	tempvar I NI	gen `I' = 0	while `r' <= `nvars' {		tempvar pctd`r' ir		gen `pctd`r'' = ``r'' / `totd' 		gen `ir' = `pctd`r'' * (1 - `pctd`r'')		replace `I' = `I' + `ir'		drop `pctd`r'' `ir'		local r = `r' + 1	}	gen `NI' = `nvars' * `I' / (`nvars' - 1)	lab var `I'  "Interaction"	lab var `NI' "Norm. Int. "	format `I' `NI' %6.4f}if "`hseg'" ~= "" {	local r = 1	tempvar E	gen `E' = 0	while `r' <= `nvars' {		tempvar pctd`r' er		gen `pctd`r'' = ``r''/`totd' 		gen `er' = `pctd`r'' * log(1 / `pctd`r'') / log(`base')		replace `er' = 0 if `pctd`r'' == 0		replace `E' = `E'+`er'		drop `pctd`r'' `er'		local r = `r' + 1	}	lab var `E' "Entropy    "	format `E' %6.4f}if "`dseg'" ~= "" {	tempvar D	gen `D' = `dnum' / `I'	replace `D' = 0 if `I' == 0	format `D' %6.4f	label var `D' "Dissim.    "}if "`gseg'" ~= "" {	tempvar G	gen `G' = `gnum' / `I'	replace `G' = 0 if `I' == 0	format `G' %6.4f	label var `G' "Gini       "}if "`hseg'" ~= "" {	tempvar H	gen `H' = 1 - `hnum' / `E'	replace `H' = 0 if `E' == 0	format `H' %6.4f	label var `H' "Inf. Theory "}if "`cseg'" ~= "" {	tempvar C	gen `C' = `ctemp'	replace `C' = . if `totd' == 0	replace `C' = 0 if `I' == 0	format `C' %6.4f	label var `C' "Squared. CV"}if "`rseg'" ~= "" {	tempvar R	gen `R' = `rnum' / `I'	replace `R' = 0 if `I' == 0	format `R' %6.4f	label var `R' "Rel. Diver."}if "`pseg'" ~= "" {	tempvar P	gen `P' = `ptemp'	replace `P' = . if `totd' == 0	replace `P' = 0 if `I' == 0	format `P' %6.4f	label var `P' "Norm. Exp. "}if "`xseg'" ~= "" {	tempvar X	gen `X' = `xtemp'	format `X' %6.4f	label var `X' "Exposure   "}if "`sseg'" ~= "" {	tempvar S	gen `S' = `stemp'	format `S' %6.4f	label var `S' "Isolation  "}if "`nseg'" ~= "" {	tempvar N	gen `N' = `ntemp'	format `N' %8.4f	label var `N' "2G Norm Exp"}*---------------noi {	if "`display'" == "" & `nby' < 2 {		di _n in gr "Group Variables:" _col(20) in ye "`varlist'"		di _n in ye "Total Counts and Diversity Measures"		tabdisp `by', c(`nunits' `totd' `I' `NI' `E') center		di _n in ye "Segregation Measures"		if `nind' > 5 {			tabdisp `by', c(`D' `G' `H' `C' `R') center			tabdisp `by', c(`P' `X' `S' `N') center		}		else {			tabdisp `by', c(`D' `G' `H' `C' `R' `P' `X' `S' `N') center		}	}}keep `by' `totd' `nunits' `I' `NI' `E' `G' `D' `H' `C' `R' `P' `X' `S' `N'*-------------------------------------------------*output code*-------------------------------------------------if "`generat'" ~= "" {	if "`D'" ~= "" { 		if "`dout'" ~= "" {rename `D' `dout'}		else drop `D'	}	if "`G'" ~= "" { 		if "`gout'" ~= "" {rename `G' `gout'}		else drop `G'	}	if "`H'" ~= "" { 		if "`hout'" ~= "" {rename `H' `hout'}		else drop `H'	}	if "`C'" ~= "" { 		if "`cout'" ~= "" {rename `C' `cout'}		else drop `C'	}	if "`R'" ~= "" { 		if "`rout'" ~= "" {rename `R' `rout'}		else drop `R'	}	if "`P'" ~= "" { 		if "`pout'" ~= "" {rename `P' `pout'}		else drop `P'	}	if "`X'" ~= "" { 		if "`xout'" ~= "" {rename `X' `xout'}		else drop `X'	}	if "`S'" ~= "" { 		if "`sout'" ~= "" {rename `S' `sout'}		else drop `S'	}	if "`N'" ~= "" { 		if "`nout'" ~= "" {rename `N' `nout'}		else drop `N'	}	if "`I'" ~= "" { 		if "`iout'" ~= "" {			rename `NI' `iout'			drop `I'		}		else drop `I' `NI'	}	if "`E'" ~= "" { 		if "`eout'" ~= "" {rename `E' `eout'}		else drop `E'	}	if "`tout'" ~= "" {rename `totd' `tout'}	else drop `totd'      if "`uout'" ~= "" {rename `nunits' `uout'}	else drop `nunits'	noi if "`file'" ~= "" {		save `file', `replace'		di _n in bl "Index Values Written to Output File:"		di in ye "`file'"		di	}	else {		tempfile byfile		sort `by'		save `byfile'		noi di _n in bl "Index Values Written to Current File"	}} /* end of the `generat' ~= "" condition */else {	if "`file'" ~= "" {		noi di _n in bl "Index Values Written to Output File:"		noi di in ye "`file'"		rename `totd' Total		rename `nunits' nunits		if "`I'" ~= "" { 			rename `NI' Idiv			drop `I' 		}		if "`E'" ~= "" { rename `E' Ediv }		if "`D'" ~= "" { rename `D' Dseg }		if "`G'" ~= "" { rename `G' Gseg }		if "`H'" ~= "" { rename `H' Hseg }		if "`C'" ~= "" { rename `C' Cseg }		if "`R'" ~= "" { rename `R' Rseg }		if "`P'" ~= "" { rename `P' Pseg }		if "`X'" ~= "" { rename `X' Xseg }		if "`S'" ~= "" { rename `S' Sseg }		if "`N'" ~= "" { rename `N' Nseg }		save `file', `replace'	}}}if "`generat'" ~= "" & "`file'" == "" {	restore, preserve	sort `by'	tempvar merge	merge `by' using "`byfile'", _merge(`merge')	drop `merge'	if "`sorted'" ~= "" {sort `sorted'} 	restore, not}else restoreend