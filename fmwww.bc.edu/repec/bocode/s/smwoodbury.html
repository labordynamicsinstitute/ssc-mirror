<pre>
<b>help smwoodbury</b>
-------------------------------------------------------------------------------
<p>
<b><u>Syntax</u></b>
<p>
        <i>real matrix</i>  <b>smwoodbury_lu(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>,</b> real
            matrix <i>Cinv</i><b>,</b> real matrix <i>V</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_lu_solve(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>,</b>
            real matrix <i>Cinv</i><b>,</b> real matrix <i>V</i><b>,</b> real matrix <i>AinvB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_qr(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>,</b> real
            matrix <i>Cinv</i><b>,</b> real matrix <i>V</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_qr_solve(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>,</b>
            real matrix <i>Cinv</i><b>,</b> real matrix <i>V</i><b>,</b> real matrix <i>AinvB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_lu(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_lu_solve(</b>real matrix <i>Ainv</i><b>,</b> real matrix
            <i>U</i><b>,</b> real matrix <i>AinvB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_qr(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_qr_solve(</b>real matrix <i>Ainv</i><b>,</b> real matrix
            <i>U</i><b>,</b> real matrix <i>AinvB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_posdef(</b>real matrix <i>Ainv</i><b>,</b> real matrix <i>U</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym1_posdef_solve(</b>real matrix <i>Ainv</i><b>,</b> real
            matrix <i>U</i><b>,</b> real matrix <i>AinvB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_lu(</b>real scalar <i>s</i><b>,</b> real matrix <i>U</i><b>,</b> real
            matrix <i>Cinv</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_lu_solve(</b>real scalar <i>s</i><b>,</b> real matrix <i>U</i><b>,</b>
            real matrix <i>Cinv</i><b>,</b> real matrix <i>sB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_qr(</b>real scalar <i>s</i><b>,</b> real matrix <i>U</i><b>,</b> real
            matrix <i>Cinv</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_qr_solve(</b>real scalar <i>s</i><b>,</b> real matrix <i>U</i><b>,</b>
            real matrix <i>Cinv</i><b>,</b> real matrix <i>sB</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_posdef(</b>real scalar <i>s</i><b>,</b> real matrix <i>U</i><b>,</b>
            real matrix <i>Cinv</i><b>)</b>
<p>
        <i>real matrix</i>  <b>smwoodbury_sym2_posdef_solve(</b>real scalar <i>s</i><b>,</b> real matrix
            <i>U</i><b>,</b> real matrix <i>Cinv</i><b>,</b> real matrix <i>sB</i><b>)</b>
<p>
<b><u>Description</u></b>
<p>
    This package provides a set of Mata functions that implement the
    Sherman-Morrison-Woodbury formula for a rank-k update to a matrix inverse
    and that use the formula to efficiently solve matrix equations. The
    formula is:
<p>
    inv(A+U*C*V) = inv(A) - inv(A)*U*inv(inv(C)+V*inv(A)*U)*V*inv(A)
<p>
    where A is NxN, U is NxK, C is KxK, V is KxN.  Use of this formula can
    save computation time when N is much larger than K and either inv(A) is
    easy to calculate or inv(A+U*C*V) must be calculated many times for
    different values of U, C and V.  Such situations arise, for example, in
    Markov chain Monte Carlo estimation of mixed models.
<p>
    Notice that the functions require as input Ainv and Cinv, the inverses of
    A and C, rather than A and C themselves.
<p>
    <b>smwoodbury_lu()</b> and <b>smwoodbury_qr()</b> implement the full formula.  The
    former uses lusolve() and thus assumes Cinv+V*Ainv*U has full rank.  The
    latter uses qrsolve() and will work even when Cinv+V*Ainv*U does not have
    full rank (or is poorly conditioned), but is typically slower.
<p>
    <b>smwoodbury_sym1_lu()</b> and <b>smwoodbury_sym1_qr()</b> implement the special case
    where C=I(K), V=U', and A is symmetric.  The former uses lusolve() and
    thus assumes I(K)+U'*Ainv*U has full rank. This assumption generally
    holds but can fail for unusual values of A and U.  The latter uses
    qrsolve() and will work even when I(K)+U'*Ainv*U does not have full rank
    (or is poorly conditioned), but is typically slower.  To maximize speed,
    <b>smwoodbury_sym1_lu()</b> and <b>smwoodbury_sym1_qr()</b> do not verify that Ainv is
    symmetric.  You may get unexpected results if Ainv is not symmetric.
<p>
    <b>smwoodbury_sym1_posdef()</b> implements the special case where C=I(K), V=U',
    A is symmetric, and I(K)+U'*Ainv*U is positive definite.  To maximize
    speed, the function does not verify that Ainv is symmetric or that
    I(K)+U'*Ainv*U is positive definite. You may get unexpected results if
    these conditions fail.
<p>
    <b>smwoodbury_sym2_lu()</b> and <b>smwoodbury_sym2_qr()</b> implement the special case
    where V=U' and A=I(N)/s for a nonzero scalar s.  The former uses
    lusolve() and thus assumes Cinv+s*U'*U has full rank. This assumption
    generally holds but can fail for unusual values of s and U.  The latter
    uses qrsolve() and will work even when Cinv+s*U'*U does not have full
    rank (or is poorly conditioned), but is typically slower.
<p>
    <b>smwoodbury_sym2_posdef()</b> implements the special case where V=U', A=I(N)/s
    for a nonzero scalar s, Cinv is symmetric, and Cinv+s*U'*U is positive
    definite.  To maximize speed, the function does not verify that Cinv is
    symmetric or that Cinv+s*U'*U is positive definite. You may get
    unexpected results if these conditions fail.
<p>
    Functions <b>smwoodbury_*_solve()</b> are equivalent to the functions without
    <b>solve</b> in the name but are designed to efficiently solve the equation
    (A+U*C*V)X=B for X. These functions require as input either
    AinvB=inv(A)*B or sB=(s*I(N))*B.
<p>
<b><u>Author</u></b>
<p>
    Sam Schulhofer-Wohl
    Federal Reserve Bank of Minneapolis
    90 Hennepin Ave.
    Minneapolis MN 55480-0291
    wohls@minneapolisfed.org
<p>
    The views expressed herein are those of the author and not necessarily
    those of the Federal Reserve Bank of Minneapolis or the Federal Reserve
    System.
<p>
<p>
</pre>