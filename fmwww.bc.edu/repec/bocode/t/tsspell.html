<pre>
-------------------------------------------------------------------------------
help for <b>tsspell</b>
-------------------------------------------------------------------------------
<p>
<b><u>Identification of spells or runs in time series</u></b> 
<p>
<p>
    <b>tsspell</b> [<i>varname</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [<b>,</b> { <b><u>f</u></b><b>cond(</b><i>fcondstr</i><b>)</b> |
          <b><u>c</u></b><b>ond(</b><i>condstr</i><b>)</b> | <b><u>p</u></b><b>cond(</b><i>pcondstr</i><b>)</b> } <b>spell(</b><i>spellvar</i><b>)</b> <b>seq(</b><i>seqvar</i><b>)</b>
          <b>end(</b><i>endvar</i><b>)</b> <b>replace</b> ]
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>tsspell</b> examines the data, which must be tsset time series, to identify
    spells or runs, which are contiguous sequences defined by some condition.
    <b>tsspell</b> generates new variables:
<p>
        (1) indicating distinct spells (0 for not in spell, or integers 1
        up);
<p>
        (2) giving sequence in spell (0 for not in spell, or integers 1 up);
        and
<p>
        (3) indicating whether observations occur at the end of spells (0 or
        1).
<p>
    By default, these variables will be called <b>_spell</b>, <b>_seq</b> and <b>_end</b>.
<p>
    If the data are panel data, all operations are automatically performed
    separately within panels.
<p>
<p>
<b><u>Remarks</u></b> 
<p>
    There are four ways of defining spells in <b>tsspell</b>.
<p>
    First, given
<p>
        <b>tsspell</b> <i>varname</i>
<p>
    a new spell starts whenever <i>varname</i> changes.  Strictly, the condition is
    <b>(</b><i>varname</i> <b>!= L.</b><i>varname</i><b>)</b> <b> | (_n == 1)</b>. (The condition <b>_n == 1</b> is protection
    against the possibility that the first value is missing.)
<p>
    Second, a new spell starts whenever some condition defining the first
    observation in a spell is true. A spell ends just before a new spell
    starts. Such a condition may be specified by the <b>fcond()</b> option.  For
    example, suppose we wish to divide time into spells of consecutive
    values.  A new spell starts whenever <b>L.</b><i>varname</i> is missing, which works
    for the first observation as well because the expression <i>varname</i><b>[0]</b> is
    evaluated as missing.  Spells started by earthquakes, eruptions,
    accidents, revolutions, elections, births or other traumatic events may
    often be defined in this way.
<p>
    Third, spells are defined by some condition being true for every
    observation in the spell. A spell ends when that condition becomes false.
    Such a condition may be specified by the <b>cond()</b> option.
<p>
    Fourth, a special but useful case of the previous kind is <b>cond(</b><i>varname</i><b> &gt;</b>
    <b>0 &amp; </b><i>varname</i><b> &lt; .)</b>; that is, values of <i>varname</i> are positive (but not
    missing).  Given daily data, spells of rain are defined by there being
    some rainfall every day. As a convenience, such conditions may be
    specified by <b>pcond(</b><i>varname</i><b>)</b>, or more generally, <b>pcond(</b><i>expression</i><b>)</b>.
<p>
    Spells are deemed to end at the last observation.
<p>
    Specifying <b>if</b> and/or <b>in</b> adds extra conditions and does not override the
    rule that spells consist of sequences of values.
<p>
    Missing values may be ignored by using <b>if</b> to exclude them. They are not
    ignored by default, as a convenience to users wishing to explore patterns
    of missing values. Recall that numeric missing <b>.</b> is treated as larger
    than any positive number. Thus be careful to exclude missing values where
    appropriate.
<p>
<p>
<b><u>Options</u></b>
<p>
    <b>fcond(</b><i>fcondstr</i><b>)</b> specifies a true or false condition that defines the
        start of a spell: to be precise, the first observation in a spell.  A
        new spell starts whenever this condition is true.
<p>
        If <i>varname</i> is specified, and neither <b>fcond()</b> nor <b>cond()</b> is specified,
        <b>fcond()</b> defaults to <b>(</b><i>varname</i> <b>!= L.</b><i>varname</i><b>) | (_n == 1)</b>.  To span
        gaps, use <b>(</b><i>varname</i> <b>!= </b><i>varname</i><b>[_n-1]) | (_n == 1)</b>.
<p>
    <b>cond(</b><i>condstr</i><b>)</b> specifies a true or false condition that defines a spell.
<p>
    <b>pcond(</b><i>pcondstr</i><b>)</b> is equivalent to
<p>
        <b>cond((</b><i>pcondstr</i><b>) &gt; 0 &amp; (</b><i>pcondstr</i><b>) &lt; .))</b>
<p>
        That is, some expression <i>pcondstr</i> evaluates to a positive number (but
        not missing).  Commonly, the expression is just the name of a numeric
        variable.
<p>
    Only one of <b>fcond()</b>, <b>cond()</b> and <b>pcond()</b> may be specified.
<p>
    <b>end(</b><i>endvar</i><b>)</b> defines a new variable that is 1 at the end of each spell and
        0 otherwise. <b>_end</b> is tried as a variable name if this option is not
        specified.
<p>
    <b>seq(</b><i>seqvar</i><b>)</b> defines a new variable that is the number of observations so
        far in the spell. <b>_seq</b> is tried as a variable name if this option is
        not specified.
<p>
    <b>spell(</b><i>spellvar</i><b>)</b> defines a new variable that is the number of spells so
        far. All observations in the first spell are tagged with 1, all in
        the second with 2, and so on. <b>_spell</b> is tried as a variable name if
        this option is not specified. With panel data, a separate count is
        kept for each panel.
<p>
    <b>replace</b> indicates that any variables created by <b>tsspell</b> may overwrite
        existing variables with the same names.
<p>
 
<b><u>Examples</u></b>
<p>
    Who is in office:
<p>
            <b>. tsspell party</b>
<p>
    Spells are distinct jobs (panel data):
<p>
            <b>. tsspell job</b>
<p>
    Number of spells (panel data):
<p>
            <b>. egen nspells = max(_spell), by(id)</b>
<p>
    Spells of consecutive values of <b>time</b>:
<p>
            <b>. tsspell, f(L.time == .)</b>
<p>
    Rainfall spells:
<p>
            <b>. tsspell, p(rain)</b>
<p>
    Spells in which rainfall was at least 10 mm every day:
<p>
            <b>. tsspell, c(rain &gt;= 10 &amp; rain &lt; .) end(hrend) seq(hrseq)</b>
<p>
    To get information on spell lengths (# observations):
<p>
            <b>. su hrseq if hrend</b>
            <b>. tab hrseq if hrend</b>
<p>
    Length of each spell in a new variable, non-panel and panel data:
<p>
            <b>. egen length = max(_seq), by(_spell)</b>
<p>
            <b>. egen length = max(_seq), by(id _spell)</b>
<p>
    Duration (length in time) of each spell in a new variable, panel data:
<p>
            <b>. egen tmax = max(time), by(id _spell)</b>
            <b>. egen tmin = min(time), by(id _spell)</b>
            <b>. gen duration = tmax - tmin</b>
<p>
    Cumulative totals of <i>varname</i>:
<p>
            <b>. bysort _spell (_seq) : gen total = sum(</b><i>varname</i><b>) if _seq</b>
<p>
    Sums of <i>varname</i>:
<p>
            <b>. egen total = sum(</b><i>varname</i><b>), by(_spell)</b>
<p>
    Spells of growth, stability, decline:
<p>
            <b>. gen sign = sign(D.</b><i>varname</i><b>)</b>
            <b>. tsspell sign</b>
<p>
    Define a recession as at least two quarters' decline in real GDP:
<p>
            <b>. gen sign = sign(D.realGDP)</b>
            <b>. tsspell sign</b>
            <b>. egen qtrs = max(_seq), by(_spell)</b>
            <b>. gen recession = D.realGDP &lt; 0 &amp; qtrs &gt;= 2</b>
<p>
    One observation per spell:
<p>
            <b>.</b> ...<b> if _end</b>
<p>
    A left-censored spell starts at the first relevant observation (so it
    might have started earlier, except that we have no data to determine
    that). A right-censored spell ends at the last relevant observation (so
    it might have ended later, except that we have no data to determine
    that). Indicator variables:
<p>
            <b>. by id : gen byte censoredleft = _seq == 1 &amp; _n == 1</b>
            <b>. by id : gen byte censoredright = _end == 1 &amp; _n == _N</b>
<p>
    A liberal definition of a spell might allow inclusion of periods that
    were no longer than some specified number of observations, even though
    they do not fit the strict definition of that spell. For example, two
    spells of heavy rain separated by a brief period might be regarded,
    meteorologically, as part of the same spell. More generally, we might
    consider including any part of the data that is not part of a strictly
    identified spell, i.e. before the first spell, between two spells, or
    after the last spell. One approach to this is a two-pass process. In the
    second pass, periods omitted from spells on the first pass are themselves
    treated as another kind of spell. Then once the length of each gap has
    been calculated, the new definition is just the old definition <b>or</b> the
    fact that gap lengths are acceptable:
<p>
            <b>. tsspell, cond(_spell == 0) spell(_gap) seq(_gapseq)</b>
            <b>end(_gapend)</b>
            <b>. bysort id _gap: gen _gaplength = _N if _gap</b>
            <b>. tsset</b>
            <b>. tsspell, cond(_spell | _gaplength &lt;= 2) spell(_spell2)</b>
            <b>seq(_seq2) end(_end2)</b>
<p>
<p>
<b><u>Author</u></b>
<p>
    Nicholas J. Cox, University of Durham, U.K.
    n.j.cox@durham.ac.uk
<p>
<p>
<b><u>Acknowledgements</u></b> 
<p>
    Richard Goldstein was the co-author of an earlier program, <b>spell</b>, which
    did not assume <b>tsset</b> data. Kit Baum, Jan Dehn, Stephen Jenkins, Philippe
    Van Kerm and Fred Wolfe made very helpful direct or indirect
    contributions.
<p>
<p>
<b><u>Also see</u></b>
 
On-line: help for tsset, varlist (time series operators)
Manual: <b>[R] tsset</b>, <b>[U] 14.4.3 Time-series varlists</b>
<p>
</pre>