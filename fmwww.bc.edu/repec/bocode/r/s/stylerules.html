<pre>
-------------------------------------------------------------------------------
help for <b>stylerules</b>
-------------------------------------------------------------------------------
<p>
<b><u>Suggestions on Stata programming style</u></b> 
<p>
<p>
<b><u>Introduction</u></b> 
<p>
    Programming in Stata, like programming in any other computer language, is
    partly a matter of syntax - Stata has rules that must be obeyed - and
    partly a matter of style. Good style includes - but is not limited to -
    writing programs that are, above all else, clear. They are clear to the
    programmer, who may revisit them repeatedly, and they are clear to other
    programmers, who may wish to understand them, to debug them, to extend
    them, to speed them up, to imitate them or to plagiarise them.
<p>
    People who program a great deal know this: setting rules for yourself and
    then obeying them ultimately yields better programs and saves time.
<p>
    I suggest one overriding rule:
<p>
        Set and obey programming style rules for yourself.
<p>
    Moreover,
<p>
        Obey each of the rules I suggest unless you can make a case that your
        own rule is as good or better.
<p>
    Enough pious generalities. The devil in programming is in the details:
<p>
<p>
<b><u>Presentation</u></b> 
<p>
    Always include a comment containing the version number of your program,
    your name or initials, and the date the program was last modified above
    the <b>program</b> line. For example,
<p>
        <b>*! 1.0.0 Jane Roe 24jan2003</b>
        <b>program myprog</b>
<p>
    (As said, this line is indeed just a comment line: it bears no relation
    to the Stata version command. Both should be used.)
<p>
    Use sensible, intelligible names where possible, for programs, variables
    and macros.
<p>
    Choose a name for your program that does not conflict with anything
    already existing. Suppose you are contemplating <i>newname</i>. If typing either
    <b>which</b> <i>newname</i> or <b>which</b> <i>newname</i><b>.class</b> gives you a result, StataCorp are
    already using the name. Similarly, if <b>ssc type</b> <i>newname</i><b>.ado</b> gives you a
    result, a program with your name is already on SSC. No result from either
    does not guarantee that the program is not in use elsewhere: <b>findit</b>
    <i>newname</i> may find such a program, although often it will also find much
    that is irrelevant to this point.
<p>
    Brevity of names is also a virtue. However, no platform on which Stata is
    currently supported requires an 8-character limit. Tastes are in
    consequence slowly shifting: an intelligible long name for something used
    only occasionally would usually be considered preferable to something
    more cryptic.
<p>
    Note that actual English words for program names are supposedly reserved
    for StataCorp.
<p>
    Use the same names and abbreviations for command options that are in
    common use in official Stata's commands. Try to adopt the same
    conventions for options syntax: for example, allow a numlist where
    similar commands use a <b>numlist</b>. Implement sensible defaults wherever
    possible.
<p>
    Use natural names for logical constants or variables. Thus <b>local OK</b>
    should be 1 if true and 0 if false, permitting idioms such as <b>if `OK'</b>.
    (But beware such logicals taking on missing values.)
<p>
    Type expressions so they are readable. Some possible rules are
<p>
        put spaces around each binary operator except <b>^</b> (<b>gen z = x + y</b> is
        clear, but <b>x ^ 2</b> looks odder than <b>x^2</b>)
<p>
        <b>*</b> and <b>/</b> allow different choices. <b>num / den</b> is arguably clearer than
        <b>num/den</b>, but readers might well prefer <b>2/3</b> to <b>2 / 3</b>. Overall
        readability is paramount: compare for example
        <b>hours + minutes / 60 + seconds / 3600</b> with
        <b>hours + minutes/60 + seconds/3600</b>
<p>
        put a space after each comma in a function, etc.
<p>
        parenthesise for readability
<p>
    Note, however, that such a spaced-out style may make it difficult to fit
    expressions on one line, another desideratum.
<p>
    Adopt a consistent style for flow control. Stata has if, while, foreach
    and forvalues structures that resemble those in many mainstream
    programming languages. Programmers in those languages often argue
    passionately about the best layout. Choose one such layout for yourself.
<p>
        Here is one set of rules:
<p>
        tab lines consistently after <b>if</b> or <b>else</b> or <b>while</b> or <b>foreach</b> or
        <b>forvalues</b> (the StataCorp convention is that a tab is 8 spaces and is
        greatly preferable if Stata is to show your programs properly)
<p>
        do not put anything on a line after a brace, either an opening { or a
        closing }.
<p>
        put a space before braces
<p>
        align the <b>i</b> of <b>if</b> and the <b>e</b> of <b>else</b>, and align closing braces <b>}</b> with
        the <b>i</b>, or the <b>e</b>, or the <b>w</b> of <b>while</b>, or the <b>f</b> of <b>foreach</b> or <b>forvalues</b>:
<p>
        <b>if</b> ... <b>{</b>
                ...
                ...
        <b>}</b>
<p>
        <b>else {</b>
                ...
                ...
        <b>}</b>
<p>
        <b>while</b> ... <b>{</b>
                ...
                ...
        <b>}</b>
<p>
        <b>foreach</b> ... <b>{</b>
                ...
                ...
        <b>}</b>
<p>
        In Stata 8 up, putting the opening and closing braces on lines above
        and below the body of each construct is compulsory (with the
        exceptions that the whole of an <b>if</b> construct or the whole of an <b>else</b>
        construct may legally be placed on one line). For earlier releases,
        it is strongly advised.
<p>
    Write within 80 columns (72 are even better). The awkwardness of viewing
    (and understanding) long lines outweighs the awkwardness of splitting
    commands into two or more physical lines.
<p>
    Use <b>#delimit ;</b> sparingly (Stata isn't C): commenting out end-of-lines is
    tidier where possible (although admittedly still ugly).  The <b>///</b> comment
    introduced in Stata 8 is most helpful here, and arguably more pleasing
    visually than <b>/* */</b>.
<p>
    Use blank lines to separate distinct blocks of code.
<p>
    Consider putting quietly on a block of statements, rather than on each or
    many of them. An alternative in some cases is to use capture.
<p>
    You may express logical negation by either <b>!</b> or <b>~</b>. Choose one and stick
    with it. StataCorp have flipped from preferring <b>~</b> to preferring <b>!</b>.
<p>
    Group tempname, tempvar and tempfile declarations.
<p>
    Well-written programs don't need many comments. (Comment: We could
    certainly argue about that!)
<p>
    Use appropriate display styles for messages and other output.  All error
    messages (and no others) should be <b>display</b>ed <b>as err</b>.  In addition, attach
    a return code to each error message:  198 (syntax error) will often be
    fine.
<p>
<p>
<b><u>Helpful Stata features</u></b>
<p>
    Stata is very tolerant through version control of out-of-date features,
    but that does not mean that you should be. To maximise effectiveness and
    impact, and to minimise problems, write using the latest version of Stata
    and exploit its features.
<p>
    Make yourself familiar with all the details of syntax. It can stop you
    re-inventing little wheels. Use wildcards for options to pass to other
    commands when appropriate.
<p>
    Support <b>if</b> <i>exp</i> and <b>in</b> <i>range</i> where applicable.  This is best done using
    <b>marksample touse</b> (or occasionally <b>mark</b> and <b>markout</b>).  Have <b>touse</b> as a
    temporary variable if and only if <b>marksample</b> or a related command is
    used. See help on marksample.
<p>
    <b>_result()</b> still works, but it is unnecessarily obscure compared with <b>r()</b>,
    <b>e()</b> or <b>s()</b> class results.
<p>
    Make effective use of information available in <b>e()</b> and <b>r()</b>.  If your
    program is to run in a context which implies results or estimates are
    available (say, after <b>regress</b>), make use of the stored information from
    the prior command.
<p>
    Where appropriate, ensure that your command returns the information that
    it computes and displays, so that another user may employ it quietly and
    retrieve that information.
<p>
    Ensure that programs that focus on time-series or panel data work with
    time-series operators if at all possible. In short, exploit tsset.
<p>
    Define constants to machine precision. Thus use <b>_pi</b> or <b>c(pi)</b> rather than
    some approximation such as 3.14159, or use <b>-digamma(1)</b> for the
    Euler-Mascheroni constant gamma, rather than 0.57721.  Cruder
    approximations may give results adequate for your purposes, but that
    doesn't mean that you should eschew wired-in features.
<p>
    Familiarise yourself with the built-in material revealed by <b>creturn list</b>.
    Scrolling right to the end will show several features that may be useful
    to you.
<p>
    SMCL is the standard way to format Stata output.
<p>
<p>
<b><u>Respect for datasets</u></b> 
<p>
    In general, make no change to the data unless that is the direct purpose
    of your program or that is explicitly requested by the user.  For
    example,
<p>
        your program should not destroy the data in memory unless that is
        essential for what it does
<p>
        you should not create new permanent variables on the side unless
        notified or requested
<p>
        do not use variables, matrices, scalars or global macros whose names
        might already be in use: there is absolutely no need to guess at
        names unlikely to occur, as temporary names can always be used (see
        help on tempvar, tempname, and tempfile)
<p>
        do not change the type of a variable unless requested
<p>
        do not even change the sort order of data: programs can easily be
        made <b>sortpreserve</b>.
<p>
<p>
<b><u>Speed and efficiency</u></b>
<p>
    Test for fatal conditions as early as possible. Do no unnecessary work
    before checking that a vital condition has been satisfied.
<p>
    Use <b>summarize, meanonly</b> for speed when its returned results are
    sufficient. Also consider whether a <b>qui count</b> is what fits the purpose
    better.
<p>
    <b>foreach</b> and <b>forvalues</b> are cleaner and faster than most <b>while</b> loops, and
    much faster than <b>for</b>.  Within programs, avoid <b>for</b> like the plague.
<p>
    <b>macro shift</b> can be very slow when many variables are present.  With
    10,000 variables, for example, working all the way through a variable
    list with <b>macro shift</b> would require around 50 million internal macro
    renames.  Using <b>foreach</b> or <b>while</b> without a macro shift is faster.
<p>
    Avoid <b>egen</b> within programs: it is usually slower than a direct attack.
<p>
    Try to avoid looping over observations, which is very slow. Fortunately,
    it can usually be avoided.
<p>
    Avoid <b>preserve</b> if possible. <b>preserve</b> is attractive to the programmer but
    can be expensive in time for the user with large data files.  Programmers
    should learn to master marksample.
<p>
    Specify the type of temporary variables to minimise memory overhead. So
    if a <b>byte</b> variable can be used, specify <b>generate byte `myvar'</b> rather than
    let the default type be used, which would waste storage space.
<p>
    Temporary variables will be automatically dropped at the end of a
    program, but also consider dropping them when they are no longer needed,
    to minimise memory overhead, and indeed to reduce the chances of your
    program stopping because there is no room to add more variables.
<p>
    Avoid using a variable to hold a constant: a macro or a scalar is usually
    all that is needed.
<p>
<p>
<b><u>Reminders</u></b> 
<p>
    Remember to think about string variables as well as numeric variables.
    Does the task carried out by your program make sense for string
    variables? If so, will it work properly? If not, do you need to trap
    input of a string variable as an error, say through syntax?
<p>
    Remember to think about making your program support <b>by</b> <i>varlist</i><b>:</b> when
    natural. See byable.
<p>
    Remember to think about weights and implement them when natural.
<p>
    The job isn't finished until the <b>.hlp</b> is done.  Use SMCL to set up your
    help files: old-style help files, while supported, are not documented,
    while help files not written in SMCL cannot take advantage of its
    paragraph mode, which allows lines to auto-wrap to fit the desired screen
    width of the user.  For an introduction to the SMCL required to write a
    basic help file, see <b>[U] 21.11.6 Writing on-line help</b> or examplehelpfile.
<p>
<p>
<b><u>Style in the large</u></b> 
<p>
    Style in the large is difficult to prescribe, but here are some vague
    generalities.
<p>
        Before writing a program, do check that it has not been written
        already!  findit is the broadest search tool.
<p>
        The best programs do just one thing well. There are exceptions, but
        what to a programmer is a Swiss army knife with a multitude of useful
        tools may look to many users like a confusingly complicated command.
<p>
        Very large programs become increasingly difficult to understand, to
        build, and to maintain, roughly as some power of their length.
        Consider breaking such programs into subroutines and/or use a
        structure of command and subcommands.
<p>
        The more general code is often both shorter and more robust.
<p>
        Don't be afraid to realise that at some point you may be best advised
        to throw it all away and start again from scratch.
<p>
 
<b><u>Note: Use the best tools</u></b> 
<p>
    Find and use a text editor which you like and which supports programming
    directly. A good editor will, for example, will be smart about indenting
    and will allow you to search for matching braces. Some even show syntax
    highlighting. For much more detailed comments on various text editors for
    Stata users, see http://fmwww.bc.edu/repec/bocode/t/textEditors.html.
<p>
<p>
<b><u>Author</u></b>
<p>
    Nicholas J. Cox, University of Durham, U.K.
    n.j.cox@durham.ac.uk
<p>
<p>
<b><u>Acknowledgements</u></b>
<p>
    Many thanks to Kit Baum, Bill Gould, Alan Riley and Vince Wiggins for
    general benedictions and numerous specific contributions.
<p>
 
<b><u>History</u></b>
<p>
    this version: 12 April 2005
<p>
<p>
<b><u>See also</u></b> 
<p>
    the Stata manuals...
    the Stata <b>.ado</b> code...
<p>
</pre>