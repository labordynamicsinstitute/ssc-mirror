<pre>
<b>help spkde</b>                                                        Version 1.0.0
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>spkde</b> -- Kernel estimation of density and intensity functions for
             two-dimensional spatial point patterns
<p>
<p>
<a name="syntax"></a><b><u>Syntax</u></b>
<p>
        <b>spkde</b> [<i>varlist</i>] [<i>if</i>] [<i>in</i>] using <i>gridpoints</i> [<b>,</b> <i>options</i>]
<p>
<p>
<a name="options1"></a>    <i>options</i><i>                             </i> Description
    -------------------------------------------------------------------------
<a name="main"></a>    Main
    * <b><u>x</u></b><b>coord(</b><i>xvar</i><b>)</b>                       variable containing the x-coordinate
                                           of data points
    * <b><u>y</u></b><b>coord(</b><i>yvar</i><b>)</b>                       variable containing the y-coordinate
                                           of data points
      <b><u>k</u></b><b>ernel(</b><i>kf</i><b>)</b>                         kernel function, where <i>kf</i> is one of
                                           the following: <b><u>qu</u></b><b>artic</b> (default),
                                           <b><u>un</u></b><b>iform</b>, <b><u>no</u></b><b>rmal</b>, <b><u>ne</u></b><b>gexp</b>,
                                           <b><u>tr</u></b><b>iangular</b>, <b><u>ep</u></b><b>anechnikov</b>
      <b><u>trunc</u></b><b>ated(</b><i>t</i><b>)</b>                       truncation parameter for kernel
                                           functions <b>normal</b> and <b>negexp</b>, where
                                           <i>t</i> is a positive number
    * <b><u>b</u></b><b>andwidth(</b><i>method</i><b>)</b>                  method for setting the value of the
                                           kernel bandwidth, where <i>method</i> is
                                           one of the following: <b>fbw</b>, <b>ndp</b>,
                                           <b><u>mix</u></b><b>ed</b>
<p>
<a name="estpar"></a>    Estimation parameters
      <b>fbw(ad</b><i>q</i>|<i>b</i><b>)</b>                         fixed kernel bandwidth, where <i>q</i> is
                                           positive integer and <i>b</i> is a
                                           positive number
      <b>ndp(</b><i>d</i><b>)</b>                             minimum (weighted) number of data
                                           points to be used for kernel
                                           estimation at each grid point,
                                           where <i>d</i> is a positive number
      <b>ndpw(</b><i>ndpwvar</i><b>)</b>                      weight data points by variable
                                           <i>ndpwvar</i> when searching for the
                                           minimum number of data points to
                                           be used for kernel estimation
      <b><u>edge</u></b><b>correction</b>                     apply approximate edge correction
<p>
    Reporting
      <b><u>d</u></b><b>ots</b>                               display job progression dots
      <b><u>noverb</u></b><b>ose</b>                          suppress display of job progression
<p>
    Saving results
    * <b><u>sav</u></b><b>ing(</b><i>kernest</i> [<b>, replace</b>]<b>)</b>        save results to Stata dataset
                                           <i>kernest</i>
    -------------------------------------------------------------------------
    * Required option
<p>
<p>
<a name="desc"></a><b><u>Description</u></b>
<p>
    <b>spkde</b> implements a variety of kernel estimators of both the probability
    density function and the intensity function of two-dimensional spatial
    point patterns.
<p>
    A two-dimensional spatial point pattern <b>S</b> can be defined as a set of <i>data</i>
    <i>points</i> <b>s</b>_<i>i</i> (<i>i</i> = 1, ..., <i>n</i>) located in a two-dimensional study region <i>R</i> at
    coordinates (<i>s_i</i>1, <i>s_i</i>2). Each data point <b>s</b>_<i>i</i> represents the location in
    <i>R</i> of one or more “objects” of some kind: people, events, sites,
    buildings, plants, cases of a disease, etc.
<p>
    In the analysis of spatial point patterns we are often interested in
    determining whether the distribution of the objects of interest within <i>R</i>
    exhibits some form of clustering, as opposed to being random. To explore
    the possibility of clustering, it may be useful to describe the spatial
    point pattern of interest by means of its <i>probability density function</i>
    <i>p</i>(<b>s</b>) and/or its <i>intensity function</i> <i>l</i>(<b>s</b>).
<p>
    The probability density function <i>p</i>(<b>s</b>) defines the probability of
    observing an object at location <b>s</b> in <i>R</i>. In turn, the intensity function
    <i>l</i>(<b>s</b>) defines the expected number of objects per unit area at location <b>s</b>
    in <i>R</i>. Therefore, <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>) differ only by a constant of
    proportionality (Bailey and Gatrell 1995; Waller and Gotway 2004).
<p>
    Both the probability density function <i>p</i>(<b>s</b>) and the intensity function
    <i>l</i>(<b>s</b>) of a given two-dimensional spatial point pattern can be easily
    estimated by means of nonparametric estimators, e.g., kernel estimators.
    <i>Kernel estimators</i> are used to generate a spatially smooth estimate of
    <i>p</i>(<b>s</b>) and/or <i>l</i>(<b>s</b>) at a fine grid of points <b>s</b>_<i>g</i> (<i>g</i> = 1, ..., <i>G</i>) covering
    the study region <i>R</i> (Bailey and Gatrell 1995; Waller and Gotway 2004).
<p>
    <b>spkde</b> computes kernel estimates of both <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>) at a grid of points
    generated by the user-written Stata program spgrid. Expressly, for each
    grid point <b>s</b>_<i>g</i>, <b>spkde</b> computes first the kernel estimate of the intensity
    <i>l</i>(<b>s</b>_<i>g</i>), and then the kernel estimate of the density <i>p</i>(<b>s</b>_<i>g</i>).
<p>
<a name="eq1"></a>    The intensity <i>l</i>(<b>s</b>_<i>g</i>) at each grid point <b>s</b>_<i>g</i> is estimated as follows:
<p>
            ^          <i>c</i>      <i>n</i>     
    (1)     <i>l</i>(<b>s</b>_<i>g</i>) = ----- · SUM <i>k</i>(<i>d_ig</i> / <i>h_g</i>) · <i>y_i</i>
                      <i>A_g</i>    <i>i</i>=1
<p>
    where <i>k</i>(·) is the kernel function - usually a unimodal symmetrical
    bivariate probability density function; <i>d_ig</i> is the Euclidean distance
    between data point <b>s</b>_<i>i</i> and grid point <b>s</b>_<i>g</i>; <i>h_g</i> is the kernel bandwidth -
    i.e., the radius of the kernel function - at grid point <b>s</b>_<i>g</i>; <i>y_i</i> is the
    number of objects located at data point <b>s</b>_<i>i</i>; <i>A_g</i> is the area of the
    subregion of <i>R</i> over which the kernel function is evaluated at grid point
    <b>s</b>_<i>g</i>, possibly corrected for edge effects; and <i>c</i> is a constant of
    proportionality.
<p>
    In turn, the density <i>p</i>(<b>s</b>_<i>g</i>) at each grid point <b>s</b>_<i>g</i> is estimated as
    follows:
<p>
                        ^
            ^           <i>l</i>(<b>s</b>_<i>g</i>)
<a name="eq2"></a>    (2)     <i>p</i>(<b>s</b>_<i>g</i>) = ------------
                       <i>G</i>  ^
                      SUM <i>l</i>(<b>s</b>_<i>j</i>)
                      <i>j</i>=1
<p>
    The estimates of <i>l</i>(<b>s</b>_<i>g</i>) and <i>p</i>(<b>s</b>_<i>g</i>), along with several other auxiliary
    variables, are saved to Stata dataset <i>kernest</i> and can be visualized using
    the user-written Stata program spmap.
<p>
<p>
<a name="section01"></a><b><u>Kernel function</u></b>
<p>
    As shown by Equation 1 above, for each grid point <b>s</b>_<i>g</i>, kernel estimators
    compute a weighted sum of the objects making up the spatial point pattern
    of interest. The weight <i>k</i>(<i>d_ig</i> / <i>h_g</i>) applied to each object is a
    function of the ratio between the object's distance from <b>s</b>_<i>g</i> (<i>d_ig</i>) and
    the value of the kernel bandwidth <i>h_g</i>. In turn, the way weights depend on
    <i>d_ig</i> and <i>h_g</i> is determined by the form of the kernel function <i>k</i>(·) used
    in the analysis.
<p>
    <b>spkde</b> allows to choose among six basic types of kernel function: uniform,
    normal, negative exponential, quartic (the default), triangular, and
    Epanechnikov. Moreover, through specification of option <b>truncated(</b><i>t</i><b>)</b>, it
    is possible to use a truncated version of the normal and negative
    exponential kernel functions.
<p>
    Let <i>z</i> = <i>d_ig</i> / <i>h_g</i> denote the argument of the kernel function, and <i>t</i>&gt;0
    denote a truncation parameter specified with option <b>truncated(</b><i>t</i><b>)</b>. Then,
    the kernel functions made available by <b>spkde</b> can be described as follows:
<p>
        -----------------------------------------------------------------------
        Name                               Formula
        -----------------------------------------------------------------------
        Uniform                            <i>k</i>(<i>z</i>) = 1            if <i>z</i> &lt; 1
                                           <i>k</i>(<i>z</i>) = 0            otherwise
<p>
        Normal                             <i>k</i>(<i>z</i>) = exp(-<i>z</i>²/2)
<p>
        Truncated normal                   <i>k</i>(<i>z</i>) = exp(-<i>z</i>²/2)   if <i>d_ig</i> &lt; <i>h_g</i>·<i>t</i>
                                           <i>k</i>(<i>z</i>) = 0            otherwise
<p>
        Negative exponential               <i>k</i>(<i>z</i>) = exp(-3<i>z</i>)
<p>
        Truncated negative exponential     <i>k</i>(<i>z</i>) = exp(-3<i>z</i>)     if <i>d_ig</i> &lt; <i>h_g</i>·<i>t</i>
                                           <i>k</i>(<i>z</i>) = 0            otherwise
<p>
        Quartic                            <i>k</i>(<i>z</i>) = (1-<i>z</i>²)²      if <i>z</i> &lt; 1
                                           <i>k</i>(<i>z</i>) = 0            otherwise
<p>
        Triangular                         <i>k</i>(<i>z</i>) = (1-<i>z</i>)        if <i>z</i> &lt; 1
                                           <i>k</i>(<i>z</i>) = 0            otherwise
<p>
        Epanechnikov                       <i>k</i>(<i>z</i>) = (1-<i>z</i>²)       if <i>z</i> &lt; 1
                                           <i>k</i>(<i>z</i>) = 0            otherwise
        -----------------------------------------------------------------------
<p>
<p>
<a name="section02"></a><b><u>Kernel bandwidth</u></b>
<p>
    While the precise form of the kernel function has a moderate influence on
    the estimates of <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>), the kernel bandwidth plays a major role
    in kernel estimation, since it determines the degree of smoothing with
    which <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>) are estimated: large bandwidths may result in
    oversmoothing, small bandwidths may retain too much local deatail and
    exhibit spikes at isolated event locations (Bailey and Gatrell 1995;
    Waller and Gotway 2004).
<p>
    <b>spkde</b> allows to choose among three methods for setting the value of the
    kernel bandwidth <i>h_g</i> at each grid point <b>s</b>_<i>g</i>: fixed bandwidth, minimum
    (weighted) number of data points, and mixed.
<p>
    The <i>fixed bandwidth</i> method sets <i>h_g</i> = <i>h</i> at all grid points, where <i>h</i> is a
    positive number expressed in the same unit of measurement (miles,
    kilometers, meters, pixels, etc.) as the grid and data points
    coordinates.
<p>
    The <i>minimum (weighted) number of data points</i> method sets <i>h_g</i> = <i>r_g</i>(<i>ndp</i>),
    where <i>r_g</i>(<i>ndp</i>) is the radius of the smallest circle centered on <b>s</b>_<i>g</i> that
    circumscribes at least <i>ndp</i> (weighted) data points. The quantity <i>ndp</i> can
    express either an unweighted or a weighted number of data points. In the
    latter case, the weight associated with each data point must be stored in
    variable <i>ndpwvar</i> and specified with option <b>ndpw(</b><i>ndpwvar</i><b>)</b>. For discussion
    and illustration of this adaptive method and its applications see, e.g.,
    Bailey and Gatrell (1995), Brundson (1995), Talbot <i>et al.</i> (2000).
<p>
    The <i>mixed</i> method is a combination of the other two methods. Expressly, it
    sets <i>h_g</i> = <i>h</i> if the circle centered on <b>s</b>_<i>g</i> and having radius <i>h</i>
    circumscribes at least <i>ndp</i> (weighted) data points, and <i>h_g</i> = <i>r_g</i>(<i>ndp</i>)
    otherwise.
<p>
<p>
<a name="section03"></a><b><u>Edge correction</u></b>
<p>
    For bounded and truncated kernel functions, the nominal value of the area
    over which the kernel function is evaluated at each grid point <b>s</b>_<i>g</i> (see
    Equation 1 above) equals the area of the kernel window, i.e., of the
    circle centered on <b>s</b>_<i>g</i> and having radius <i>h_g</i> (for bounded functions) or
    <i>h_g·t</i> (for truncated functions, <i>t</i> being the truncation parameter).
    Formally: <i>A_g</i> = 3.1416 · <i>h_g</i>² for bounded functions, and <i>A_g</i> = 3.1416 ·
    (<i>h_g·t</i>)² for truncated functions.
<p>
    For grid points located near the edges of the study region, a greater or
    lesser portion of their kernel window may lie outside the study region,
    so that the densities/intensities computed with the standard formula at
    such grid points may result underestimated (Bailey and Gatrell 1995).
<p>
    Although an accurate assessment of the impact of edge effects and the
    development of proper corrections remain an open area of research (Waller
    and Gotway 2004), some adjustments are possible. <b>spkde</b> implements an
    approximate edge correction that consists in rescaling the area of the
    kernel window at each grid point <b>s</b>_<i>g</i> by a factor <i>ec_g</i> that approximately
    equals the proportion of the kernel window lying within the study region.
    After this correction, <i>A_g</i> = 3.1416 · <i>h_g</i>² · <i>ec_g</i> for bounded functions,
    and <i>A_g</i> = 3.1416 · (<i>h_g·t</i>)² · <i>ec_g</i> for truncated functions.
<p>
    In <b>spkde</b>, the approximate edge correction described above can be applied
    to the estimation of <i>l</i>(<b>s</b>) and <i>p</i>(<b>s</b>) only when a bounded or truncated
    kernel function is used. This includes the uniform, quartic, triangular,
    Epanechnicov, truncated normal, and truncated negative exponential
    functions.
<p>
<p>
<a name="section04"></a><b><u>Input datasets</u></b>
<p>
    <b>spkde</b> makes use of two input datasets: <i>datapoints</i> and <i>gridpoints</i>.
<p>
    <i>datapoints</i> is the dataset that resides in memory when <b>spkde</b> is run. It
    consists of <i>n</i> observations, one for each data point making up the spatial
    point pattern of interest. At the minimum, it must include <i>xvar</i>, a
    numeric variable that contains the x-coordinate of data points, and <i>yvar</i>,
    a numeric variable that contains the y-coordinate of data points. When
    each data point “hosts” more than one object of <i>J</i>&gt;0 different types, then
    <b>spkde</b> must be run specifying a <i>varlist</i> made of <i>J</i> numeric variables, each
    containing the number of objects of a given type located at each data
    point; in this case, dataset <i>datapoints</i> must also include the <i>J</i> variables
    specified in <i>varlist</i>. Finally, dataset <i>datapoints</i> can optionally include
    <i>ndpwvar</i>, a numeric variable sometimes used to set the value of the kernel
    bandwidth.
<p>
    <i>gridpoints</i> is the using dataset invoked by <b>spkde</b> at run time. It is
    generated by the user-written Stata program spgrid and contains the
    spatial grid used by <b>spkde</b> to compute the kernel estimates of <i>p</i>(<b>s</b>_<i>g</i>) and
    <i>l</i>(<b>s</b>_<i>g</i>).
<p>
<p>
<a name="section05"></a><b><u>Output dataset</u></b>
<p>
    <b>spkde</b> routinely generates <i>kernest</i>, a Stata dataset that consists of <i>G</i>
    observations - one for each grid point <b>s</b>_<i>g</i> - and includes the following
    variables:
<p>
         o  <b>spgrid_id</b> is a numeric variable that uniquely identifies the
            cells making up the grid.
<p>
         o  <b>spgrid_xcoord</b> is a numeric variable that contains the
            x-coordinate of each grid point.
<p>
         o  <b>spgrid_ycoord</b> is a numeric variable that contains the
            y-coordinate of each grid point.
<p>
         o  <b>bandwidth</b> is a numeric variable that contains the values of <i>h_g</i>
            (see above).
<p>
         o  <b>ndp</b> is a numeric variable that contains the number of data points
            used for kernel estimation at each grid point.
<p>
         o  <b>A</b> is a numeric variable that contains the values of <i>A_g</i> (see
            above).
<p>
    If no <i>varlist</i> is specified, three additional variables are included in
    dataset <i>kernest</i>:
<p>
         o  <b>c</b> is a numeric variable that contains the value of <i>c</i> (see above).
<p>
         o  <b>lambda</b> is a numeric variable that contains the kernel estimate of
            <i>l</i>(<b>s</b>_<i>g</i>) (see above).
<p>
         o  <b>p</b> is a numeric variable that contains the kernel estimate of
            <i>p</i>(<b>s</b>_<i>g</i>) (see above).
<p>
    On the other hand, if a <i>varlist</i> is specified, for each variable <i>varname</i>
    in <i>varlist</i> three additional variables are included in dataset <i>kernest</i>:
<p>
         o  <i>varname</i><b>_c</b> is a numeric variable that contains the value of <i>c</i> for
            objects of type <i>varname</i>.
<p>
         o  <i>varname</i><b>_lambda</b> is a numeric variable that contains the kernel
            estimate of <i>l</i>(<b>s</b>_<i>g</i>) for objects of type <i>varname</i>.
<p>
         o  <i>varname</i><b>_p</b> is a numeric variable that contains the kernel estimate
            of <i>p</i>(<b>s</b>_<i>g</i>) for objects of type <i>varname</i>.
<p>
    When option <b>ndpw(</b><i>ndpwvar</i><b>)</b> is specified, an additional variable is
    included in dataset <i>kernest</i>:
<p>
         o  <b>wndp</b> is a numeric variable that contains the weighted number of
            data points used for kernel estimation at each grid point.
<p>
    Finally, when option <b>edgecorrection</b> is specified, an additional variable
    is included in dataset <i>kernest</i>:
<p>
         o  <b>edgecorrect</b> is a numeric variable that contains the edge
            correction factor <i>ec_g</i> (see above).
<p>
<p>
<a name="section06"></a><b><u>Visualization of kernel estimates</u></b>
<p>
    The kernel estimates of <i>l</i>(<b>s</b>_<i>g</i>) and <i>p</i>(<b>s</b>_<i>g</i>) generated by <b>spkde</b> can be
    visualized using the user-written Stata program spmap.
<p>
    To this purpose, two datasets are needed:
<p>
         o  <i>kernest</i> is the output dataset routinely generated by <b>spkde</b> (see
            section Output dataset above).
<p>
         o  <i>gridcells</i> is one of the two output datasets generated by the
            user-written Stata program spgrid.
<p>
    To visualize the kernel estimates of interest, spmap must be run with
    <i>kernest</i> as the <i>master</i> dataset, and <i>gridcells</i> as the <i>basemap</i> dataset.
<p>
<p>
<a name="section07"></a><b><u>Alternative applications</u></b>
<p>
    Although <b>spkde</b> has been designed to carry out kernel estimation of
    density and intensity functions for two-dimensional spatial point
    patterns, it can be used also for estimating the joint probability
    density function <i>p</i>(<i>x</i>,<i>y</i>) of any pair of quantitative variables <i>X</i> and <i>Y</i>
    (see section Examples 2 - Alternative applications below).
<p>
<p>
<a name="options2"></a><b><u>Options</u></b>
<p>
        +------+
    ----+ Main +-------------------------------------------------------------
<p>
    <b>xcoord(</b><i>xvar</i><b>)</b> specifies the name of the variable containing the
        x-coordinate of each data point <b>s</b>_<i>i</i>.
<p>
    <b>ycoord(</b><i>yvar</i><b>)</b> specifies the name of the variable containing the
        y-coordinate of each data point <b>s</b>_<i>i</i>.
<p>
    <b>kernel(</b><i>kf</i><b>)</b> specifies the basic type of kernel function to be used in the
        estimation of <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>) (for details, see section Kernel function
        above).
<p>
        <b>kernel(quartic)</b> is the default and requests that the quartic kernel
            function be used.
<p>
        <b>kernel(uniform)</b> requests that the uniform kernel function be used.
<p>
        <b>kernel(normal)</b> requests that the normal kernel function be used.
<p>
        <b>kernel(negexp)</b> requests that the negative exponential kernel function
            be used.
<p>
        <b>kernel(triangular)</b> requests that the triangular kernel function be
            used.
<p>
        <b>kernel(epanechnikov)</b> requests that the Epanechnikov kernel function
            be used.
<p>
    <b>truncated(</b><i>t</i><b>)</b> applies only when option <b>kernel(normal)</b> or <b>kernel(negexp)</b> is
        specified. It requests that, for each grid point <b>s</b>_<i>g</i>, the selected
        kernel function be evaluated only within a distance <i>h_g·t</i> from <b>s</b>_<i>g</i>,
        where <i>t</i> is a positive number.
<p>
    <b>bandwidth(</b><i>method</i><b>)</b> specifies the method to be used for setting the value
        of the kernel bandwidth <i>h_g</i> at each grid point <b>s</b>_<i>g</i> (for details, see
        section Kernel bandwidth above).
<p>
        <b>bandwidth(fbw)</b> requests that the <b>f</b>ixed <b>b</b>and<b>w</b>idth method be used.
<p>
        <b>bandwidth(ndp)</b> requests that the minimum (weighted) <b>n</b>umber of <b>d</b>ata
            <b>p</b>oints method be used.
<p>
        <b>bandwidth(mixed)</b> requests that the mixed method be used.
<p>
        +-----------------------+
    ----+ Estimation parameters +--------------------------------------------
<p>
    <b>fbw(ad</b><i>q</i>|<i>b</i><b>)</b> sets the value of <i>h</i> as defined in section Kernel bandwidth
        above.
<p>
        <b>fbw(ad</b><i>q</i><b>)</b> sets <i>h</i> = <i>adq</i>, where <i>adq</i> equals the average distance between
            each data point <b>s</b>_<i>i</i> and its <i>q</i> nearest data points.
<p>
        <b>fbw(</b><i>b</i><b>)</b> sets <i>h</i> = <i>b</i>.
<p>
    <b>ndp(</b><i>d</i><b>)</b> sets the value of <i>ndp</i> as defined in section Kernel bandwidth
        above, namely <i>ndp</i> = <i>d</i>.
<p>
    <b>ndpw(</b><i>ndpwvar</i><b>)</b> specifies that <i>ndp</i> denotes a weighted number of data points
        and the weights are stored in variable <i>ndpwvar</i>.
<p>
    <b>edgecorrection</b> requests that an approximate edge correction be applied to
        the estimation of <i>p</i>(<b>s</b>) and <i>l</i>(<b>s</b>) (for details, see section Edge
        correction above).
<p>
        +-----------+
    ----+ Reporting +--------------------------------------------------------
<p>
    <b>dots</b> requests that job progression dots be displayed.
<p>
    <b>noverbose</b> requests that the display of every indicator of job progression
        be suppressed.
<p>
        +----------------+
    ----+ Saving results +---------------------------------------------------
<p>
    <b><u>sav</u></b><b>ing(</b><i>kernest</i> [<b>, replace</b>]<b>)</b>} requests that the kernel estimates of <i>p</i>(<b>s</b>_<i>g</i>)
        and <i>l</i>(<b>s</b>_<i>g</i>) (<i>g</i> = 1, ..., <i>G</i>), along with a set of auxiliary variables,
        be saved to dataset <i>kernest</i>. If specified, suboption <b>replace</b> requests
        that dataset <i>kernest</i> be overwritten if already existing.
<p>
<p>
<a name="ex1"></a><b><u>Examples 1 </u></b>-<b><u> Standard applications</u></b>
<p>
<b>    . spgrid using "Italy-OutlineCoordinates.dta",   ///</b>
<b>        resolution(w10) unit(kilometers)             ///</b>
<b>        cells("GridCells.dta")                       ///</b>
<b>        points("GridPoints.dta")                     ///</b>
<b>        replace compress dots</b>
<p>
<b>    . use "Italy-DataPoints.dta", clear</b>
<b>    . spkde using "GridPoints.dta",     ///</b>
<b>        xcoord(xcoord) ycoord(ycoord)   ///</b>
<b>        bandwidth(fbw) fbw(100) dots    ///</b>
<b>        saving("Kde.dta", replace)</b>
<b>    . use "Kde.dta", clear</b>
<b>    . spmap lambda using "GridCells.dta",     ///</b>
<b>         id(spgrid_id) clnum(20)              ///</b>
<b>         fcolor(Rainbow) ocolor(none ..)      ///</b>
<b>         legend(off)                          ///</b>
<b>         point(data("Italy-DataPoints.dta")   ///</b>
<b>         x(xcoord) y(ycoord))</b>
<p>
<b>    . use "Italy-DataPoints.dta", clear</b>
<b>    . spkde using "GridPoints.dta",     ///</b>
<b>        xcoord(xcoord) ycoord(ycoord)   ///</b>
<b>        bandwidth(fbw) fbw(100) dots    ///</b>
<b>        edgecorrect                     ///</b>
<b>        saving("Kde.dta", replace)</b>
<b>    . use "Kde.dta", clear</b>
<b>    . spmap lambda using "GridCells.dta",     ///</b>
<b>         id(spgrid_id) clnum(20)              ///</b>
<b>         fcolor(Rainbow) ocolor(none ..)      ///</b>
<b>         legend(off)                          ///</b>
<b>         point(data("Italy-DataPoints.dta")   ///</b>
<b>         x(xcoord) y(ycoord))</b>
<p>
<b>    . use "Italy-DataPoints.dta", clear</b>
<b>    . spkde using "GridPoints.dta",     ///</b>
<b>        xcoord(xcoord) ycoord(ycoord)   ///</b>
<b>        kernel(normal)                  ///</b>
<b>        bandwidth(fbw) fbw(ad5) dots    ///</b>
<b>        saving("Kde.dta", replace)</b>
<b>    . use "Kde.dta", clear</b>
<b>    . spmap lambda using "GridCells.dta",     ///</b>
<b>         id(spgrid_id) clnum(20)              ///</b>
<b>         fcolor(Rainbow) ocolor(none ..)      ///</b>
<b>         legend(off)                          ///</b>
<b>         point(data("Italy-DataPoints.dta")   ///</b>
<b>         x(xcoord) y(ycoord))</b>
<p>
<b>    . use "Italy-DataPoints.dta", clear</b>
<b>    . spkde using "GridPoints.dta",     ///</b>
<b>        xcoord(xcoord) ycoord(ycoord)   ///</b>
<b>        bandwidth(ndp) ndp(4) dots      ///</b>
<b>        saving("Kde.dta", replace)</b>
<b>    . use "Kde.dta", clear</b>
<b>    . spmap lambda using "GridCells.dta",     ///</b>
<b>         id(spgrid_id) clnum(20)              ///</b>
<b>         fcolor(Rainbow) ocolor(none ..)      ///</b>
<b>         legend(off)                          ///</b>
<b>         point(data("Italy-DataPoints.dta")   ///</b>
<b>         x(xcoord) y(ycoord))</b>
<p>
<b>    . use "Italy-DataPoints.dta", clear</b>
<b>    . spkde dcvd95 pop95 using "GridPoints.dta",   ///</b>
<b>        xcoord(xcoord) ycoord(ycoord)              ///</b>
<b>        bandwidth(fbw) fbw(100) dots               ///</b>
<b>        saving("Kde.dta", replace)</b>
<b>    . use "Kde.dta", clear</b>
<b>    . generate ratio = dcvd95_lambda / pop95_lambda * 1000</b>
<b>    . spmap ratio using "GridCells.dta",      ///</b>
<b>         id(spgrid_id) clnum(20)              ///</b>
<b>         fcolor(Rainbow) ocolor(none ..)      ///</b>
<b>         legend(off)</b>
<p>
<p>
<a name="ex2"></a><b><u>Examples 2 </u></b>-<b><u> Alternative applications</u></b>
<p>
    As mentioned above, <b>spkde</b> can be used also for estimating the joint
    probability density function of any pair of quantitative variables (for
    an alternative, see Stata program kdens2, written by Christopher F. Baum
    and available from the Boston SSC Archive). spmap can then be used to
    generate the corresponding density plot. To this purpose, it is advised
    to make use of mylabels, a Stata program written by Nicholas J. Cox and
    available from the Boston SSC Archive.
<p>
    As an example, let us estimate and plot the bivariate probability density
    function for two of the variables included in the <b>auto</b> dataset: <b>mpg</b> and
    <b>price</b>. This can be done in four steps as follows:
<p>
    1. Normalize variables in the range [0,1]
<p>
<b>    . sysuse "auto.dta", clear</b>
<b>    . summarize price mpg</b>
<b>    . clonevar x = mpg</b>
<b>    . clonevar y = price</b>
<b>    . replace x = (x-0) / (50-0)</b>
<b>    . replace y = (y-0) / (20000-0)</b>
<b>    . mylabels 0(10)50, myscale((@-0) / (50-0)) local(XLAB)</b>
<b>    . mylabels 0(5000)20000, myscale((@-0) / (20000-0)) local(YLAB)</b>
<b>    . keep x y</b>
<b>    . save "xy.dta", replace</b>
<p>
    2. Generate a 100x100 grid
<p>
<b>    . spgrid, shape(hexagonal) xdim(100)   ///</b>
<b>        xrange(0 1) yrange(0 1)            ///</b>
<b>        dots replace                       ///</b>
<b>        cells("2D-GridCells.dta")          ///</b>
<b>        points("2D-GridPoints.dta")</b>
<p>
    3. Estimate the bivariate probability density function
<p>
<b>    . spkde using "2D-GridPoints.dta",   /// </b>
<b>        xcoord(x) ycoord(y)              ///</b>
<b>        bandwidth(fbw) fbw(0.1) dots     ///</b>
<b>        saving("2D-Kde.dta", replace)</b>
<p>
    4. Display the density plot
<p>
<b>    . use "2D-Kde.dta", clear</b>
<b>    . recode lambda (.=0)</b>
<b>    . spmap lambda using "2D-GridCells.dta",      ///</b>
<b>        id(spgrid_id) clnum(20) fcolor(Rainbow)   ///</b>
<b>        ocolor(none ..) legend(off)               ///</b>
<b>        point(data("xy.dta") x(x) y(y))           ///</b>
<b>        freestyle aspectratio(1)                  ///</b>
<b>        xtitle(" " "Mileage (mpg)")               ///</b>
<b>        xlab(`XLAB')                              ///</b>
<b>        ytitle("Price" " ")                       ///</b>
<b>        ylab(`YLAB', angle(0))</b>
<p>
<p>
<b><u>Acknowledgments</u></b>
<p>
    I wish to thank Nick Cox for helpful suggestions.
<p>
<p>
<b><u>Author</u></b>
<p>
    Maurizio Pisati
    Department of Sociology and Social Research
    University of Milano Bicocca - Italy
    maurizio.pisati@unimib.it
<p>
<p>
<b><u>References</u></b>
<p>
    Bailey, T.C. and A.C. Gatrell. 1995. <i>Interactive Spatial Data</i> <i>Analysis</i>.
        Harlow: Longman.
<p>
    Brundson, C. 1995. Estimating Probability Surfaces for Geographical Point
        Data: An Adaptive Kernel Algorithm.<i> Computers &amp; Geosciences</i> 21:
        877-894.
<p>
    Talbot, T.O., Kulldorff, M., Forand, S.P. and V.B. Haley. 2007.
        Evaluation of Spatial Filters To Create Smoothed Maps of Health Data.
        <i>Statistics in Medicine</i> 19: 2399-2408.
<p>
    Waller, L.A. and C.A. Gotway. 2004. <i>Applied Spatial Statistics</i> <i>for Public</i>
        <i>Health Data</i>. Hoboken NJ: Wiley.
<p>
<p>
<b><u>Also see</u></b>
<p>
    Online:  <b>spgrid</b> (if installed), <b>spmap</b> (if installed), <b>mylabels</b> (if
             installed)
</pre>