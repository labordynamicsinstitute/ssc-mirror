#delim ;
prog def robit, eclass byable(recall) prop(ml_score swml svyb svyj svyr mi);
version 16.0;
*
 Robit wrapper for glm.
 with added estimation results.
*!Author: Roger Newson
*!Date: 21 December 2021
*;


*
 Check that all necessary Stata packages are present
*;
qui _whichlist robit1 robit2 robit3 robit4 robit5 robit6 robit7 robit8,
  pack(xlink);
local incpackages `"`r(incomplete)'"';
if "`incpackages'"!="" {;
  disp as error "robit requires the following SSC packages to be installed:"
    _n as result `"`incpackages'"';
  disp as error "To install these packages, type:";
  foreach IP in `incpackages' {;
    disp as result "ssc install `IP'";
  };
  error 498;
};


if(replay()){;
*
 Beginning of replay section (not indented)
*;

if "`e(cmd)'"!="glm"{;error 301;};
if _by() {;
  error 190;
};
syntax [, Level(cilevel) EForm ];
glm, level(`level') `eform';

*
 End of replay section (not indented)
*;
};
else {;
*
 Beginning of non-replay section (not indented)
*;

syntax varlist(numeric fv ts) [if] [in] [fweight pweight iweight aweight] [,
  DFRObit(numlist integer >=1 <=8 min=1 max=1)
  Family(passthru) Level(cilevel) EForm * ];
if "`dfrobit'"=="" local dfrobit 7;
if `"`family'"'=="" local family "family(bernoulli)";


* Identify sample to use *;
marksample touse;


* Run glm *;
disp _n as text "Robit regression";
glm `varlist' if `touse' [`weight'`exp'] , level(`level') `eform'
  `family' link(robit`dfrobit') `options';
if !inlist(lower(e(varfunct)),"binomial","bernoulli")
  disp "Warning: Variance function not binomial or Bernoulli";


* Change e(cmdline) (but not e(cmd)) to refer to robit *;
ereturn local cmdline `"robit `0'"';


* Add e(depvarsum) *;
local yvar "`e(depvar)'";
if "`e(wtype)'"=="fweight" {;
  qui summ `yvar' [`e(wtype)'`e(wexp)'] if e(sample), meanonly;
};
else {;
  qui summ `yvar' if e(sample), meanonly;
};
ereturn scalar depvarsum=r(sum);


* Add e(msum) *;
if `"`e(m)'"'!="" {;
  tempvar mvar;
  qui gene long `mvar'=`e(m)';
  qui compress `mvar';
  if "`e(wtype)'"=="fweight" {;
    qui summ `mvar' [`e(wtype)'`e(wexp)'] if e(sample), meanonly;
  };
  else {;
    qui summ `mvar' if e(sample), meanonly;
  };  
};
ereturn scalar msum=r(sum);


*
 Restore r() results
*;
if "`eform'"=="eform" {;
  local exteform "eform(exp(b))";
};
qui ereturn display, level(`level') `exteform';


*
 End of non-replay section (not indented)
*;
};

end;


#delim ;
prog def _whichlist, rclass;
version 16.0;
/*
 Input a list of which input items
 and optionally a package list
 and output lists of present and absent items
 and complete and incomplete packages.
*/


syntax anything(name=itemlist) [ , Packagelist(namelist) NOIsily ];
*
 packagelist() specifies a list of packages
   for the items to belong to.
 noisily specifies that whichlist will have the output generated by which
   for each item in the item list.
*;
local Nitem: word count `itemlist';

*
 Extend packagelist if required
*;
if "`packagelist'"!="" {;
  local Npackage: word count `packagelist';
  if `Npackage' < `Nitem' {;
    local lastpackage: word `Npackage' of `packagelist';
    forv i1=`=`Npackage'+1'(1)`Nitem' {;
      local packagelist "`packagelist' `lastpackage'";
    };
  };
};


*
 Create present, absent, complete, and incomplete lists
*;
if "`packagelist'"=="" {;
  * Create present and absent lists only *;
  forv i1=1(1)`Nitem' {;
    local itemcur: word `i1' of `itemlist';
    cap `noisily' which `itemcur';
    if _rc local absent `"`absent' `itemcur'"';
    else local present `"`present' `itemcur'"';
  };
};
else {;
  * Create present, absent, complete, and incomplete lists *;
  forv i1=1(1)`Nitem' {;
    local itemcur: word `i1' of `itemlist';
    local packagecur: word `i1' of `packagelist';
    cap `noisily' which `itemcur';
    if _rc {;
      local absent `"`absent' `itemcur'"';
      local incomplete "`incomplete' `packagecur'";
    };
    else {;
      local present `"`present' `itemcur'"';
      local complete "`complete' `packagecur'";
    };
  };
  local incomplete: list uniq incomplete;
  local incomplete: list sort incomplete;
  local complete: list uniq complete;
  local complete: list complete - incomplete;
  local complete: list sort complete;
};
local present: list uniq present;
local present: list sort present;
local absent: list uniq absent;
local absent: list sort absent;


*
 List results
*;
if `"`present'"'!="" {;
  disp as text "Present items:";
  disp as result `"`present'"';
};
if `"`absent'"'!="" {;
  disp as text "Absent items:";
  disp as result `"`absent'"';
};
if "`complete'"!="" {;
  disp as text "Complete packages:";
  disp as result `"`complete'"';
};
if "`incomplete'"!="" {;
  disp as text "Incomplete packages:";
  disp as result `"`incomplete'"';
};


*
 Return results
*;
foreach R in incomplete complete absent present {;
  return local `R' `"``R''"';
};


end;

