<pre>
-------------------------------------------------------------------------------
help for <b>invcise</b>                                                 (Roger Newson)
-------------------------------------------------------------------------------
<p>
<b><u>Compute standard errors using the inverse confidence interval method</u></b>
<p>
        <b>invcise</b> <i>lb_varname</i> <i>ub_varname</i> [ <i>dof_varname</i> ] [<i>if</i>] [<i>in</i>] , <b><u>std</u></b><b>err(</b>
                     <i>newvarname</i><b>)</b> [ <b>eformestimate(</b><i>varname</i><b>)</b> <b><u>l</u></b><b>evel(</b><i>#</i><b>)</b> <b>replace</b>
                     <b>float</b> <b>fast</b> ]
<p>
    where <i>lb_varname</i>, <i>ub_varname</i> and <i>dof_varname</i> are the names of existing
    variables, containing lower confidence bounds, upper confidence bounds,
    and degrees of freedom, respectively.
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>invcise</b> is intended for use in an output dataset (or resultsset), with
    one observation for each of a set of estimated parameters, and variables
    containing their confidence limits, and (optionally) containing the
    degrees of freedom used to calculate these confidence limits.  Such
    datasets may be produced using the official Stata <b>statsby</b> prefix, or by
    the <b>parmest</b> package, downloadable from SSC.  <b>invcise</b> uses the confidence
    limits to compute a new variable, containing standard errors for the
    parameters, using the inverse confidence interval method.  These standard
    errors, together with parameter estimates in another variable in the
    dataset, may be used to calculate standard errors and confidence
    intervals for linear combinations of these parameters, using the <b>metaparm</b>
    module of the <b>parmest</b> package, assuming that the parameters are
    independently estimated.  The inverse confidence interval method is
    frequently used with rank statistics, such as medians, median
    differences, and median slopes, to compute confidence intervals for
    linear combinations of these rank statistics, particularly differences
    between differences ("interactions") or weighted means of several
    differences ("meta-analysis summaries").
<p>
<p>
<b><u>Options</u></b>
<p>
    <b>stderr(</b><i>newvarname</i><b>)</b> is required.  It specifies the name of a new variable
        to be created, containing standard errors computed from the input
        confidence limit variables using the inverse confidence interval
        method.
<p>
    <b>eformestimate(</b><i>varname</i><b>)</b> specifies the name of a variable, assumed to be an
        exponentiated estimate corresponding to the input confidence limits,
        and implying that the standard error must be calculated from the log
        ratio of the confidence limits, multiplied by the <b>eformestimate()</b>
        variable, and then scaled inversely by twice the critical <i>t</i>-value or
        <i>z</i>-value corresponding to the confidence level specified by <b>level()</b>.
        If <b>eformestimate()</b> is not specified, then the standard error is
        calculated from the difference between the confidence limits, scaled
        inversely by twice the critical <i>t</i>-value or <i>z</i>-value corresponding to
        the confidence level specified by <b>level()</b>.  The <b>eformestimate()</b>
        option is useful if the standard errors are used with the
        <b>eformestimate()</b> variable for input to the <b>metaparm</b> or <b>parmcip</b> modules
        of the <b>parmest</b> package, using the <b>eform</b> option of these modules to
        produce exponentiated confidence intervals.  Such exponentiated
        confidence intervals may be used to estimate parameters which are
        ratios, ratios of ratios, or geometric mean ratios.
<p>
    <b>level(</b><i>#</i><b>)</b> specifies the confidence level assumed for the input confidence
        limits, expressed as a percentage.  If <b>level()</b> is not specified, then
        <b>invcise</b> first attempts to extract the confidence level from the
        variable characteristic <i>lb_varname</i><b>[level]</b>, and then (if this attempt
        fails) attempts to extract the confidence level from 
        <i>ub_varname</i><b>[level]</b>, and then (if this attempt also fails) extracts the
        confidence level from the c-class value <b>c(level)</b>, which contains the
        default confidence level in force in Stata at the time, which is
        usually set to 95 to specify 95% confidence limits.  The variable
        characteristic <i>varname</i><b>[level]</b> is created, for a confidence limit
        variable with the name <i>varname</i>, by the modules of the <b>parmest</b>
        package, which all set this characteristic to be equal to the
        confidence level used in calculating the confidence limit variable.
<p>
    <b>replace</b> specifies that any non-input variable with the same name as the
        new variable specified by the <b>stderr()</b> option will be discarded
        before the new standard error variable is created.
<p>
    <b>float</b> specifies that float is the highest-precision numeric type to be
        allowed for the <b>stderr()</b> variable.  If <b>float</b> is not specified, then
        the <b>stderr()</b> variable is created as a double variable.  Whether or
        not <b>float</b> is specified, the <b>stderr()</b> variable is compressed to the
        lowest precision possible without loss of informstion.
<p>
    <b>fast</b> is an option for programmers.  It specifies that <b>invcise</b> will take
        no action to restore the existing dataset in memory in the event of
        failure, or if the user presses Break.  If <b>fast</b> is not specified,
        then <b>invcise</b> will take this action, which uses an amount of time
        depending on the size of the dataset in memory.
<p>
<p>
<b><u>Methods and formulas</u></b>
<p>
    <b>invcise</b> computes standard errors using the inverse confidence interval
    method, which is an inversion of the method commonly used to compute
    confidence limits from estimates and standard errors.
<p>
    The default formula (if <b>eformestimate()</b> is not specified) used to derive
    a standard error <i>SE</i> by inverting a 100*(1-<i>alpha</i>)% confidence interval
    with lower bound <i>lb</i> and upper bound <i>ub</i> is
<p>
    <i>SE = 0.5*(ub - lb)/z(alpha)</i>
<p>
    (where <i>z(alpha)</i> is the result of <b>invnorm(1-</b><i>alpha</i><b>/2)</b>) if no degrees of
    freedom variable is specified, and is
<p>
    <i>SE = 0.5*(ub - lb)/t(df,alpha)</i>
<p>
    (where <i>t(df,alpha)</i> is the result of <b>invttail(</b><i>df</i><b>,1-</b><i>alpha</i><b>/2)</b> and <i>df</i> is the
    degrees of freedom) if a degrees of freedom variable is specified.
<p>
    If the <b>eformestimate()</b> option is specified, then the formula used is
<p>
    <i>SE = 0.5*eformestimate*(log(ub) - log(lb))/z(alpha)</i>
<p>
    (where <i>eformestimate</i> is the variable specified by <b>eformestimate()</b>) if no
    degrees of freedom variable is specified, and is
<p>
    <i>SE = 0.5*eformestimate*(lof(ub) - log(lb))/t(df,alpha)</i>
<p>
    if a degrees of freedom variable is specified.
<p>
    These formulas are typically used with confidence intervals for rank
    statistics, such as percentiles and percentile differences.  Lehmann
    (1963) discussed a standard error formula of this kind for Hodges-Lehmann
    median differences.  McKean and Schrader (1984) discussed a standard
    error formula of this kind for medians, which was slightly modified by
    Bonett and Price (2001).
<p>
    Usually, standard error formulas are a means to the end of calculating
    confidence intervals.  The reason for inverting the usual practice is to
    calculate confidence intervals for linear combinations of independently
    estimated parameters, such as medians or median differences from
    independent subsamples from distinct subpopulations.  These linear
    combinations are typically either weighted averages, or differences, or
    weighted averages of differences (as in a meta-analysis), or differences
    between differences (known as interactions, and viewed as important by
    some scientists).  Bonett and Price (2002) discuss the general case of
    linear combinations of medians, and Price and Bonett (2002) discuss the
    special case of differences (and ratios) between two medians.  Given a
    list of independently-estimated parameters <i>theta_1, ..., theta_N</i>, with
    corresponding standard errors <i>se_1, ..., se_N</i>, and corresponding
    coefficients <i>a_1, ..., a_N</i>, we wish to estimate the linear combination
<p>
    <i>Theta = Sum ( a_j * theta_j )</i>
<p>
    and its standard error
<p>
    <i>SE = sqrt( Sum (a_j * se_j)^2</i> )
<p>
    and we can easily do this using the <b>metaparm</b> module of the <b>parmest</b>
    package, once the standard errors have been calculated using <b>invcise</b>.  We
    usually expect the Central Limit Theorem to work better for the linear
    combination than for its component parameters, which may be better
    estimated using their original confidence intervals, which were inverted
    using <b>invcise</b> to give their standard errors.
<p>
<p>
<b><u>Examples</u></b>
<p>
    The following sequence of commands reads in the <b>auto</b> data and adds a
    variable <b>odd</b>, indicating whether a car model is odd-numbered or
    even-numbered.  This dataset is used in the examples, which compare
    differences in mileage between non-US cars and US cars within the
    odd-numbered and even-numbered groups.
<p>
        <b>.sysuse auto, clear</b>
        <b>.gene byte odd=mod(_n,2)</b>
        <b>.lab def odd 0 "Even" 1 "Odd"</b>
        <b>.lab val odd odd</b>
        <b>.lab var odd "Odd numbered model"</b>
        <b>.describe</b>
        <b>.tab foreign odd, m</b>
<p>
    The following example starts by using <b>centile</b>, with the <b>statsby</b> prefix,
    to replace the dataset in memory with a new dataset, with one observation
    for each of 4 groups, defined by combinations of values for the variables
    <b>odd</b> and <b>foreign</b>, and variables containing group numbers in <b>N</b>, and
    estimates and lower and upper confidence bounds for the group medians in
    <b>median</b>, <b>medmin</b> and <b>medmax</b>.  We then use <b>invcise</b> to compute a standard
    error for each median, and use <b>metaparm</b> to replace the new dataset with a
    third dataset, with one observation per group defined by a value of <b>odd</b>,
    and data on confidence intervals and <i>P</i>-values for differences between
    median values in non-US and US cars in the group.  The second <b>metaparm</b>
    command lists a confidence interval for the difference (or interaction)
    between the foreign-US difference in odd-numbered models and the
    foreign-US difference in even-numbered models.  The third <b>metaparm</b>
    command lists a confidence interval for the weighted mean foreign-US
    difference, averaging the differences in odd-numbered and even-numbered
    cars.
<p>
        <b>.preserve</b>
        <b>.statsby N=r(N) median=r(c_1) medmin=r(lb_1) medmax=r(ub_1), by(odd</b>
            <b>foreign) noisily clear: centile mpg</b>
        <b>.list odd foreign N median medmin medmax</b>
        <b>.invcise medmin medmax, stderr(icse)</b>
        <b>.metaparm [iweight=(foreign==1)-(foreign==0)], by(odd) norestore</b>
            <b>sumvar(N) estimate(median) stderr(icse)</b>
        <b>.list odd N median min95 max95 p</b>
        <b>.metaparm [iweight=(odd==1)-(odd==0)], sumvar(N) estimate(median)</b>
            <b>stderr(icse) list(,)</b>
        <b>.metaparm [aweight=N], sumvar(N) estimate(median) stderr(icse)</b>
            <b>list(,)</b>
        <b>.restore</b>
<p>
    The following example compares Hodges-Lehmann median foreign-US
    differences, which are not necessarily the same parameters as foreign-US
    differences between medians.  We start by using the <b>censlope</b> module of
    the <b>somersd</b> package, together with the <b>parmby</b> module of the <b>parmest</b>
    package, to replace the dataset in memory with a new dataset, with one
    observation per value of <b>odd</b>, and data on confidence intervals and
    <i>P</i>-values for foreign-US median differences.  We then use <b>invcise</b> to
    compute standard errors inversely from the confidence limits.  The first 
    <b>metaparm</b> command lists a confidence interval and a <i>P</i>-value for the
    odd-even difference (or interaction) between foreign-US median
    differences.  The second <b>metaparm</b> command lists a confidence interval for
    the weighted mean of the two foreign-US median differences, summarizing
    the foriegn-US differences in the two groups.  The confidence intervals
    are slightly slimmer than the corresponding confidence intervals in the
    previous example, although they are for different parameters.
<p>
        <b>.preserve</b>
        <b>.parmby "censlope mpg foreign, tdist estaddr", by(odd) escal(N)</b>
            <b>norestore ecol(cimat) rename(es_1 N ec_1_1 percent ec_1_2 meddif</b>
            <b>ec_1_3 mdmin ec_1_4 mdmax)</b>
        <b>.describe</b>
        <b>.list odd N dof meddif mdmin mdmax</b>
        <b>.invcise mdmin mdmax dof, stderr(icse)</b>
        <b>.metaparm [iweight=(odd==1)-(odd==0)] , sumvar(N) estimate(meddif)</b>
            <b>stderr(icse) dof(dof) list(,)</b>
        <b>.metaparm [aweight=N], sumvar(N) estimate(meddif) stderr(icse)</b>
            <b>dof(dof) list(,)</b>
        <b>.restore</b>
<p>
    The following example is similar to the previous example, but compares
    Hodges-Lehmann median foreign/US ratios instead of Hodges-Lehmann median
    foreign/US differences.  We start by creating the variable <b>logmpg</b> as the
    log of <b>mpg</b>, and estimate the Hodges-Lehmann median ratios by
    exponentiating the Hodges-Lehmann median differences for <b>logmpg</b>.  We then
    use <b>invcise</b>, with the <b>eformestimate()</b> option, to calculate inverse
    confidence interval standard errors for the median ratios.  These are
    then input into <b>metaparm</b> as before, except that, this time, we use the
    <b>eform</b> option of <b>metaparm</b>, to estimate the odd/even ratios between
    foreign/US ratios, and to estimate the weighted geometric mean foreign/US
    ratio.
<p>
        <b>.preserve</b>
        <b>.gene logmpg=log(mpg)</b>
        <b>.parmby "censlope logmpg foreign, tdist estaddr eform", eform by(odd)</b>
            <b>escal(N) norestore ecol(cimat) rename(es_1 N ec_1_1 percent</b>
            <b>ec_1_2 medrat ec_1_3 mrmin ec_1_4 mrmax)</b>
        <b>.describe</b>
        <b>.list odd N dof medrat mrmin mrmax</b>
        <b>.invcise mrmin mrmax dof, stderr(icse) eformestimate(medrat)</b>
        <b>.metaparm [iweight=(odd==1)-(odd==0)] , sumvar(N) estimate(medrat)</b>
            <b>stderr(icse) dof(dof) eform list(,)</b>
        <b>.metaparm [aweight=N], sumvar(N) estimate(medrat) stderr(icse)</b>
            <b>dof(dof) eform list(,)</b>
        <b>.restore</b>
<p>
    The <b>parmest</b> and <b>somersd</b> packages can both be downloaded from SSC.
<p>
<p>
<b><u>Saved results</u></b>
<p>
    <b>invcise</b> saves the following in <b>r()</b>:
<p>
    Scalars        
      <b>r(level)</b>            confidence level
<p>
    Macros         
      <b>r(lb)</b>               name of lower confidence bound variable
      <b>r(ub)</b>               name of upper confidence bound variable
      <b>r(dof)</b>              name of degrees of freedom variable
      <b>r(eformestimate)</b>    name of <b>eformestimate()</b> variable
      <b>r(levelsource)</b>      source of confidence level
<p>
<p>
    The returned result <b>r(levelsource)</b> may be <b>level()</b>, <i>lb_varname</i><b>[level]</b>,
    <i>ub_varname</i><b>[level]</b>, or <b>c(level)</b>, indicating that the confidence level was
    derived from the <b>level()</b> option, from the <b>level</b> characteristic of the
    lower bound variable, from the <b>level</b> characteristic of the upper bound
    variable, or from the c-class value <b>c(level)</b>, respectively.
<p>
<p>
<b><u>Author</u></b>
<p>
    Roger Newson, National Heart and Lung Institute, Imperial College London,
    UK.
    Email: r.newson@imperial.ac.uk
<p>
<p>
<b><u>References</u></b>
<p>
    Bonett, D. G. and Price, R. M.  2002.  Statistical inference for a linear
        function of medians:  Confidence intervals, hypothesis testing, and
        sample size requirements.  <i>Psychological Methods</i> 7(3): 370-383.
<p>
    Lehmann, E. L.  1963.  Nonparametric confidence intervals for a shift
        parameter.  <i>Annals of Mathematical Statistics</i> 34(4): 1507-1512.
<p>
    McKean, J. W. and Schrader, R. M.  1984.  A comparison of methods for
        studentizing the sample median.  <i>Communications in Statistics -</i>
        <i>Simulation and Computation</i> 13(6): 751-773.
<p>
    Price, R. M. and Bonett, D. G.  2002.  Distribution-free confidence
        intervals for difference and ratio of medians.  <i>Journal of</i>
        <i>Statistical Computation and Simulation</i> 72(2): 119-124.
<p>
    Price, R. M. and Bonett, D. G.  2001.  Estimating the variance of the
        sample median.  <i>Journal of Statistical Computing and Simulation</i>
        68(3): 295-305.
<p>
<p>
<b><u>Also see</u></b>
<p>
     Manual: <b>[R] centile</b>, <b>[D] statsby</b>
    On-line: help for <b>centile</b>, <b>statsby</b>
             help for <b>parmest</b>, <b>parmby</b>, <b>parmcip</b>, <b>metaparm</b>, <b>somersd</b>, <b>censlope</b>, 
             <b>cendif</b> if installed
</pre>