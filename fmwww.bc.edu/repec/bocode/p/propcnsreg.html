<pre>
-------------------------------------------------------------------------------
help for <b>propcnsreg</b>
-------------------------------------------------------------------------------
<p>
<b><u>Fitting a measurement model with causal indicators</u></b>
<p>
        <b>propcnsreg</b> <i>depvar</i> [<i>indepvars</i>] [<i>if</i>] [<i>in</i>] [<i>weight</i>] <b>,</b>
                 <b><u>con</u></b><b>strained(</b><i>varlist_c</i><b>)</b> <b>lambda(</b><i>varlist_l</i><b>)</b> [ <b><u>stand</u></b><b>ardized</b>
                 <b>lcons</b> <b>unit(</b><i>varname</i><b>)</b> <b>mimic</b> <b>logit</b> <b>poisson</b> <b>vce(</b><i>vcetype</i><b>)</b> <b><u>r</u></b><b>obust</b>
                 <b><u>cl</u></b><b>uster(</b><i>clustervar</i><b>)</b> <b><u>l</u></b><b>evel(</b><i>#</i><b>)</b> {<b>or</b> | <b><u>ir</u></b><b>r</b>} <b>wald</b>
                 <i>maximize_options</i> ]
<p>
    <b>by</b> <i>...</i> <b>:</b> may be used with <b>propcnsreg</b>; see help by.
<p>
    <b>fweight</b>s, <b>pweight</b>s, <b>aweight</b>s, and <b>iweight</b>s are allowed; see help weights.
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>propcnsreg</b> combines information from several observed variables into a
    single latent variable and estimates the effect of this latent variable
    on the dependent variable. <b>propcnsreg</b> assumes that the observed variables
    influence the latent variable. A common alternative assumption is that
    the latent variable influences the observed variables. For example,
    factor analysis is based in this alternative assumption. To distinguish
    between these two situations some authors, following Bollen (1984) and
    Bollen and Lennox (1991), call the observed variables "effect indicators"
    when they are influenced by the latent variable, while they call the
    observed variables "causal indicators" when they influence the latent
    variable.  Distinguishing between these two is important as they require
    very different strategies for recovering the latent variable. In a basic
    (exploratory) factor analysis, which is a model for effect indicators,
    one assumes that the only thing that the observed variables have in
    common is the latent variable, so any correlation between the observed
    variables must be due to the latent variable, and it is this correlation
    that is used to recover the latent variable. In <b>propcnsreg</b>, which
    estimates models for causal indicators, we assume that the latent
    variable is a weighted sum of the observed variables (and optionally an
    error term), and the weights are estimated such that they are optimal for
    predicting the dependent variable.
<p>
    Models for dealing with causal indicators come in roughly three flavors:
    A model with "sheaf coefficients" (Heise 1972), a model with
    "parametricaly weighted covariates" (Yamaguchi 2002), and a Multiple
    Indicators and Multiple Causes (MIMIC) model (Hauser Goldberger 1971).
    The latter two can be estimated using <b>propcnsreg</b>, while the former can be
    estimated using <b>sheafcoef</b>, which is also available from SSC.
<p>
<p>
        +-------------------+
    ----+ Sheaf coefficient +------------------------------------------------
<p>
    The sheaf coefficient is the simplest model of the three. Say we want to
    explain a variable y using three observed variables x1, x2, and x3, and
    we think that x1 and x2 actually influence y through a latent variable
    eta.  Because eta is a latent variable we need to fix the origin and the
    unit. The origin can be fixed by setting eta to 0 when both x1 and x2 are
    0, the unit can be fixed by setting the standard deviation of eta equal
    to 1. The model starts with simple regression model, where the b-s are
    the regression coefficients and e a normally distributed error term, with
    a mean of 0 and a standard deviation that is to be estimated:
<p>
        (1) y = b0 + b1 x1 + b2 x2 + b3 x3 + e
<p>
    and we want to turn this into, where l is the effect of the latent
    variable and the c-s are the effects of the observed variables on the
    latent variable:
<p>
        (2) y = b0 + l eta + b3 x3 + e
<p>
        (3) eta = c0 + c1 x1 + c2 x2
<p>
<p>
    We can fix the origin of eta by constraining c0 to be 0, this way eta
    will be 0 when both x1 and x2 equal 0. This leaves c1 and c2. We want to
    choose values for these parameters such that eta optimally predicts y,
    and the standard deviation of eta equals 1. This means that c1 and c2 are
    going to be a transformation of b1 and b2. We can start with an initial
    guess that c1 equals b1 and c2 equals b2, and call the resulting latent
    variable eta'. This will get us closer to where we want to be, as we now
    have values for all parameters:  c0=0, c1'=b1, c2'=b2, and l'=1. The
    value for l' is derived from the fact that that is the only value where
    equations (2) and (3) lead to equation (1).  However, the standard
    deviation of eta' will generally not be equal to 1, actually we can
    calculate the standard deviation of eta' as follows:
<p>
        sd(eta') = sqrt{b1^2 var(x1) + b2^2 var(x2) + 2 b1 b2 cov(x1, x2)}
<p>
    We can recover eta by dividing eta' by its standard deviation, which
    means that the true values of c1 and c2 are actually b1/sd(eta') and
    b2/sd(eta'). If we divide eta' by its standard deviation, then we must
    multiply l' by that same number to ensure that equations (2) and (3)
    continue to lead to equation (1).  As a consequence l will equal
    sd(eta').
<p>
    Notice that the effect of the latent variable will thus always be
    positive.  This is necesary because we have only specified the origin and
    unit of the latent variable but not its direction. Say, x1 is the
    proportion of vegetables in a person's diet and x2 the number minutes
    spent a day excercizing. If we did not fix the effect of the latent
    variable to be positive, then there would always be two sets of estimates
    that would represent exactly the same information. If the c's are
    positive then the latent variable represent the healtyness of someone's
    lifestyle, and if the c's are negative then the latent variable represent
    the unhealtyness of that person's lifestyle. Saying that the healthyness
    of someone's lifestyle has a positive effect is exactly the same as
    saying that the unhealthyness of someone's lifestyle has a negative
    effect. Stata can't choose between these two, since both statements are
    the same, so we need to choose for it. We can do so by either fixing the
    direction of the latent variable or fixing the direction of the effect.
    The default is to fix the direction of the effect, but we can also
    specify one key variable and fix the direction of the latent variable
    relative to this key variable either by stating that the latent variable
    is high when the key variable is high and low when the key variable is
    low, or exactly the opposite.
<p>
    This illustrates how the following set assumptions can be used to recover
    the latent variable and its effect of the dependent variable:
<p>
        - the latent variable is a weighted sum of the observed variables
        such that the latent variable optimally predicts the dependent
        variable.
<p>
        - a constraint that fixes the origin of the latent variable.
<p>
        - a constraint that fixes the unit of the latent variable.
<p>
        - a constraint that either fixes the direction of the latent variable
        or the direction of the effect of the latent variable.
<p>
    However, a sheaf coefficient just reorders the information you obtained
    from a regular regression. It is just a different way of looking at the
    regression results, which can be useful but it does not impose a testable
    constraint.
<p>
    One possible application of the sheaf coefficient is the comparison of
    effect sizes of different blocks of variables. For example, we may have a
    block of variables representing the family situation of the respondent
    and another block of variables representing characteristics of the work
    situation and we wonder whether the work situation or the family
    situation is more important for determining a certain outcome variable.
    In that case we would estimate a model with two latent variables, one for
    the family situation and one for the work situation, and since both
    latent variables are standardized their effects will be comparable.
<p>
<p>
        +------------------------------------+
    ----+  Parametricaly weighted covariates +-------------------------------
<p>
    The model with parametricaly weighted covariates builds on the model with
    sheaf coefficients, but adds a testable constraint by assuming that the
    effect of the latent variable changes over another observed variable.
    This means that instead of equation (2) we will be estimating equation
    (4) where the effect of eta changes over x3:
<p>
        (4) y = b0 + (l0 + l1 x3) eta + b3 x3 + e
<p>
    If we replace eta with equation (3), and fix the unit of eta by
    constraining c0 to be zero, we get:
<p>
        y = b0 + (l0 + l1 x3) (c1 x1 + c2 x2) + b3 x3 + e
<p>
        = b0 + (l0 + l1 x3) c1 x1 + (l0 + l1 x3) c2 x2 + b3 x3 + e
<p>
    This means the effect of x1 (through eta) on y equals (l0 + l1 x3) c1,
    and that the effect of x2 (through eta) on y equals (l0 + l1 x3) c2. This
    implies the following constraint: for every value of x3, the effect of x1
    relative to x2 will always be {(l0 + l1 x3) c1} / {(l0 + l1 x3) c2} =
    c1/c2, which is a constant. In other words, the model with parametricaly
    weighted covariates imposes a proportionality constraint. A test of this
    constraint is reported at the bottom of the output from <b>propcnsreg</b> (when
    the <b>mimic</b> option is not specified).
<p>
    This proportionality constraint can also be of substantive interest
    without referring to a latent variable. Consider a model where one wants
    to explain the respondent's education (<i>ed</i>) with the eduction of the
    father (<i>fed</i>) and the mother (<i>med</i>), and that one is interested in testing
    whether the relative contribution of the mother's education has increased
    over time. <b>propcnsreg</b> will estimate this model under the null hypothesis
    that the relative contributions of <i>fed</i> and <i>med</i> have remained constant
    overtime. Notice that the effects of <i>fed</i> and <i>med</i> are allowed to change
    over time, but the effects of <i>fed</i> and <i>med</i> are constrained to change by
    the same proportion over time. So if the effect of <i>fed</i> drops by 10% over
    a decade, than so does the effect of <i>med</i>.
<p>
    <b>propcnsreg</b> will allow you to identify the unit of the latent variable in
    one of the following three ways:
<p>
        - By setting its standard deviation of the latent variable to 1,
        effectively standardizing the latent variable. This is the default
        parametrization , but can also be explicitly requesting by specifying
        the <b>standardized</b> option. One can specify one key variable by
        prefixing that variable in the <b>constrained</b> option with either a <b>+</b> or
        a <b>-</b>. The <b>+</b> means that the latent variable is high when the key
        variable is high and the latent variable is low when the key variable
        is low. The <b>-</b> means exactly the opposite. If no key variable is
        specified then l0 is constrained to be postive.
<p>
        - By setting the coefficient l0 to 1, which means that c1 and c2
        represent the indirect effects of x1 and x2 through the latent
        variable on y when x3 equals 0.
<p>
        - By setting either the coefficient c1 or c2 to 1, which means that
        the unit of the latent variable will equal the unit of either x1 or
        x2 respectively. This can be done by specifying the <b>unit(</b><i>varname</i><b>)</b>
        option.
<p>
<p>
        +-------+
    ----+ MIMIC +------------------------------------------------------------
<p>
    The MIMIC model builds on the model with parametricaly weighted
    covariates by assuming that the latent variable is measured with error.
    This means that the following model is estimated:
<p>
        (5) y = b0 + (l0 + l1 x3) eta + b3 x3 + e_y
<p>
        (6) eta = c0 + c1 x1 + c2 x2 + e_eta
<p>
    Where e_y and e_eta are independent normally distributed error terms with
    means zero and standard deviations that need to be estimated. By
    replacing eta in equation (5) with equation (6) one can see that the
    error term of this model is:
<p>
        e_y + (l0 + l1 x3) e_eta
<p>
    This combined error term will also be normally distributed, as the sum of
    two independent normally distributed variables is itself also normally
    distributed, with a mean zero and the following standard deviation:
<p>
        sqrt{var(e_y) + (l0 + l1 x3)^2 var(e_eta)}
<p>
    So the empirical information that is used to separate the standard
    deviation of e_y from the standard deviation of e_eta is the changes in
    the residual variance over x3.  So the data will only contain rather
    indirect information that can be used for estimating this model, and the
    model may thus not always converge. However, if the model is correct it
    will enable one to control for measurement error in the latent variable.
<p>
    There is an important downside to this model, and that is that
    heteroscedasticity, and in particular changes in the variance of e_y over
    x3, could have a distorting influence on the parameter estimates of l0
    and l1. Consider again the example where one wants to explain the
    respondent's education with the education of the father and the mother,
    but now assume that we are interested in how the effect of the latent
    variable changes over time. In this case we have good reason to suspect
    that the variance of e_y will also change over time: Education consists
    of a discrete number of categories, and in early cohorts most of the
    respondents tend to cluster in the lowest categories. Over time the
    average level of education tends to increase, which means that the
    respondents tend to cluster less in the lowest category, and have more
    room to differ from one another. As a consequence the residual variance
    is likely to have increased over time. Normally this heteroscedasticity
    would not be an issue of great concern, but in a MIMIC model this
    heteroscedasticity is incorrectly interpreted as indicating that there is
    measurement error in the latent variable representing parental education.
    Moreover, this "information" on the measurement error is used to "refine"
    the estimates of l0 and l1. So, this would be an example where the MIMIC
    model would not be appropriate.
<p>
<p>
<b><u>Options</u></b>
<p>
        +-------+
    ----+ Model +------------------------------------------------------------
<p>
    <b><u>con</u></b><b>strained(</b><i>varlist_c</i><b>)</b> specifies the variables can be thought of as being
        measurements of the same latent variable. The effects of these
        variables are to be constrained to change by the same proportion as
        the variables specified in <b>lambda()</b> change.
<p>
        If the <b>standardized</b> option is specified one can identify one variable
        as a key variable that identifies the direction of the latent
        variable, either in the same direction as the key variable (<b>+</b>) or in
        the opposite direction (<b>-</b>). If the <b>standardized</b> option is specified
        but no key variable is specified, then the constant of the lambda
        equation will be constrained to be positive.
<p>
    <b>lambda(</b><i>varlist_l</i><b>)</b> specifies the variables along which the effects of the
        latent variable changes.
<p>
    <b>mimic</b> specifies that a MIMIC model is to be estimated.
<p>
    <b>logit</b> specifies that the dependent variable is binary and that the
        influence of the latent and control variables on the probability is
        modeled through a logistic regression model.
<p>
    <b>poisson</b> specifies that the dependent variable is a count and that the
        influence of the latent and control variables on the rate is modeled
        through a poisson regression model.
<p>
        +----------------+
    ----+ Identification +---------------------------------------------------
<p>
    <b>standardized</b> specified that the unit of the latent variable is identified
        by constraining the standardard deviation of the latent variable to
        be equal to 1. This is the default parametrization.
<p>
    <b>lcons</b> specifies that the parameters of the variables specified in the
        option<b> constrained()</b> measure the indirect effect of these variables
        through the latent variable on the dependent variable when all
        variables specified in the option<b> lamda()</b> are zero.
<p>
    <b>unit(</b><i>varname</i><b>)</b> specifies that the scale of the latent variable is
        indentified by constraining the unit of the latent variable to be
        equal to the unit of<i> varname</i>. The variable<i> varname</i> must be specified
        in<i> varlist_c</i>.
<p>
        +---------------------+
    ----+ SE/robust/reporting +----------------------------------------------
<p>
    <b>vce(</b><i>vcetype</i><b>)</b> specifies the type of standard error reported, which
        includes types that are derived from asymptotic theory, that are
        robust to some kinds of misspecification, that allow for intragroup
        correlation, and that use bootstrap or jackknife methods; see 
        vce_option.
<p>
    <b><u>r</u></b><b>obust</b> specifies that the Huber/White/sandwich estimator of variance is
        to be used in place of the traditional calculation; see <b>[U] 23.14</b>
        <b>Obtaining robust variance estimates</b>.  <b>robust</b> combined with <b>cluster()</b>
        allows observations which are not independent within cluster
        (although they must be independent between clusters).
<p>
    <b><u>c</u></b><b>luster(</b><i>clustervar</i><b>)</b> specifies that the observations are independent
        across groups (clusters) but not necessarily within groups.
        <i>clustervar</i> specifies to which group each observation belongs; e.g.,
        <b>cluster(personid)</b> in data with repeated observations on individuals.
        See <b>[U] 23.14 Obtaining robust variance estimates</b>.  Specifying
        <b>cluster()</b> implies <b>robust</b>.
<p>
    <b><u>l</u></b><b>evel(</b><i>#</i><b>)</b> specifies the confidence level, in percent, for the confidence
        intervals of the coefficients; see help level.
<p>
    <b>or</b> specifies that odds ratios are to be displayed. If the <b>lcons</b> option is
        specified than the parameters in all three equations (unconstrained,
        lambda, and unconstrained) will be exponentiated. In all other cases
        only the parameters in the first two equations (unconstrained, and
        lambda) will be exponentiated. This option is only allowed in
        combination with the <b>logit</b> option.
<p>
    <b>irr</b> specifies that incidence rate ratios are to be displayed. If the
        <b>lcons</b> option is specified than the parameters in all three equations
        (unconstrained, lambda, and unconstrained) will be exponentiated. In
        all other cases only the parameters in the first two equations
        (unconstrained, and lambda) will be exponentiated. This option is
        only allowed in combination with the <b>poisson</b> option.
<p>
    <b>wald</b> specifies that the test of the proportionality constrained is to be
        a Wald test instead of a likelihood ratio test. This is the default
        when robust standard errors have been used. This option is not
        allowed in combination with the <b>mimic</b> option.
<p>
<a name="maximize_options"></a>        +------------------+
    ----+ maximize_options +-------------------------------------------------
<p>
    <b><u>diff</u></b><b>icult</b>, <b><u>tech</u></b><b>nique(</b><i>algorithm_spec</i><b>)</b>, <b><u>iter</u></b><b>ate(</b><i>#</i><b>)</b>, <b><u>tr</u></b><b>ace</b>, <b><u>grad</u></b><b>ient</b>,
    <b>showstep</b>, <b><u>hess</u></b><b>ian</b>, <b><u>shownr</u></b><b>tolerance</b>, <b><u>tol</u></b><b>erance(</b><i>#</i><b>)</b>, <b><u>ltol</u></b><b>erance(</b><i>#</i><b>)</b>,
    <b><u>gtol</u></b><b>erance(</b><i>#</i><b>)</b>, <b><u>nrtol</u></b><b>erance(</b><i>#</i><b>)</b>, <b><u>nonrtol</u></b><b>erance(</b><i>#</i><b>)</b>; see maximize.  These
    options are seldom used.
<p>
<p>
<a name="example"></a><b><u>Example</u></b>
<p>
    Example illustrating the use of the <b>poisson</b> option to model a
    non-negative but not necessarily a count dependent variable. For its
    advantages see: (Cox et al. 2007; Nichols, 2010; Gould 2011). However, in
    a simulation the point estimates seem to be unbiased but the robust
    standard errors don't seem to perform as well.  So I use bootstrap
    standard errors instead of robust standard errors.  This example also
    illustrates the use of predict to help with interpreting the model:
<p>
<b>        sysuse nlsw88, clear</b>
<p>
<b>        gen hs = grade == 12 if grade &lt; .</b>
<b>        gen sc = grade &gt; 12 &amp; grade &lt; 16 if grade &lt; .</b>
<b>        gen c = grade &gt;= 16 if grade &lt; .</b>
<p>
<b>        gen tenure2 = tenure^2</b>
<b>        gen tenureXunion = tenure*union</b>
<b>        gen tenure2Xunion = tenure2*union</b>
<p>
<b>        gen hours2 = ( hours - 40 ) / 5</b>
<b>                </b>
<b>        gen white = race == 1 if race &lt; .</b>
<p>
<b>        propcnsreg wage tenure* union white hours2, /*</b>
<b>        */ lambda(tenure tenureXunion union) /*</b>
<b>        */ constrained(hs sc c) unit(c) /*</b>
<b>        */ poisson vce(bootstrap) irr</b>
<p>
<b>        predict double effect, effect</b>
<b>        predict double se_effect, stdp eq(lambda)</b>
<b>        gen double lb = effect - invnormal(.975)*se_effect</b>
<b>        gen double ub = effect + invnormal(.975)*se_effect</b>
<b>                </b>
<b>        replace effect = exp(effect)</b>
<b>        replace lb = exp(lb)</b>
<b>        replace ub = exp(ub)</b>
<b>                </b>
<b>        sort tenure</b>
<p>
<b>        twoway rarea lb ub tenure if union == 1 || /* </b>
<b>        */ rarea lb ub tenure if union== 0, /*</b>
<b>        */ astyle(ci ci) || /*</b>
<b>        */ line effect tenure if union == 1 || /* </b>
<b>        */ line effect tenure if union == 0, /*</b>
<b>        */ yline(1) clpattern(longdash shortdash) /*</b>
<b>        */ legend(label(1 "95% conf. int.") /*</b>
<b>               */ label(2 "95% conf. int.") /*</b>
<b>               */ label(3 "union")          /*</b>
<b>               */ label(4 "non-union")      /*</b>
<b>               */ order(3 4 1 2))           /*</b>
<b>        */ ytitle("effect of education on wage")</b>
        <i>(</i><i>click to run</i><i>)</i>
<p>
    An example for a binary dependent variable. Note that in this case both
    the parameters in the unconstrained and the lambda equation are both odds
    ratios.
<p>
<b>        sysuse nlsw88, clear</b>
<b>        gen byte high = occupation &lt; 3 if !missing(occupation)</b>
<b>        gen byte white = race == 1 if !missing(race)</b>
<p>
<b>        gen byte hs = grade == 12 if !missing(grade)</b>
<b>        gen byte sc = grade &gt; 12 &amp; grade &lt; 16 if !missing(grade)</b>
<b>        gen byte c = grade &gt;= 16 if !missing(grade)</b>
<p>
<b>        propcnsreg high white ttl_exp married never_married age, ///</b>
<b>                   lambda(ttl_exp white) ///</b>
<b>                   constrained(hs sc c) unit(c) logit or </b>
        <i>(</i><i>click to run</i><i>)</i>
<p>
<b><u>Author</u></b>
<p>
    Maarten L. Buis, Wissenschaftszentrum Berlin für Sozialforschung (WZB)
    maarten.buis@wzb.eu
<p>
<p>
<b><u>References</u></b>
<p>
    Bollen, Kenneth A. 1984. "Multiple Indicators: Internal Consistency or No
    Necessary Relationship" <i>Quality and Quantity</i> 18(4): 377-385.
<p>
    Bollen, Kenneth A. and Richard Lennox. 1991. "Conventional Wisdom on
    Measurement: A Structural Equation Perspective" <i>Psychological Bulletin</i>
    110(2): 305-314.
<p>
    Cox, Nicholas J., Jeff Warburton, Alona Armstrong and Victoria J.
    Holliday (2007) "Fitting concentration and load rating curves with
    generalized linear models" <i>Earth Surface Processes and Landforms</i>,
    33(1):25--39.
<p>
    Gould, William. (2011) "Use poisson rather than regress; tell a friend"
    <i>Not Elsewhere Classified, the official Stata blog.</i>  
    http://blog.stata.com/2011/08/22/use-poisson-rather-than-regress-tell-a-f
    &gt; riend/
<p>
    Hauser, Robert M. and Arthur S. Goldberger. 1971.  "The Treatment of
    Unobservable Variables in Path Analysis." <i>Sociological Methodology</i> 3:
    81-117.
<p>
    Heise, David R. 1972. "Employing nominal variables, induced variables,
    and block variables in path analysis." <i>Sociological Methods &amp; Research</i>
    1(2): 147-173.
<p>
    Nichols, Austin (2010) "Regression for nonnegative skewed dependent
    variables" <i>Stata Conference, 2010</i>.  
    http://www.stata.com/meeting/boston10/boston10_nichols.pdf
<p>
    Yamaguchi, Kazuo. 2002. "Regression models with parametrically weighted
    explanatory variables."<i> Sociological Methodology</i> 32: 219-245.
<p>
<p>
<b><u>Suggested citation if using propcnsreg in published work</u></b>
<p>
    <b>propcnsreg</b> is not an official Stata command. It is a free contribution to
    the research community, like a paper. Please cite it as such.
<p>
    Buis, Maarten L.  2007. "PROPCNSREG: Stata program fitting a linear
    regression with a proportionality constraint by maximum likelihood" 
    http://ideas.repec.org/c/boc/bocode/s456858.html
<p>
<p>
<b><u>Also see:</u></b>
<p>
</pre>