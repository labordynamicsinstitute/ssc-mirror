<pre>
-------------------------------------------------------------------------------
help for <b>powercal</b>                                                (Roger Newson)
-------------------------------------------------------------------------------
<p>
<b><u>Generalized power calculations saving results in variables</u></b>
<p>
        <b>powercal</b> <i>newvarname</i> [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] , [ <b><u>n</u></b><b>unit(</b><i>expression_1</i><b>)</b>
                           <b><u>p</u></b><b>ower(</b><i>expression_2</i><b>)</b> <b><u>a</u></b><b>lpha(</b><i>expression_3</i><b>)</b>
                           <b><u>d</u></b><b>elta(</b><i>expression_4</i><b>)</b> <b><u>s</u></b><b>dinf(</b><i>expression_5</i><b>)</b>
                           <b><u>t</u></b><b>df(</b><i>expression_6</i><b>)</b> <b>no</b><b><u>ce</u></b><b>iling</b> <b>float</b> ]
<p>
where <i>expression</i> is a numeric expression. The numeric expression for each
option must be in the form required by the <b>generate</b> command. That is to say,
each expression must be specified so that the command
<p>
<b>gene double </b><i>newvarname</i><b>=(</b><i>expression</i><b>)</b>
<p>
will work.
<p>
<p>
<b><u>Description</u></b>
<p>
<b>powercal</b> performs generalized power calculations, storing the result in a new
variable with a name specified by <i>newvarname</i>. All except one of the options
<b>nunit</b>, <b>power</b>, <b>alpha</b>, <b>delta</b> and <b>sdinf</b> must be specified. The single unspecified
option in this list specifies whether the output variable is the number of
sampling units, power, alpha (significance level), delta (difference in
parameter value to be detected), or the standard deviation (SD) of the
influence function. Any of these 5 quantities can be calculated from the other
4. <b>powercal</b> can be used to calculate any of these quantities, assuming that we
are testing a hypothesis that a parameter is zero, and that the true value is
given by <b>delta</b>, and that the sample statistic is distributed around the
population parameter in such a way that the pivotal quantity
<p>
<b>PQ = sqrt(nunits) * (delta/sdinf)</b>
<p>
has a standard Normal distribution (if <b>tdf()</b> is not specified) or a
t-distribution with <b>tdf()</b> degrees of freedom (if <b>tdf()</b> is specified). The
formulas used by <b>powercal</b> define power as the probability of detecting a
difference in the right direction, using a two-tailed test.
<p>
<p>
<b><u>Options</u></b>
<p>
<b>nunit(</b><i>expression_1</i><b>)</b> gives an expression whose value is the number of
    independent sampling units. Sampling units are defined very generally. For
    instance, in an experiment involving equal-sized samples of individuals
    from Population A and Population B, a sampling unit might be a pair of
    sampled individuals, one from each population. Similarly, in a case-control
    study with 4 controls per case, a sampling unit might be a case together
    with 4 controls.
<p>
<b>power(</b><i>expression_2</i><b>)</b> gives an expression whose value is the power to detect a
    difference specified by the <b>delta()</b> option (see below).  The power is
    defined as the probability that the sample difference is in the correct
    direction, and also large enough to be significant, using a 2-tailed test,
    at the level specified by the <b>alpha()</b> option (see below).
<p>
<b>alpha(</b><i>expression_3</i><b>)</b> gives an expression whose value is the size, or
    significance level, of the statistical test (in units of probability, not
    percentage).
<p>
<b>delta(</b><i>expression_4</i><b>)</b> gives an expression whose value is the true population
    difference to be detected. This difference is assumed to be positive.
    Therefore, if the user wishes to detect a negative difference, then s/he
    should specify an expression equal to minus that difference. The difference
    may be the log of a ratio parameter, such as an odds ratio, rate ratio,
    risk ratio or ratio of geometric means.
<p>
<b>sdinf(</b><i>expression_5</i><b>)</b> gives an expression whose value is the standard deviation
    of the influence function. That is to say, it is an expression equal to the
    expected standard error of the sample difference multiplied by the square
    root of the number of sampling units, where sampling units are defined
    generally, as specified in the option <b>nunit()</b>. In the simple case of a
    paired t-test, <b>sdinf()</b> is the standard deviation of the paired differences.
    More generally, <b>sdinf()</b> can be defined by calculating a standard error for
    a particular number of units, from a pilot study, from a simulation or from
    a formula, and multiplying this standard error by the square root of the
    number of units in the pilot study, simulation or formula.
<p>
<b>tdf(</b><i>expression_6</i><b>)</b> gives an expression whose value is the degrees of freedom of
    the t-distribution to be assumed for the pivotal quantity <b>PQ</b> specified
    above. The degrees of freedom expression is not necessarily integer-valued.
    If <b>tdf()</b> is absent, then <b>PQ</b> is assumed to follow a standard Normal
    distribution.
<p>
<b>noceiling</b> specifies that, if the output variable specified by <i>newvarname</i> is a
    number of units, then it will not be rounded up to the lowest integer no
    less than itself (as calculated by the Stata 8 <b>ceil()</b> function). This
    option can be useful if the output variable is intended to specify an
    amount of exposure, such as a number of person-years, and the input <b>sdinf()</b>
    expression specifies a standard deviation of the influence function per
    unit exposure. If <b>noceiling</b> is not specified, and <b>power()</b>, <b>alpha()</b>, <b>delta()</b>
    and <b>sdinf()</b> are specified, then <b>powercal</b> rounds up the output variable, so
    that it contains a whole number of units
<p>
<b>float</b> specifies that the output variable will have a storage type no higher
    than <b>float</b>.  If <b>float</b> is not specified, then <b>powercal</b> creates the output
    variable with storage type <b>double</b>.  Whether or not <b>float</b> is specified,
    <b>powercal</b> compresses the output variable as much as possible without loss of
    precision. (See help for compress.)
<p>
<p>
<b><u>Remarks</u></b>
<p>
<b>powercal</b> carries out sample size calculations for a more general range of
possible experimental designs than sampsi, and stores the result in a new
variable, instead of reporting the result in the log. The new variable may be
input to further calculations and/or plotted and/or listed. <b>powercal</b> is
intended as a low-level programming tool for users intending to carry out
sample size calculations for a given experimental design. It is the
responsibility of the user to ensure that the expressions are correct, and to
choose a parameter scale on which the parameter is expected to be Normally
distributed (or t-distributed), with a variance that does not vary excessively
with the size of the measured difference.
<p>
The formulas used by <b>powercal</b> define power as the probability of detecting a
difference in the right direction, using a two-tailed test. It follows that, in
the limit, as the difference <b>delta</b> tends to zero, the power to detect a
difference of <b>delta</b> with a P-value of <b>alpha</b> tends to a minimum of <b>alpha/2</b>, and
not to a minimum of <b>alpha</b>. <b>powercal</b> converts to missing the results of all
input expressions for <b>power()</b> and <b>alpha()</b> which evaluate to a number outside
the open interval <b>(0,1)</b>, and the results of all input expressions for <b>delta()</b>,
<b>sdinf()</b> and <b>nunit()</b> which evaluate to a non-positive number.  <b>powercal</b> also
converts to missing all values in the output variable for which there is not a
unique maximum or minimum value of the output quantity. See the manual
<b>powercal.pdf</b> (distributed as an ancillary file with the <b>powercal</b> package) for
details of the Methods and Formulas.
<p>
<p>
<b><u>Examples</u></b>
<p>
The following examples are explained in detail in the manual <b>powercal.pdf</b>,
which is distributed with the <b>powercal</b> package. They are designed to work both
under Stata 7 and under Stata 8.
<p>
This example creates Figure 1, displaying power as a function of the geometric
mean ratio between 2 treatment groups:
<p>
        . clear
        . scal cv=0.5
        . scal sdlog=sqrt(log(cv*cv + 1))
        . scal r20=exp(-2*sdlog*invnorm(0.2))
        . disp _n as text "Coefficient of variation: " as result cv _n as text
                "SD of logs: " as result sdlog _n as text "20% tail ratio: " as
                result r20
        . set obs 100
        . gene logratio=log(2)*(_n/_N)
        . lab var logratio "Log GM ratio"
        . gene gmratio=exp(logratio)
        . lab var gmratio "GM ratio"
        . powercal power, alpha(0.01) delta(logratio) sdinf(sdlog*sqrt(2))
                nunit(50) tdf(98)
        . version 7:graph power gmratio, s(.) c(L) ylab(0(0.05)1) yline(0.8
                0.9) xlab(1(0.1)2) xlog
<p>
This example creates Figure 2, displaying detectable geometric mean ratios
between 2 groups as a function of number per group:
<p>
        . clear
        . scal cv=0.5
        . scal sdlog=sqrt(log(cv*cv + 1))
        . scal r20=exp(-2*sdlog*invnorm(0.2))
        . disp _n as text "Coefficient of variation: " as result cv _n as text
                "SD of logs: " as result sdlog _n as text "20% tail ratio: " as
                result r20
        . set obs 100
        . gene npergp=_n
        . lab var npergp "Number per group"
        . powercal logratio, power(0.9) alpha(0.01) sdinf(sdlog*sqrt(2))
                nunit(npergp) tdf(2*(npergp-1))
        . gene hiratio=exp(logratio)
        . gene loratio=exp(-logratio)
        . lab var hiratio "Detectable GM ratio &gt;1"
        . lab var loratio "Detectable GM ratio &lt;1"
        . version 7:graph hiratio loratio npergp if _n&gt;=5, s(..) c(LL) yline(1)
                ylab xlab(0(10)100)
<p>
<p>
This example creates Figures 3 and 4, displaying, respectively, detectable odds
ratios in a case-control study as a function of number of cases and attainable
significance levels as a function of odds ratio:
<p>
        . clear
        . scal conprev=0.25
        . scal conodds=conprev/(1-conprev)
        . disp _n as text "Expected control prevalence: " as result conprev _n
                as text "Expected control odds: " as result conodds
        . set obs 101
        . gene logor=log(1.25)+(log(5)-log(1.25))*(_n-1)/(_N-1)
        . gene or=exp(logor)
        . gene caseodds=conodds*or
        . gene caseprev=caseodds/(1+caseodds)
        . gene sdinflor=sqrt( 1/caseprev + 1/(1-caseprev) + (1/2)*( 1/conprev +
                1/(1-conprev) ) )
        . lab var logor "Log odds ratio"
        . lab var or "Odds ratio"
        . lab var caseodds "Case exposure odds"
        . lab var caseprev "Case exposure prevalence"
        . lab var sdinflor "SD of influence for log OR"
        . desc
        . * Detectable OR by number of cases *
        . powercal ncases, power(0.9) alpha(0.01) delta(logor) sdinf(sdinflor)
        . version 7:graph or ncases if ncases&lt;=2000, s(.) c(l) ylog ylab xlab
        . more
        . * Significance level by odds ratio *
        . powercal alphamin, power(0.9) delta(logor) sdinf(sdinflor) nunit(100)
        . version 7:graph alphamin or, s(.) c(l) ylog yreverse ylab(1 0.05 1e-1
                1e-2 1e-3 1e-4 1e-5 1e-6 1e-7) yline(0.05 0.01) xlog xlab(1
                1.25 1.5 2(1)5)
        . more
<p>
<p>
<b><u>Author</u></b>
<p>
Roger Newson, King's College, London, UK.  Email: roger.newson@kcl.ac.uk
<p>
<p>
<b><u>Also see</u></b>
<p>
 Manual:  <b>[R] sampsi</b>
On-line:  help for sampsi
<p>
</pre>