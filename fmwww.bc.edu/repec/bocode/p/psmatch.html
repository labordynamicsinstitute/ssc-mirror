<pre>
Last updated August 29, 2001
<p>
-------------------------------------------------------------------------------
help for <b> psmatch</b>
-------------------------------------------------------------------------------
<p>
<b><u> Perform various types of propensity score matching</u></b>
<p>
        <b>psmatch</b><i> treatvar</i> <b>,</b> {<b>on(</b><i>matchvar1</i> [<i>matchvar2</i>
                         [<i>matchvar3</i>]]<b>)</b>|<b><u>est</u></b><b>imate(</b><i>varlist</i><b>)</b>}
                         [ <b><u>log</u></b><b>it</b> <b><u>ind</u></b><b>ex</b> <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> <b><u>out</u></b><b>come(</b><i>outcomevar</i><b>)</b>
                         <b>id(</b><i>idvar</i><b>)</b> <b><u>ker</u></b><b>nel(</b><i>outcomevar</i><b>)</b> <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> <b><u>ep</u></b><b>an</b>
                         <b><u>tr</u></b><b>icube(</b><i>outcomevar</i><b>)</b> <b><u>spl</u></b><b>ine(</b><i>outcomevar</i><b>)</b> <b><u>nk</u></b><b>nots(</b><i>integer</i><b>)</b>
                         <b><u>me</u></b><b>an(</b><i>outcomevar</i><b>)</b> <b><u>nei</u></b><b>ghbour(</b><i>integer</i><b>)</b> <b><u>li</u></b><b>ne(</b><i>outcomevar</i><b>)</b>
                         <b><u>low</u></b><b>ess(</b><i>outcomevar</i><b>)</b> <b><u>bo</u></b><b>th</b> <b>nocommon</b> <b><u>noc</u></b><b>ount</b>
                         <b><u>qua</u></b><b>lity(</b><i>varlist</i><b>)</b> <b><u>sa</u></b><b>ving(</b><i>filename</i><b>)</b> <b><u>boot</u></b><b>strap</b>
                         <b><u>r</u></b><b>eps(</b><i>integer</i><b>)</b> <b><u>d</u></b><b>ots</b> <b><u>si</u></b><b>ze(</b><i>integer</i><b>)</b> <b><u>ev</u></b><b>ery(</b><i>integer</i><b>)</b>
                         <b>replace</b> <b><u>doub</u></b><b>le</b> <b><u>l</u></b><b>evel(</b><i>integer</i><b>)</b> ]
<p>
<p>
<b><u>Description</u></b>
<p>
<i>treatvar</i> is a 0-1 variable identifying two groups, 1 for the 'treated' and 0
for the 'controls'.<b>  psmatch</b> pairs to each treated unit one or more
'comparable' (in terms of the<i> matchvars</i>) non-treated units and associates to
the outcome of the treated unit, the (weighted) outcomes of his 'neighbours' in
the comparison group, where the weights can optionally depend on their
'distance' to the treated unit under consideration.
<p>
<p>
<b><u>Options</u></b>
<p>
<b>on(</b><i>matchvar1</i> [<i>matchvar2</i> [<i>matchvar3</i>]]<b>)</b> specifies the variable(s) on which to
    match.  The 'propensity score', the probability of belonging to the treated
    group given observable characteristics, can be used as a summary of these
    characteristics (Rosenbaum and Rubin, 1983). It can be estimated via logit
    or probit regressions, and the predicted probability or the index used as
    <i>matchvar1</i>.  I suggest the use of double as storage type for<i> matchvar1</i> in
    order to decrease the likelihood of multiple 'exact' matches for a given
    treated.  If a second or third<i> matchvar</i> is specified (e.g. matching on a
    finer basis, or on multiple scores estimated from a multinomial model such
    as mlogit or nlogit),<b> psmatch</b> will look for the closest match in terms of
    the Mahalanobis distance constructed from the two or three variables.  This
    Mahalanobis-metric matching (formula from Rubin, 1980) is presently only
    allowed for the one-to-one and kernel-based (gaussian and epanechnikov)
    versions.  Note: 1) Mahalanobis-metric matching may take long to implement.
    2) If required, it is the user who has in this case to programme
    bootstrapping with the appropiate scores estimation procedure.
<p>
<p>
<b>estimate(</b><i>varlist</i><b>)</b> is an alternative to <b>on(</b><i>matchvar1</i><b>)</b> and estimates the
    propensity score (i.e. the predicted probability, unless the option <b>index</b>
    is specified) using the user-specified <i>varlist</i> as regressors in a probit
    model (unless the option <b>logit</b> is specified).
    Either <b>on</b> or <b>estimate</b> must be specified.
<p>
<b>logit</b> uses a logit model to <b>estimate</b> the propensity score.
<p>
<b>index</b> requires the use of the linear index as the propensity score when
    <b>estimate</b>d.
<p>
If no smoothing type of matching is specifed via the options <b>kernel</b>, <b>spline</b>,
<b>mean</b>, <b>line</b>, <b>lowess</b> or <b>tricube</b>, the default is to perform one-to-one (or
nearest-neighbour) matching with replacement:
To each treated unit that single control unit with the closest propensity score
is matched; a given control unit can be matched to more than one treated unit.
This latter choice is necessary for estimation in the multiple-treatment case,
where each sub-group will act both as a treated group and as (several)
comparison groups.  Two new variables are created:
<p>
    _times stores the number of times a unit is used (1 for all matched
    treated); it is missing for the unmatched treated and unmatched control
    units.  In subsequent analyses use [fw=_times] or else expand _times
    _matchdif is defined only for matched treated and stores the absolute
    distance (in terms of the propensity score or the Mahalanobis metric) of
    that treated unit with its matched control.  It is useful to assess
    matching quality and decide on possibly refining or widening the caliper.
<p>
<b>caliper(</b><i>real</i><b>)</b> calls for one-to-one caliper matching (Cochran and Rubin, 1973)
    with replacement to be performed:  Treated units for which no control unit
    is found within the maximum absolute distance given by the caliper are left
    unmatched.
<p>
<b>id(</b><i>idvar</i><b>)</b> specifies the <i>numeric</i> variable identifying the individual units.  If
    specified, the programme will check that the dataset contains only one
    observation per individual, as needed by <b>psmatch</b>.
    For one-to-one matching, it will also ensure that the same matched control
    is always used should there be multiple 'exact' matches. Secondly, it will
    create the variable _matchedid, defined only for matched treated and
    storing the identifier <i>idvar</i> of the corresponding matched control.
<p>
<b>outcome(</b><i>outcomevar</i><b>)</b> specifies the numeric outcome variable which the user
    intends to evaluate by one-to-one matching. If specified, the means of
    <i>outcomevar</i> for the matched treated and for the matched controls, together
    with their difference, an approximate standard error of the effect and the
    corresponding t-test statistic will be directly displayed after matching is
    performed. Secondly, a new variable _moutcomevar will be created, storing
    for each matched treated the <i>outcomevar</i> of his matched control.
<p>
<b>kernel(</b><i>outcomevar</i><b>)</b> asks for kernel-based matching to be performed (Heckman et
    al., 1997 and 1998). <i>outcomevar</i> is the outcome being evaluated. All
    controls are used to construct a weighted matched <i>outcomevar</i> for a given
    treated unit (within the common support). These values are stored in the
    new variable, _moutcomevar.
<p>
<b>bwidth(</b><i>real</i><b>)</b> specifies the bandwidth to be used for <b>kernel</b>. Default is 0.06.
    It is also the bandwidth to be used by <b>mean</b>, <b>line</b>, <b>lowess</b> and <b>tricube</b>, this
    time however constrained in (0,1] and expressed in terms of the percentage
    of non-treated units to be used in smoothing.  Default is 0.8.
<p>
<b>epan</b> specifies that the Epanechnikov kernel be used by <b>kernel</b> rather than the
    default Gaussian one.  This means that only those controls falling within a
    radius of <b>bwdith</b> are used to construct _moutcomevar for a given treated
    unit (within the common support).
<p>
<b>tricube(</b><i>outcomevar</i><b>)</b> performs kernel-based matching using a tricube weight.
    Only those controls within a neighbourhood determined by <b>bwdith</b> are used to
    construct a weighted matched <i>outcomevar</i> for a given treated unit (within
    the common support). These values are stored in the new variable,
    _moutcomevar.
<p>
<b>spline(</b><i>outcomevar</i><b>)</b> performs 'spline-smoothing matching' by first fitting a
    natural cubic spline on <i>matchvar1</i> (or on the result from<b> estimate</b>) to
    <i>outcomevar</i> for the non-treated. The matched values are stored in the new
    variable, _moutcomevar.  It requires the STB spline programme, which can be
    downloaded by typing:
    net install snp7_1.
<p>
<b>nknots(</b><i>integer</i><b>)</b> specifies the number of interior knots for spline smoothing.
    Default is the fourth root of the number of non-treated units.
<p>
<b>mean(</b><i>outcomevar</i><b>)</b> performs nearest-neighbours matching (with equal weights).
    The number of non-treated neighbours is governed by either <b>bwidth</b> (default
    is 0.8) or more directly by <b>neighbour</b>. The matched values are stored in the
    new variable, _moutcomevar.
<p>
<b>neighbour(</b><i>integer</i><b>)</b> (or<b> neighbor()</b>) specifies the number of neighbours for
    nearest-neighbours matching.
<p>
<b>line(</b><i>outcomevar</i><b>)</b> performs 'least-squares-smoothing matching', obtained by
    locally fitting an (unweighted) line in the neighbourhood determined by
    <b>bwidth</b>. The matched values are stored in the new variable, _moutcomevar.
<p>
<b>lowess(</b><i>outcomevar</i><b>)</b> performs a type of local linear matching (Heckman et al.,
    1997), smoothing the non-treated in a neighbourhood determined by <b>bwidth</b>
    and weighting their contribution by a tricube weight.  The matched values
    are stored in the new variable, _moutcomevar.
<p>
<b>both</b> asks <b>kernel</b> or <b>tricube</b> or <b>spline</b> or <b>mean</b> or <b>line</b> or <b>lowess</b> to smooth
    <i>outcomevar</i> for the treated as well and to store the smoothed values in the
    new _soutcomevar.
<p>
<b>nocommon</b> forces treated individuals outside the common support to be matched
    too (for the smoothed matching estimators).
<p>
<b>nocount</b> suppresses the display of the 'count down' of the treated being matched
    - which is shown by default in the more time-consuming types of estimators
    (one-to-one on more than one score; kernel) -, as well as the display of a
    summary of instructions (log files should remain unaffected anyway).
<p>
<b>quality(</b><i>varlist</i><b>)</b> creates a new dataset (named as specified by the <b>saving</b>
    option) containing (one-to-one) matching quality indicator variables for
    the regressors specified in <i>varlist</i>.  The variables in the created dataset
    are: a string variable storing the name of the regressor, the corresponding
    means in the treated and control groups (both for the full and for the
    matched groups), the standardised percentage bias (a) before and (b) after
    matching for that regressor (the difference of the sample means in the
    treated and non-treated - (a) full or (b) matched - sub-samples as a
    percentage of the square root of the average of the sample variances in the
    treated and non-treated groups; formulae from Rosenbaum and Rubin, 1985),
    and the percentage bias reduction.
<p>
<b>saving(</b><i>filename</i><b>)</b> creates a dataset named <i>filename</i>.dta containing either the
    quality information requested if <b>quality</b> was specified or the bootstrap
    distribution for the treatment effect if <b>bootstrap</b> was specified.  Note
    that for <b>quality</b>, a dataset with the same <i>filename</i> will <b>automatically</b> be
    OVERWRITTEN; for <b>bootstrap</b> it will not, unless the option <b>replace</b> is also
    specified.
<p>
<b>bootstrap</b> performs bootstrapping of the treatment effect. The option <b>estimate</b>
    needs to be specified, and for one-to-one matching <b>outcome</b> as well. The
    option <b>quality</b> cannot be requested.
    ATTENTION: This can be quite time-consuming. Also note that for
    non-standard estimation of the score (e.g. in a multiple-treatment
    framework) and/or non-standard type of outcome (e.g. histories), it is the
    user who should post the saved r(effect) in a tailor-made programme to be
    called by STATA's bstrap.
    If interested in the reproducibility of the results, set the random-number
    seed by typing <b>set seed</b> <i>integer</i> before bootstrapping. (This may not work
    exactly if there are ties in one-to-one matching).
    The following 7 options and <b>saving</b> are those of bstrap; see also the
    relevant entry in STATA's manual.
<p>
<b>reps(</b><i>integer</i><b>)</b> specifies the number of bootstrap replications to be performed.
    The default is 50.
<p>
<b>dots</b> requests a dot be placed on the screen at the beginning of each
    replication.
<p>
<b>size(</b><i>integer</i><b>)</b> specifies the size of the samples to be drawn.  The default is
    _N, that is the size as the data.
<p>
<b>every(</b><i>integer</i><b>)</b> specifies that the results should be saved every <i>integer</i>-th
    replication.
<p>
<b>replace</b> indicates that the file specified by <b>saving()</b> may be overwritten.
<p>
<b>double</b> specifies that the bootstrap results for each replication are to be
    stored as double (8-byte reals) rather than as the default float (4-byte
    reals).
<p>
<b>level(</b><i>integer</i><b>)</b> specifies the confidence level, in percent, for confidence
    intervals.  The default is 95 or as set by <b>set level</b>.
<p>
<p>
<b><u> Remarks</u></b>
<p>
The dataset needs to contain ONLY ONE observation per unit; Stata will check
this for you if the option <b>id()</b> is specified; if not, it is your
responsibility!
If running<b> psmatch</b> more than once on the same dataset, it is presumed the user
is no longer interested in the _* variables previously created; if they are not
renamed first, they will be REPLACED by the new ones.
<p>
<p>
<b><u> Saved Results</u></b>
<p>
For the smoothed types of matching and, if the option <b>outcome</b> is specified for
one-to-one matching, <b>psmatch</b> saves the (possibly smoothed) average outcome for
the matched treated in scalar r(mean1), for the matched controls in scalar
r(mean0); the average treatment effect on the treated is stored in scalar
r(effect).
<p>
<p>
<b><u> Examples</u></b>
<p>
. psmatch treated, on(score) caliper(.001) id(serialno) outcome(wage)
<p>
. psmatch treated, on(score age) quality(age-sex) saving(qual1)
. stset days [fw=_times], failure(fail)
. sts graph, by(treated)
<p>
. psmatch group1, on(p1 p2) kernel(logwage) bwidth(0.01) epan nocommon
<p>
. psmatch treated, est(age-sex) lowess(logwage) bwidth(0.2) both
<p>
. psmatch reform, est(age-sex) mean(educat) neighb(5) boot reps(100) dots
<p>
<p>
<b><u> Author</u></b>
<p>
        Barbara Sianesi
        University College London and Institute for Fiscal Studies 
        Email: barbara_s@ifs.org.uk
<p>
        
<b><u> Aknowledgements</u></b>
<p>
The core code for one-to-one matching has been made faster by adapting a clever
idea by Andrea Ichino (European University Institute).
<b>spline</b> uses Peter Sasieni's STB-24 snp7.1 spline programme.
<b>mean</b>, <b>line</b>, <b>lowess</b> and <b>tricube</b> are based on STATA's ksm command. See the
corresponding entry in the manual for additional information.
<p>
        
<b><u> Bibliography and Sources</u></b>
<p>
Cochran, W. and Rubin, D.B. (1973), "Controlling Bias in Observational
  Studies", Sankyha, 35, 417-446.
Dehejia, R.H and Wahba, S. (1999), "Causal Effects in Non-Experimental Studies:
  Re-Evaluating the Evaluation of Training Programmes", Journal of the American
  Statistical Association, 94, 1053-1062.
Heckman, J.J., Ichimura, H. and Todd, P.E. (1997), "Matching As An Econometric
  Evaluation Estimator: Evidence from Evaluating a Job Training Programme",
  Review of Economic Studies, 64, 605-654.
Heckman, J.J., Ichimura, H. and Todd, P.E. (1998), "Matching as an Econometric
  Evaluation Estimator", Review of Economic Studies, 65, 261-294.
Heckman, J.J., Ichimura, H., Smith, J.A. and Todd, P. (1998), "Characterising
  Selection Bias Using Experimental Data", Econometrica, 66, 5.
Heckman, J.J., LaLonde, R.J., Smith, J.A. (1998), "The Economics and
  Econometrics of Active Labour Market Programmes", in Ashenfelter, O. and
  Card, D. (eds.), The Handbook of Labour Economics, Volume III.
Imbens, G. (2000), "The Role of Propensity Score in Estimating Dose-Response
  Functions", Biometrika, 87, 3, 706-710.
Lechner, M. (2001), Identification and Estimation of Causal Effects of Multiple
  Treatments under the Conditional Independence Assumption, in: Lechner, M.,
  Pfeiffer, F. (eds), Econometric Evaluation of Labour Market Policies,
  Heidelberg: Physica/Springer, p. 43-58.
Rosenbaum, P.R. and Rubin, D.B. (1983), "The Central Role of the Propensity
  Score in Observational Studies for Causal Effects", Biometrika, 70, 1, 41-55.
Rosenbaum, P.R. and Rubin, D.B. (1985), "Constructing a Control Group Using
  Multivariate Matched Sampling Methods that Incorporate the Propensity Score",
  The American Statistician, 39, 1, 33-38.
Rubin, D.B. (1974), "Estimating Causal Effects of Treatments in Randomised and
  Non-Randomised Studies", Journal of Educational Psychology, 66, 688-701.
Rubin, D.B. (1980), "Bias Reduction Using Mahalanobis-Metric Matching",
  Biometrics, 36, 293-298.
<p>
</pre>