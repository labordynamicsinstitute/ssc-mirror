<pre>
-------------------------------------------------------------------------------
help for <b>psmatch2</b>
-------------------------------------------------------------------------------
<p>
<b><u>Mahalanobis and Propensity score Matching</u></b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [<b>,</b> <b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b>
                     <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b><u>n</u></b><b>eighbor(</b><i>integer</i><b>)</b> <b>radius</b> <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b>
                     <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b> <b>ai(</b><i>integer</i><b>)</b> <b>kernel</b> <b>llr</b>
                     <b><u>k</u></b><b>erneltype(</b><i>type</i><b>)</b> <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> <b>spline</b> <b><u>n</u></b><b>knots(</b><i>integer</i><b>)</b>
                     <b><u>com</u></b><b>mon</b> <b>trim(</b><i>real</i><b>)</b> <b><u>norepl</u></b><b>acement</b> <b><u>desc</u></b><b>ending</b> <b>odds</b> <b>index</b>
                     <b>logit</b> <b>ties</b> <b><u>qui</u></b><b>etly</b> <b>w(</b><i>matrix</i><b>)</b> <b>ate</b>]
<p>
<b><u>Description</u></b>
<p>
    <b>psmatch2</b> implements full Mahalanobis matching and a variety of propensity
    score matching methods to adjust for pre-treatment observable differences
    between a group of treated and a group of untreated.  Treatment status is
    identified by <i>depvar</i>==1 for the treated and <i>depvar</i>==0 for the untreated
    observations.
<p>
    <b>psmatch2</b> is being continuously improved and developed. Make sure to keep
    your version up-to-date as follows
<p>
     . ssc install psmatch2, replace
<p>
    By default <b>psmatch2</b> calculates approximate standard errors on the
    treatment effects assuming independent observations, fixed weights,
    homoskedasticity of the outcome variable within the treated and within
    the control groups and that the variance of the outcome does not depend
    on the propensity score:
<p>
    1/N1*Var(Y | DM=1) + Sum(w_i^2; i in DM=0)/(N1)^2*Var(Y | DM=0)
<p>
    where N1 is the number of matched treated, DM=1 denotes the matched
    treated, DM=0 the matched controls and w_i is the weight given to control
    i. <b>psmatch2</b> stores the estimate of the standard error of the ATT in
    <i>r(seatt)</i> or with more than one outcome variable, in <i>r(seatt_varname)</i>.
<p>
    With nearest neighbor matching on the X's (<b>mahal()</b>), then analytical
    standard errors as in Abadie and Imbens (2006) are calculated when <i>M&gt;0</i> is
    passed using option <b>ai(</b><i>M</i><b>)</b>, where <i>M</i> is the number of neighbors that are
    used to calculate the conditional variance (formula (14) in Abadie and
    Imbens, 2006).
<p>
    <b>psmatch2</b> stores the estimate of the treatment effect on the treated in
    <i>r(att)</i>, this allows bootstrapping of the standard error of the estimate
    (although it is unclear whether the bootstrap is valid in this context).
    This can be done as follows:
<p>
     . bootstrap r(att) : psmatch2 training age gender, out(wage)
<p>
    If the average treatment is requested using option <i>ate</i> the estimate is
    returned in <i>r(ate)</i>. The average treatment effect on the untreated is then
    also returned in <i>r(atu)</i>.  With more than one outcome variable the effects
    are returned as r(att_<i>varname</i>) etc. for each outcome variable and effect.
<p>
    See the documentation of bootstrap for more details about bootstrapping
    in Stata.
<p>
    If you want to be able to replicate your results you should set seed
    before calling <b>psmatch2</b>.
<p>
    The propensity score - the conditional treatment probability - is either
    directly provided by the user or estimated by the program on the
    <i>indepvars</i>. Note that the sort order of your data could affect the results
    when using nearest-neighbor matching on a propensity score estimated with
    categorical (non-continuous) variables. Or more in general when there are
    untreated with identical propensity scores.
<p>
    Matching methods to choose from are one-to-one (nearest neighbour or
    within caliper; with or without replacement), <i>k</i>-nearest neighbors,
    radius, kernel, local linear regression, 'spline-smoothing' and
    Mahalanobis matching. The following list presents the syntax for each
    method.
<p>
    You can also click here to pop up a dialog or type db psmatch2.
<p>
<b><u>About sample weights</u></b>
<p>
    As far as we know it's not really clear in the literature how to
    accommodate sample weights in the context of matching. If you are aware
    how to properly account for sampling weights, please let us know.  In the
    meantime, here are some thoughts you might want to take into
    consideration when asking yourself the following questions:
<p>
    1) Should I use weights when estimating the score?
<p>
    The recommendation to date seems to be to ignore sampling weights,
    estimate the propensity score using a logit model (option <b>logit</b>) and
    match on the odds ratio (option <b>odds</b>)
<p>
    2) Should I use weights after having performed matching?
<p>
    When interested in the effect of treatment on the treated, the sampling
    weights should refer to the treated alone. So the pweigths should be
    applied to the observed and to the matched outcome (if need be further
    restricted to the treated on the common support) for all the treated:
<p>
    . sum outcome if treated==1 [aw=pweight]
<p>
    . sum _outcome if treated==1 [aw=pweight]
<p>
<b><u>Matching within strata</u></b>
<p>
    The following code illustrates how to match within exact cells and then
    calculate the average effect for the whole population.
<p>
        <b>g att = .</b>
        <b>egen g = group(groupvars)</b>
        <b>levels g, local(gr)</b>
        <b>qui foreach j of local gr {</b>
                <b>psmatch2 treatvar varlist if g==`j', out(outvar)</b>
                <b>replace att = r(att) if  g==`j'</b>
        <b>}</b>
        <b>sum att</b>
<p>
<b><u>Detailed Syntax</u></b>
<p>
    <b>One-to-one matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> [<b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b>
                     <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b>ai(</b><i>integer k</i>&gt;1<b>)</b> <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b>
                     <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> <b><u>norep</u></b><b>lacement</b> <b><u>desc</u></b><b>ending</b> <b><u>com</u></b><b>mon</b> <b>trim(</b><i>real</i><b>)</b>
                     <b>odds</b> <b>index</b> <b>logit</b> <b>ties</b> <b><u>nowarn</u></b><b>ings</b> <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
<p>
    <i>k</i><b>-Nearest neighbors matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> [<b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b>
                     <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b><u>n</u></b><b>eighbor(</b><i>integer k</i>&gt;1<b>)</b> <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b>
                     <b><u>com</u></b><b>mon</b> <b>trim(</b><i>real</i><b>)</b> <b>odds</b> <b>index</b> <b>logit</b> <b>ties</b> <b><u>nowarn</u></b><b>ings</b>
                     <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
<p>
    <b>Radius matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <b>radius</b>
                     <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> [<b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b><u>com</u></b><b>mon</b>
                     <b>trim(</b><i>real</i><b>)</b> <b>odds</b> <b>index</b> <b>logit</b> <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
<p>
    <b>Kernel matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <b>kernel</b>
                     [<b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> <b><u>k</u></b><b>erneltype(</b><i>kernel_type</i><b>)</b>
                     <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b> <b><u>com</u></b><b>mon</b>
                     <b>trim(</b><i>real</i><b>)</b> <b>odds</b> <b>index</b> <b>logit</b> <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
<p>
    <b>Local linear regression matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <b>llr</b>
                     <b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> [<b><u>k</u></b><b>erneltype(</b><i>kernel_type</i><b>)</b>
                     <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b> <b><u>com</u></b><b>mon</b>
                     <b>trim(</b><i>real</i><b>)</b> <b>odds</b> <b>index</b> <b>logit</b> <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
    <b>Spline matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<i>indepvars</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <b>spline</b>
                     <b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> [<b><u>nk</u></b><b>nots(</b><i>integer</i><b>)</b> <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b>
                     <b><u>n</u></b><b>eighbor(</b><i>integer</i><b>)</b> <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> <b><u>com</u></b><b>mon</b> <b>trim(</b><i>real</i><b>)</b> <b>odds</b>
                     <b>index</b> <b>logit</b> <b>ties</b> <b><u>nowarn</u></b><b>ings</b> <b><u>qui</u></b><b>etly</b> <b>ate</b>]
<p>
    <b>Mahalanobis matching:</b>
<p>
        <b>psmatch2</b> <i>depvar</i> [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] <b>,</b> <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b>
                     <b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> <b>ai(</b><i>integer</i><b>)</b> [<b><u>k</u></b><b>ernel(</b><i>kernel_type</i><b>)</b> <b>llr</b>
                     <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> <b>w(</b><i>matrix</i><b>)</b> <b>ate</b>]
<p>
<p>
    <b>psmatch2</b> creates a number of variables for the convenience of the user:
<p>
        _treated is a variable that equals 0 for control observations and 1
        for treatment observations.
<p>
        _support is an indicator variable with equals 1 if the observation is
        on the common support and 0 if the observatio is off the support.
<p>
        _pscore is the estimated propensity score or a copy of the one
        provided by <b><u>p</u></b><b>score()</b>.
<p>
        _<i>outcome_variable</i> for every treatment observation stores the value of
        the matched outcome.
<p>
        _weight. For nearest neighbor matching, it holds the frequency with
        which the observation is used as a match; with option <b>ties</b> and
        k-nearest neighbors matching it holds the normalized weight; for
        kernel matching, and llr matching with a weight other than stata's
        tricube, it stores the overall weight given to the matched
        observation. When estimating att only _weight = 1 for the treated.
<p>
        _id In the case of one-to-one and nearest-neighbors matching, a new
        identifier created for all observations.
<p>
        _n<i>k</i> In the case of one-to-one and nearest-neighbors matching, for
        every treatment observation, it stores the observation number of the
        k-th matched control observation. Do not forget to sort by <i>_id</i> if you
        want to use the observation number (id) of for example the 1st
        nearest neighbor as in
<p>
        <b>sort _id</b>
        <b>g x_of_match = x[_n1]</b>
<p>
        _nn In the case of nearest-neighbors matching, for every treatment
        observation, it stores the number of matched control observations.
<p>
<b><u>Options</u></b>
<p>
    <b><u>out</u></b><b>come(</b><i>varlist</i><b>)</b> the outcome variable(s).  When evaluating multiple
        outcomes psmatch2 reduces to the min common number of observations
        with non-missing values on ALL outcomes, because otherwise the
        matching weigths will not sum to the right number. If you have
        multiple outcomes with widely differing missing values you may wish
        to run psmatch2 separately for each of the outcomes.
<p>
    <b>ate</b> with this option the average treatment effect (ate) and average
        treatment effect on the untreated (atu) are reported in addition to
        the average treatment effect on the treated (att).  The estimates are
        returned in <i>r(ate)</i>, <i>r(atu)</i> and <i>r(att)</i> respectively, see above.
<p>
    <b>ai(</b><i>integer</i><b>)</b> requires calculation of the heteroskedasticity-consistent
        analytical standard errors proposed by Abadie and Imbens (2006) by
        specifying the number of neighbors to be used to calculate the
        conditional variance (their formula (14)). Note that this is
        appropriate for nearest-neighbor matching on the X's, i.e.
        Mahalanobis-metric matching (<b>mahal()</b>) not augmented with the
        propensity score.
<p>
<p>
<b><u>Options: Estimation of the propensity score</u></b>
<p>
    <b><u>p</u></b><b>score(</b><i>varname</i><b>)</b> specifies the variable to be used as propensity score.
<p>
    Alternatively, <i>indepvars</i> need to be specified to allow the program to
    estimate the propensity score on them.  In this case:
<p>
    <b>logit</b> use logit instead of the default probit to estimate the propensity
        score.
<p>
    <b><u>qui</u></b><b>etly</b> do not print output of propensity score estimation.
<p>
    <b>odds</b> match on the odds ratio of the propensity score.
<p>
    <b>index</b> use the latent variable index instead of the probability.
<p>
    <b><u>nowarn</u></b><b>ings</b> do not test for control observations with duplicate propensity
        score values.
<p>
<p>
<b><u>Options: Imposition of common support</u></b>
<p>
    <b><u>com</u></b><b>mon</b> imposes a common support by dropping treatment observations whose
        pscore is higher than the maximum or less than the minimum pscore of
        the controls.
<p>
    <b>trim(</b><i>integer</i><b>)</b> imposes common support by dropping # percent of the
        treatment observations at which the pscore density of the control
        observations is the lowest.
<p>
<b><u>Options: Choice of matching estimator</u></b>
<p>
    <b><u>n</u></b><b>eighbor(</b><i>integer</i><b>)</b> number of neighbors used to calculate the matched
        outcome.  Defaults to 1. Default matching method is single
        nearest-neighbour (without caliper).
<p>
    <b><u>norep</u></b><b>lacement</b> perform 1-to-1 matching without replacement. Nearest
        neigbor propensity score matching only.
<p>
    <b><u>desc</u></b><b>ending</b> perform 1-to-1 matching without replacement in descending
        order. Nearest neighbor propensity score matching only.
<p>
    <b>ties</b> not only match nearest neighbor but also other controls with
        identical (tied) pscores.
<p>
    <b>radius</b> perform radius matching within the specified radius given by
        <b>caliper</b>.
<p>
    <b><u>cal</u></b><b>iper(</b><i>real</i><b>)</b> value for maximum distance of controls.  Use to perform
        nearest neighbor(s) within caliper, radius matching and Mahalanobis
        1-to-1 matching.
<p>
    <b><u>k</u></b><b>ernel</b> perform kernel matching.
<p>
    <b><u>k</u></b><b>erneltype(</b><i>kernel_type</i><b>)</b> specifies the type of kernel:
<p>
        normal the gaussian kernel.
<p>
        biweight the biweight kernel.
<p>
        epan the epanechnikov kernel (Default with kernel matching).
<p>
        uniform the uniform kernel.
<p>
        tricube the tricube kernel (Default with llr matching).
<p>
    <b>llr</b> llr use local linear regression matching instead of kernel matching.
        Option <b><u>k</u></b><b>erneltype()</b> allows changing the kernel from the default
        tricube one.
<p>
    <b><u>bw</u></b><b>idth(</b><i>real</i><b>)</b> the bandwidth for kernel and local linear regression
        matching.  Default bandwidth is 0.06, except when doing local linear
        regression with the tri-cube kernel when the default bandwidth is
        0.8. In this latter case centered subsets of N*bwidth observations
        are used.
<p>
    <b><u>mahal</u></b><b>anobis(</b><i>varlist</i><b>)</b> perform Mahalanobis-metric matching on<i> varlist</i>.
<p>
    <b>w(</b><i>matrix</i><b>)</b> specify alternative weighting matrix. Mahalanobis-metric
        matching becomes matching on a quadratic metric with the specified
        weighting matrix.
<p>
    <b>spline</b> performs 'spline-smoothing matching' by first fitting a natural
        cubic spline on pscore (or on the result from estimate) to outcome.
        The matched values are stored in the new variable, _s_outcomevar.
        (It requires the <b>spline</b> programme, which for stata7 needs to be
        downloaded by typing: net install snp7_1.)
<p>
    <b><u>nk</u></b><b>nots(</b><i>integer</i><b>)</b> specifies the number of interior knots for spline
        smoothing. Default is the fourth root of the number of comparison
        units.
<p>
<b><u>Examples</u></b>
<p>
     . psmatch2 training age gender, kernel k(biweight) out(wage)
     . psmatch2 training age gender, n(5) logit
     . psmatch2 training age gender, out(wage)
     . bs "psmatch2 training age gender, out(wage)" "r(att)"
<p>
<b><u>Also see</u></b>
<p>
    The commands pstest, psgraph.
<p>
<p>
<b><u>Thanks for citing </u></b><b><u>psmatch2</u></b><b><u> as follows</u></b>
<p>
    E. Leuven and B. Sianesi. (2003). "PSMATCH2: Stata module to perform full
    Mahalanobis and propensity score matching, common support graphing, and
    covariate imbalance testing".
    http://ideas.repec.org/c/boc/bocode/s432001.html. This version
    INSERT_VERSION_HERE.
<p>
where you can check your version as follows:
<p>
     . which psmatch2
<p>
<p>
<b><u>Disclaimer</u></b>
<p>
    THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
    ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
    SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
    SERVICING, REPAIR OR CORRECTION.
<p>
    IN NO EVENT WILL THE COPYRIGHT HOLDERS OR THEIR EMPLOYERS, OR ANY OTHER
    PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THIS SOFTWARE, BE LIABLE TO YOU
    FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
    DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING
    BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
    LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO
    OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS
    BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
<p>
<b><u>Background Reading</u></b>
<p>
Abadie A. and Imbens, G. (2006), "Large sample properties of matching
  estimators for average treatment effects", <i>Econometrica 74</i>(1), 235-267.
<p>
Cochran, W. and Rubin, D.B. (1973), "Controlling Bias in Observational
  Studies", <i>Sankyha 35</i>, 417-446.
<p>
Dehejia, R.H and Wahba, S. (1999), "Causal Effects in Non-Experimental Studies:
  Re-Evaluating the Evaluation of Training Programmes", <i>Journal of the American</i>
  <i>Statistical Association 94</i>, 1053-1062.
<p>
Heckman, J.J., Ichimura, H. and Todd, P.E. (1997), "Matching As An Econometric
  Evaluation Estimator: Evidence from Evaluating a Job Training Programme",
  <i>Review of Economic Studies 64</i>, 605-654.
<p>
Heckman, J.J., Ichimura, H. and Todd, P.E. (1998), "Matching as an Econometric
  Evaluation Estimator", <i>Review of Economic Studies 65</i>, 261-294.
<p>
Heckman, J.J., Ichimura, H., Smith, J.A. and Todd, P. (1998), "Characterising
  Selection Bias Using Experimental Data", <i>Econometrica 66</i>, 5.
<p>
Heckman, J.J., LaLonde, R.J., Smith, J.A. (1998), "The Economics and
  Econometrics of Active Labour Market Programmes", in Ashenfelter, O. and
  Card, D. (eds.), <i>The Handbook of Labour Economics Vol. 3A</i>.
<p>
Imbens, G. (2000), "The Role of Propensity Score in Estimating Dose-Response
  Functions", <i>Biometrika 87(3)</i>, 706-710.
<p>
Lechner, M. (2001), Identification and Estimation of Causal Effects of Multiple
  Treatments under the Conditional Independence Assumption, in: Lechner, M.,
  Pfeiffer, F. (eds), <i>Econometric Evaluation of Labour Market Policies</i>,
  Heidelberg: Physica/Springer, p. 43-58.
<p>
Rosenbaum, P.R. and Rubin, D.B. (1983), "The Central Role of the Propensity
  Score in Observational Studies for Causal Effects", <i>Biometrika 70</i>, 1, 41-55.
<p>
Rosenbaum, P.R. and Rubin, D.B. (1985), "Constructing a Control Group Using
  Multivariate Matched Sampling Methods that Incorporate the Propensity Score",
  <i>The American Statistician 39(1)</i>, 33-38.
<p>
Rubin, D.B. (1974), "Estimating Causal Effects of Treatments in Randomised and
  Non-Randomised Studies", <i>Journal of Educational Psychology 66</i>, 688-701.
<p>
Rubin, D.B. (1980), "Bias Reduction Using Mahalanobis-Metric Matching",
  <i>Biometrics 36</i>, 293-298.
<p>
<b><u>Author</u></b>
<p>
    Edwin Leuven, University of Oslo. If you observe any problems 
    mailto:e.leuven@gmail.com.
<p>
    Barbara Sianesi, Institute for Fiscal Studies, London, UK.
<p>
</pre>