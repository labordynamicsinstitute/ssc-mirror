<pre>
-------------------------------------------------------------------------------
help for <b>povdeco</b>                               Stephen P. Jenkins (August 2006)
-------------------------------------------------------------------------------
<p>
<b><u>Poverty indices, with optional decomposition by subgroup</u></b>
<p>
        <b>povdeco</b> <i>varname</i> [<i>weights</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [, <b><u>pl</u></b><b>ine(</b><i>#</i><b>)</b>
                 <b><u>varpl</u></b><b>ine(</b><i>zvar</i><b>)</b> <b><u>by</u></b><b>group(</b><i>groupvar</i><b>)</b> <b><u>s</u></b><b>ummarize</b>]
<p>
    <b>fweight</b>s and <b>aweights</b> are allowed; see help weights.
<p>
<b><u>Description</u></b>
<p>
    <b>povdeco</b> estimates three poverty indices from the Foster, Greer and
    Thorbecke (1984) class, FGT(a). FGT(0) is the headcount ratio (the
    proportion poor); FGT(1) is the average normalised poverty gap; FGT(2) is
    the average squared normalised poverty gap. The larger a is, the greater
    the degree of `poverty aversion' (sensitivity to large poverty gaps).
    Optionally provided are statistics such as mean income amongst the poor
    and also decompositions of these indices by population subgroup. Poverty
    decompositions by subgroup are useful for providing poverty `profiles' at
    a point in time, and for analyzing secular trends in poverty using
    shift-share analysis. Unit record (`micro' level) data are required.
<p>
    Typically one's data are in one of two forms. Either (1) the money
    incomes for each unit i, x_i, are equivalised using an equivalence scale
    factor, m_i, so that y_i = x_i / m_i, and the poverty line is a single
    (common) value, in the same units as equivalised income, z. Or (2)
    incomes are not equivalised, but there are different poverty lines
    depending on (for example) household type. Suppose the poverty line for
    unit i is z_i.  Observe that if z_i = z * m_i, FGT poverty index
    calculations based on {y_i,z} give exactly the same answers as
    calculations based on {x_i,z_i}, i=1,...,n.  For the common poverty line
    case, use <b>pline(</b><i>#</i><b>)</b> to specify the poverty line. For the heterogeneous
    poverty line case, use <b>varpline(</b><i>zvar</i><b>)</b> to specify the poverty lines.
<p>
    For the characterization of the FGT(a) poverty index, see Foster et al.
    (1984).  Seidl (1988) and Zheng (1997) survey the literature on aggregate
    poverty indices.
<p>
    <i>groupvar</i> must take non-negative integer values only. To create such a
    variable from an existing variable, use the egen function <b>group</b>.  By
    default, observations with missing values on <i>groupvar</i> are excluded from
    calculations when the <b>bygroup</b> option is specified. If you wish to include
    them, create a new variable with the egen function <b>group</b> and use its
    <b>missing</b> option. The egen function <b>group</b> is also useful for multi-way
    decompositions. E.g. for a decomposition by sex and region, create a new
    <i>groupvar</i> defining sex-region combinations by specifying sex and region in
    <b>group(</b><i>varlist</i><b>)</b>.
<p>
    Bootstrapped standard errors for the estimates of the indices can be
    derived using bootstrap. Standard errors derived using linearization
    methods can be calculated straightforwardly by first creating for each
    FGT(a) index, a variable equal to I_i * [ ( z_i - y_i ) / z_i) ] ^ a,
    where I_i = 1 if observation i is poor and 0 otherwise. Then estimate the
    mean of each of these new variables using <b>svy mean</b> having first
    appropriately <b>svyset</b> your data. See Jenkins (2006) for examples.
<p>
<p>
<b><u>Technical details</u></b>
<p>
    Consider a population of persons (or households ...), i = 1,...,n, with
    income y_i, and weight w_i. Let f_i = w_i / N, where N = SUM w_i.  (In
    what follows all sums are over all values of whatever is subscripted.)
    When the data are unweighted, w_i = 1 and N = n.  The poverty line is z_i
    for each i, and the poverty gap for person i is max(0, z_i-y_i). For the
    common poverty line case (1) above, z_i = z, all i.
<p>
    Suppose there is an exhaustive partition of the population into
    mutually-exclusive subgroups k = 1,...,K.
<p>
    The FGT class of poverty indices is given by
<p>
        FGT(a) = SUM f_i * I_i * [ ( z_i - y_i ) / z_i) ] ^ a, a &gt;= 0,
<p>
    where I_i = 1 if y_i &lt; z_i and I_i = 0 otherwise.
<p>
    Each FGT(a) index can be additively decomposed as
<p>
        FGT(a) = SUM v_k * FGT_k(a)
<p>
    where v_k = N_k / N is the weighted number of persons in subgroup k
    divided by the weighted total number of persons (subgroup population
    share), and FGT_k(a), poverty for subgroup k, is calculated as if each
    subgroup were a separate population.
<p>
    Also displayed when subgroup decompositions requested, for each k, are:
<p>
        subgroup poverty 'share', S_k = v_k * FGT_k(a) / FGT(a), and
<p>
        subgroup poverty 'risk', R_k = FGT_k(a) / FGT(a) = S_k / v_k.
<p>
<p>
<b><u>Options</u></b>
<p>
    <b>bygroup(</b><i>groupvar</i><b>)</b> requests inequality decompositions by population
        subgroup, with subgroup membership summarized by <i>groupvar</i>.
<p>
    <b>summarize</b> requests presentation of the mean of <i>varname</i>, the mean among
        the poor, and the mean poverty gap among the poor.
<p>
    <b>pline(</b><i>#</i><b>)</b> is used to specify the poverty line <i>#</i> in the common poverty line
        case.
<p>
    <b>varpline(</b><i>zvar</i><b>)</b> is used to specify the variable <i>zvar</i> containing the values
        of poverty line for each observation in the heterogeneous poverty
        line case.
<p>
<p>
<b><u>Saved results</u></b> 
<p>
    r(fgt0), r(fgt1), r(fgt2)   FGT(a), for a = 0, 1, 2 
     
    r(mean)                     mean
    r(meanpoor)                 mean among the poor
    r(meangappoor)              mean poverty gap among the poor
    r(N), r(sumw)               number of observations, sum of weights
<p>
    If the <b>bygroup</b> option is specified, also saved are:
<p>
    r(fgt0_k)                   FGT(a), for a = 0, 1, 2, and
    r(fgt1_k)                   each subgroup k, where the values of k
    r(fgt2_k)                   correspond to the values of <i>groupvar</i>
                                in the estimation sample. See r(levels) below.
<p>
    r(mean_k)                   mean among subgroup k
    r(meanpoor_k)               mean among the poor in subgroup k
    r(meangappoor_k)            mean poverty gap among the poor in subgroup k
    r(n_k), r(sumw_k)           number of subgroup observations, subgroup sum o
&gt; f weights
    r(v_k)                      subgroup population share, v_k 
    r(share0_k)                 FGT(0) poverty share among subgroup k
    r(share1_k)                 FGT(1) poverty share among subgroup k
    r(share2_k)                 FGT(2) poverty share among subgroup k
    r(risk0_k)                  FGT(0) poverty risk among subgroup k
    r(risk1_k)                  FGT(1) poverty risk among subgroup k
    r(risk2_k)                  FGT(2) poverty risk among subgroup k
<p>
    r(levels)                   macro containing the set of values of <i>groupvar</i>
                                (the number of unique values = K)
<p>
<p>
    For the convenience of users of earlier versions of these programs, a
    selected set of estimates is also saved in global macros, as follows.
<p>
    S_FGT0, S_FGT1, S_FGT2      FGT(a), for a = 0, 1, 2 
<p>
        
<b><u>Examples</u></b>
<p>
    <b>. povdeco x [aw = wgtvar], pline(100)</b>
<p>
    <b>. povdeco x [aw = wgtvar], pline(100) by(famtype)</b>
<p>
    <b>. povdeco x, varpline(z)</b>
<p>
    <b>. povdeco x if sex==1, pl(100) summarize</b>
<p>
    <b>. // bootstrapped standard errors for FGT(2) in Stata version 8</b>
<p>
    <b>. preserve</b>
<p>
    <b>. keep if x &gt; 0 &amp; x &lt; .</b>
<p>
    <b>. version 8: bootstrap "povdeco x, pline(100)" fgt2 = r(fgt2), reps(100)</b>
<p>
    <b>. restore</b>
<p>
    <b>. // bootstrapped standard errors for FGT(2) in Stata version 9</b>
<p>
    <b>. preserve</b>
<p>
    <b>. keep if x &gt; 0 &amp; x &lt; .</b>
<p>
    <b>. bootstrap fgt2 = r(fgt2), reps(100): povdeco x, pline(100)</b>
<p>
    <b>. restore</b>
<p>
    <b>. // multi-way decomposition</b>
<p>
    <b>. egen sexXregion = group(sex region)</b>
<p>
    <b>. povdeco x, pline(100) by(sexXregion)</b>
<p>
<p>
<b><u>Author</u></b>
<p>
    Stephen P. Jenkins &lt;stephenj@essex.ac.uk&gt;
    Institute for Social and Economic Research
    University of Essex, Colchester CO4 3SQ, U.K.
<p>
<b><u>Acknowledgements</u></b>
<p>
    For comments and suggestions, I am grateful to Philippe Van Kerm and Nick
    Cox.
<p>
<b><u>References</u></b>
<p>
    Foster, J.E., Greer, J., and Thorbecke, E. 1984.  A class of decomposable
        poverty indices.  <i>Econometrica</i> 52: 761-766.
<p>
    Jenkins, S.P. 2006. Estimation and interpretation of measures of
        inequality, poverty, and social welfare using Stata. Presentation at
        North American Stata Users' Group Meetings 2006, Boston MA.  
        http://econpapers.repec.org/paper/bocasug06/16.htm.
<p>
    Seidl, C. 1988. Poverty measurement: a survey. In: D. Bös, M. Rose and C.
        Seidl (eds.), <i>Welfare and Efficiency in Public Economics</i>. Heidelberg:
        Springer-Verlag.
<p>
    Zheng, B. 1997. Aggregate poverty indices.  <i>Journal of Economic Surveys</i>
        11: 123-162.
<p>
<b><u>Also see</u></b>
<p>
    poverty if installed; ineqdeco if installed.
<p>
 
<p>
</pre>