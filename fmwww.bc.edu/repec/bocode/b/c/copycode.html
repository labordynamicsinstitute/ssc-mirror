<pre>
<b>copycode</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>copycode -- produce modular self-written ado files</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>copycode</b> <i>projectname</i> <b>,</b> <b><u>i</u></b><b>nputfile(</b><i>inputfilename</i><b>)</b>
                 [ <b>{</b><b><u>t</u></b><b>argetfile(</b><i>targetfilename</i><b>)</b> | <b><u>noc</u></b><b>opy</b> <b>}</b> <i>other_options</i> ]
<p>
    <i>main_options</i>                    Description
    -------------------------------------------------------------------------
      <i>projectname</i>                   Name of project to be processed
      <b><u>i</u></b><b>nputfile(</b><i>inputfilename</i><b>)</b>      Name/path of input file that contains the
                                      file listings
      <b><u>t</u></b><b>argetfile(</b><i>targetfilename</i><b>)</b>    Name/path of output file
      <b><u>noc</u></b><b>opy</b>                        Show command output without performing
                                      the copy operation
                                    
    <i>other_options</i>                   Description
    -------------------------------------------------------------------------
      <b><u>si</u></b><b>mplemode</b>                    Process project under simple mode (as
                                      opposed to ado mode)
      <b>replace</b>                       Replace target file if it already exists
      <b>force</b>                         Do not confine copying of lines to copy
                                      regions
      <b><u>st</u></b><b>arbang(</b><i>stb_mode</i><b>)</b>            Determine whether starbang lines should
                                      be copied
      <b><u>nop</u></b><b>rogdrop</b>                    Do not automatically drop program
                                      corresponding to <i>targetfilename</i> from
                                      memory
    -------------------------------------------------------------------------
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>copycode</b> copies different source code files into one file.  A typical
    application would be an ado file whose final version is supposed to
    contain subroutines and/or Mata routines that you are accustomed to use
    and re-use in your ados.
<p>
    <b>copycode</b> is thought to facilitate code production, code maintenance and
    code distribution for Stata programmers who write Stata/Mata code on a
    large scale.  You can write small programs and functions, each one in a
    separate file, test them thoroughly, and then include them in any ado
    file using <b>copycode</b>.  When you have to make changes to these general
    purpose functions the re-make of the ado files is completely automated.
<p>
    If you have written many ado files with many interdependencies (i.e. many
    of your self-written ados call other self-written ados), <b>copycode</b> enables
    you to organize your code in such a way that each final ado file is
    "modular", i.e. does not depend on other user-written code files.  This
    makes the distribution of your files easier.
<p>
    If you do not want to use <b>copycode</b> to produce your final ado files, you
    can still use it to shed light on the dependency structure of your files
    (see the nocopy subsection below).
<p>
    Another feature of <b>copycode</b> is that it allows you to add "private"
    comments to your source code file.  Your final published file will not
    include these lines.
<p>
    There is also a wrapper command for <b>copycode</b> available called fastcc
    ("fast copycode") that will allow you to work with <b>copycode</b> more
    efficiently when using it interactively.
<p>
    For an alternative description of <b>copycode</b> see Schneider (2012).
<p>
<p>
<b><u>Defintions used in this help entry</u></b>
<p>
    The definitions of the following table are repeated in the help text as
    terms appear.  The table is thought to serve as a reference for a more
    thorough reading of this help entry.
<p>
    modular ado file             A (user-written) ado file whose functioning
                                 does not require the presence/installation of
                                 other user-written code files.
    project                      Identifies a set of code files that belong
                                 together.
    main adv                     File that is listed first for a project and
                                 whose name corresponds to the project name and
                                 that has an .adv extension.  It contains the
                                 main program of a (ado) project.
    project component file       Each file entry under a project in the input
                                 file.
    dependency                   Program or function that is called by another
                                 program or function.  There can be
                                 direct/first-order and indirect/higher-order
                                 dependencies.
    copy region limits           Strings '!copycodebeg=&gt;' (beginning of a copy
                                 region) and '!copycodeend||' (end of a copy
                                 region).
    copy region                  Lines of a text file between the strings
                                 '!copycodebeg=&gt;' and '!copycodeend||'.
<p>
<p>
<b><u>Options</u></b>
<p>
    <i>projectname</i> Name of project in the input file that pins down the file
        listing.
<p>
    <b>inputfile(inputfilename)</b> specifies the file path and name of the input
        file.  Relative file paths are accepted.  The absolute part of the
        path is assumed to be the working directory.
<p>
    <b>targetfile(targetfilename)</b> determines the file path and name of the
        output file.  Relative file paths are accepted.  The absolute part of
        the path is assumed to be the working directory.
<p>
    <b>nocopy</b> can be used to specify that no targetfile should be created.  If
        this option is used, <b>copycode</b> performs fewer consistency checks of
        what you supply as input.  It still performs a consistency check of
        the input file.  It does not, however, check for the existence of
        files, nor does it check for the consistency of copy region limits
        within code files.
<p>
        When using option <b>nocopy</b>, options <b>replace</b>, <b>force</b> and <b>starbang</b> are
        ignored.  Option <b>nocopy</b> does observe the usual rules that apply in
        determining whether <b>copycode</b> is run in simple mode or in ado mode.
<p>
    <b>simplemode</b> will force simple mode.  Ado mode is entered when the first
        file for the project to be processed is a "main adv" file.  Option
        <b>simplemode</b> overrides this.  Then, only the files listed under
        <i>projectname</i> (direct dependencies) will be copied together, without
        checking for dependencies of adv files that belong to the project
        (see section Simple mode and ado mode below).
<p>
    <b>replace</b> will overwrite the outputfile if it already exists.
<p>
    <b>force</b> tells <b>copycode</b> to perform copy operations irrespective of copy
        regions of the code files.  Under option <b>force</b> all lines of all files
        will be copied except for starbang lines.  What happens to starbang
        lines is determined by option <b>starbang(</b><i>stb_mode</i><b>)</b>.
<p>
    <b>starbang(stb_mode)</b> specifies whether starbang lines should be copied to
        the output file.  The contents of starbang lines are displayed by the
        which command.  There are three modes, i.e. <i>stb_mode</i> may assume three
        values:  "skip" will not copy any starbang lines.  "first" will only
        copy starbang lines of the main adv file.  "all" will copy all
        starbang lines.
<p>
        Typically, when producing an ado file you only want to have the
        starbang line(s) of the main adv displayed by <b>which</b> and not the ones
        of subordinate advs or subroutines, which is why <i>stb_mode</i> defaults to
        "first" in ado mode.  In simple mode, however, <i>stb_mode</i> defaults to
        "all".
<p>
    <b>noprogdrop</b> will prevent <b>copycode</b> from automatically issuing a
        <b>. capture program drop </b><i>targetbasename</i>
        statement, where <i>targetbasename</i> is the file name "base" of
        <i>targetfilename</i>.  For example, if you specify
        <b>targetfile(mypath/mytarget.ado)</b>, copycode normally issues a
        <b>. capture program drop mytarget</b>
        to ensure that after the re-make of the project no old version of the
        project resides in memory.  Option <b>noprogdrop</b> prevents this statement
        from being executed.
<p>
        Usage of option <b>nocopy</b> will also prevent the "program drop"
        statement.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Remarks are presented under the following headings:
<p>
    Overview
    Backup
    Simple mode and ado mode
    File extensions 
    Input file structure
    Code dependencies
    Copy regions
    Avoiding file loss
    Downsides    
    The 'nocopy' option
    Miscellaneous
<p>
<a name="overview"></a> <b><u>Overview</u></b>
<p>
    <b>copycode</b> compiles a list of code files (text files) that accounts for
    code dependencies of a project and copies code from these files to
    <i>targetfile</i>.
<p>
    A dependency is a user-written program or function that is called by
    another user-written program or function.  There can be
    direct/first-order and indirect/higher-order dependencies.  If a.ado
    calls b.ado and b.ado calls c.ado, b.ado is a direct dependency of a.ado,
    c.ado is a direct dependency of b.ado, and c.ado is an indirect
    dependency of a.ado.  With many ado files, these dependency structures
    can become complex.
<p>
    <b>copycode</b> will figure out dependency structures if you supply it with an
    input file that lists, for each project, the direct dependencies.  This
    input file must have the following structure:
<p>
         - Each line must contain exactly two tokens.
         - The first token specifies the project.
         - The second token specifies the path and name to a file.
<p>
    An example of an input file is given in the Input file structure section.
    Once all dependencies have been determined, <b>copycode</b> copies all relevant
    code into <i>targetfile</i> which then does not depend on any other user-written
    files.  The targetfile must always be specified explicitly.  This is to
    prevent accidental overwriting of existing files.
<p>
    While copying, <b>copycode</b> takes so-called "copy regions" into account.  It
    copies only lines that you have marked to be copied.
<p>
<p>
<a name="backup"></a> <b><u>Backup of files</u></b>
<p>
    <b>copycode</b> concerns itself mainly with writing ado files to disk.  If you
    use or try out <b>copycode</b>, 1) make a backup of your self-written files and
    2) keep the backup in a safe place.  Otherwise there is the danger of
    accidentially overwriting and losing self-written code files.
<p>
<p>
<a name="modes"></a> <b><u>Simple mode and ado mode</u></b>
<p>
    <b>copycode</b> compiles file lists differently, depending whether it is run in
    simple mode or in ado mode.  Simple mode can be invoked e.g. by using
    option <b>simplemode</b>.  Then the files to be copied correspond exactly to the
    lines of the input file whose first-column entry equals <i>projectname</i>.
<p>
    In ado mode, <b>copycode</b> works differently.  Ado mode is related to the
    following problem:  When you write an ado file and your ado file depends
    on other ados you have written it becomes difficult to distribute your
    code - especially if you have many ados with many interdependencies.
<p>
    One solution is to use <b>copycode</b> to assemble the new ado file that
    contains the code of all ados that are necessary to make the new ado file
    run.  For example, if new.ado calls your user-written function
    existing.ado, you can (sort of) simply copy the code from existing.ado
    into new.ado, that way making it a modular routine.  Roughly speaking,
    this is the approach taken by <b>copycode</b>.  What you have to supply to the
    command is an input file that lists the direct dependencies of your (ado)
    projects.
<p>
    Ado mode is entered when the first file of a project is an adv file (see
    the next section on file extensions) whose file name is identical to the
    project name.  This file is then called the "main adv" of the project.
<p>
    Most of what follows is related to using <b>copycode</b> in ado mode.
<p>
<p>
<a name="fileextensions"></a> <b><u>File extensions</u></b>
<p>
    <b>copycode</b> handles the following file extensions in a special way:
<p>
           .adv      "ado development file", contains the newly written code
                     necessary for your new ado project.  In ado mode, when
                     encountering an adv file that is listed as a dependency in
                     the input file, <b>copycode</b> will search the input file for a
                     correspondingly named project.  This project must exist,
                     otherwise <b>copycode</b> will error out.  Any files listed under
                     this project (which may just consist of one adv file) are
                     included in the list of files to be copied and in turn
                     searched for further dependencies.
           .ado      Existing modular user-written ado files to be used as
                     subroutines (appended) to the new ado project
           .stp      "Stata program file", contains modular Stata code to be
                     appended to the code in the adv file.  stp files are
                     thought to contain short and simple Stata programs that do
                     not depend on other programs.  You may ignore stp file
                     types and put all of your Stata programs into adv files.
           .mata     Mata source code file, contains modular Mata code to be
                     appended to the code in the adv file
<p>
    These files contain Stata programs and Mata functions.  You should always
    name your files according to the names of the programs, e.g. sub1.stp
    should contain a Stata program called "sub1", and func2.mata should
    contain a Mata function called "func2".
<p>
    <b>copycode</b> will copy the code from the files indicated in your input file
    in the order given in the table above:  First it copies your new code
    from your new adv, then (possibly) codes from other adv files, then code
    from modular (i.e. non-dependent) ado files.  Then it copies code from
    stp files, then code from mata files, and finally code from files with
    any other extension.
<p>
    In ado mode, within each extension group, files are copied in the order
    of appearance in the input file.  In simple mode files are copied exactly
    in the order of appearance in the input file.
<p>
    <b>copycode</b> does not check for dependencies of stp files because they should
    only contain small programs that do not call other programs.  Checking
    for the depenencies among mata files would be desirable, but this has not
    yet been implemented.  To summarize, only adv files are checked for
    dependencies.
<p>
<p>
<a name="inputfile"></a> <b><u>Input file structure</u></b>
<p>
    <b>copycode</b> can detect complex dependency structures among user-written
    files.  What it needs as an input, and what you have to provide, is a
    file that lists all (ado) projects and their direct dependencies.  This
    is enough information to create a list of dependencies of all orders, for
    any project in the input file.
<p>
    Here is an example of such an input file:
<p>
           myinput.txt ------------------------------------
           //        Optional project A description goes here
           //        note that comments are allowed in the input file
           proj_a    c:\ado\personal\proj_a.adv
           proj_a    c:\ado\personal\proj_b.adv
           proj_a    c:\ado\personal\modular.ado
           proj_a    c:\ado\personal\sub1.stp
           proj_a    c:\ado\personal\sub2.stp
           proj_a    c:\ado\personal\func1.mata
           proj_a    c:\ado\personal\func2.mata
                     
           //        Optional project B description goes here
           proj_b    c:\ado\personal\proj_b.adv
           proj_b    c:\ado\personal\proj_c.adv
           proj_b    c:\ado\personal\func3.mata
           proj_b    c:\ado\personal\sub2.stp
           proj_b    c:\ado\personal\sub3.stp
           proj_b    c:\ado\personal\func2.mata
           proj_b    c:\ado\personal\remarks.txt
                     
           //        Optional project C description goes here
           proj_c    c:\ado\personal\proj_c.adv
           ------------------------------------------------
<p>
    The first column of your input file specifies the project name.  The
    second column specifies the path to the files whose code goes into the
    output file.
<p>
    Suppose you want to create a new ado file proj_a.ado that you want to
    generate using <b>copycode</b>, in ado mode.  Then you create a project
    "proj_a.ado" in your input file.  The first entry of that project
    references a file "proj_a.adv".  This is the "main adv" of proj_a and
    contains the main routine of the new ado file.  Then you add entries for
    all direct dependencies that occur in the code contained in proj_a.adv.
<p>
    Project names are not case-sensitive and may not contain blanks.  File
    paths may contain blanks but be sure to surround the entries by double
    quotes or compound double quotes in this case.  File names may not
    contain blanks.  File paths must be supplied as absolute paths (e.g.
    c:\ado\personal\mydir\myfile.adv).  Relative file paths (e.g.
    mydir\myfile.adv) are not allowed in the input file.  File paths may not
    exceed 244 characters.
<p>
    Tab characters on comment lines and in between input tokens are allowed
    and are interpreted as blanks.
<p>
    As can be seen from the above example, the input file may contain empty
    lines and comments.  Comments must be indicated by "//" which must be the
    first non-blank character sequence on a comment line.  Comments must be
    on a separate line, i.e. they may not occur on the same line as an input
    entry.
<p>
    When running <b>copycode</b> in ado mode, the above input file will produce ado
    files that contain code from the following files, in the order as given
    below:
<p>
           Project A 
                     proj_a.adv
                     proj_b.adv
                     proj_c.adv
                     modular.ado
                     sub1.stp
                     sub2.stp
                     sub3.stp
                     func1.mata
                     func2.mata
                     func3.mata
                     remarks.txt
                     
           Project B 
                     proj_b.adv
                     proj_c.adv
                     sub2.stp
                     sub3.stp
                     func3.mata
                     func2.mata
                     remarks.txt
                     
           Project C 
                     proj_c.adv
<p>
    When running <b>copycode</b> in simple mode, the output files will contain code
    from the file list recorded unter each project, in the same order:
<p>
           Project A 
                     proj_a.adv
                     proj_b.adv
                     modular.ado
                     sub1.stp
                     sub2.stp
                     func1.mata
                     func2.mata
                     
           Project B 
                     proj_b.adv
                     proj_c.adv
                     func3.mata
                     sub2.stp
                     sub3.stp
                     func2.mata
                     remarks.txt
                     
           Project C 
                     proj_c.adv
<p>
    The composition of the final ado files produced under ado mode is
    discussed in the next section.
<p>
<p>
<a name="dependencies"></a> <b><u>Code dependencies</u></b>
<p>
    From the above example, note the following:
         
         - The order of file types to be copied into the final ado file is: adv
           - ado - stp - mata - other.
         - Apart from the main adv, you do not have to stick to any particular
           order in which you specifiy project component files.  The only
           exception to this concerns Mata structures.  As you can see from
           func3.mata of project B above which is somewhat hidden, it makes
           things more transparent to keep the order adv-ado-stp-mata-other in
           the input file.
         - The main adv file of the project (the first project entry) will
           always be copied first.
         - All subroutines from adv dependencies are copied:  Files that are
           referenced by proj_b are copied into proj_a.ado since proj_a has
           proj_b.adv as dependency (sub3.stp and remarks.txt are used directly
           by proj_b only and not by proj_a).  proj_a.ado requires all of its
           calls to its private program proj_b to work; hence, all project
           component files for proj_b have to be present in proj_a.ado.
         - proj_c.adv is copied into the targetfile for proj_a because proj_a
           depends on proj_c.adv through proj_b.adv.  proj_c.adv is a
           second-order dependency of proj_a.
         - There is no duplicate copying of files: sub2.stp is copied only once
           into proj_a.ado, even though proj_a has proj_b.adv as dependency and
           both proj_a and proj_b require the usage of sub2.stp.
         - In proj_a, modular.ado is copied without any attempt to detect its
           dependencies, i.e. if you specify an ado file it is presumed to be
           modular.
         - If an adv file is specified as a project component file, a project
           with the same name must exist.  In the above example, when
           processing project A or project B, copycode sooner or later stumbles
           upon the reference proj_c.adv which it needs to resolve.  If it
           cannot determine whether proj_c.adv has dependencies (which is the
           case if project proj_c does not exist) it will error out.
<p>
    Circular references of adv files are not allowed: If proj_1.adv depends
    proj_2.adv, proj_2.adv must not depend on proj_1.adv.  If you try to
    process a project that has such a structure <b>copycode</b> will issue an error.
    To detect circular references, a maximum of 1000 direct or indirect adv
    dependencies (in total) is set.  You will necessarily hit this limit if
    your input file defines a circular reference.  Note that a circular
    reference error will also be issued if these circular dependencies are
    not on the top level of dependencies.  For example, consider the input
    file
<p>
           proj_1    c:\ado\personal\proj_1.adv
           proj_1    c:\ado\personal\proj_2.adv
           proj_2    c:\ado\personal\proj_2.adv
           proj_2    c:\ado\personal\proj_3.adv
           proj_3    c:\ado\personal\proj_3.adv
           proj_3    c:\ado\personal\proj_1.adv
<p>
    An error is issued because proj_1 depends on proj_2 which depends on
    proj_3 which in turn depends on proj_1, so the references have a circular
    structure.
<p>
<p>
<a name="copyregions"></a> <b><u>Copy regions</u></b>
<p>
    Before <b>copycode</b> starts copying the lines of a file, it searches the file
    for the strings '!copycodebeg=&gt;' and '!copycodeend||'.  Then it only
    copies the lines in between the two strings (excluding the lines
    containing these strings) to <i>targetfile</i>.  Henceforth, the two strings are
    called "copy region limits" and the lines between the limits are called a
    "copy region".  A file may contain multiple copy regions.  Copy region
    limits must be present in each file, occur in the correct order, and
    reside on different lines.  Otherwise an error is issued.  You can
    prevent the error from being issued by using option <b>force</b>.  In this case
    the entire contents of the files are copied, except for starbang lines.
    What happens to starbang lines is determined by option <b>starbang</b>.  The
    usage or omission of option <b>force</b> applies to all files in the project
    listing.
<p>
    The purpose of copy regions is that you can keep comments and auxiliary
    commands/functions in the original files and still have a clean composite
    file.
<p>
<p>
<a name="fileloss"></a> <b><u>Avoiding file loss</u></b>
<p>
    The output files that you want to create with <b>copycode</b> normally are ado
    files.  This means that the ado files that you are creating are fully
    overwritten whenever you make changes to component files and re-process a
    project.  Even if you proceed carefully, it may happen that you
    accidentially overwrite code that you have newly written.
<p>
    In particular, this may happen if some of your ado files have a complex
    dependency structure so you create these ado files using <b>copycode</b>, but
    other ado files are very simple, do not have dependencies and are outside
    of the <b>copycode</b> system, i.e. written in the usual way.  Then you may get
    into the habit of sometimes modifying adv files (to modify ado files
    created by <b>copycode</b>), and sometimes ado files (to directly modify the
    small and simple ado files).  You can then easily by accident change the
    ado file of one of the complex ado projects.  The next time you
    re-process this project, this ado file will get overwritten and your work
    will be lost.
<p>
    One save solution is to <b>make it a rule to never ever edit ado files</b>.
    Include all of your files in the <b>copycode</b> system, even the small and
    simple ones that do not have dependencies.  This means giving the simple
    ado files an adv extension, adding one project line per adv file to the
    <b>copycode</b> input file, and producing the ado file using <b>copycode</b>.  This may
    sound complicated but it is usually a change that can be implemented very
    quickly.  Once you have done so, you should have a look at fastcc to make
    working with <b>copycode</b> more efficient.
<p>
<p>
<a name="downsides"></a> <b><u>Downsides</u></b>
<p>
    While <b>copycode</b> makes your life as a developer easier by reducing the
    amount of code that needs to be written and maintained, its major
    disadvantage is that it produces code bloat <b>for the user</b> of your ado
    routines.  Including the code of general purpose functions or even
    full-blown ado routines in a new ado file means that larger parts of the
    code are probably not necessary to make the new ado work.  If a user of
    your ados wants to look at your code, it may take longer to read through
    it.
<p>
    You may alleviate this problem by including a comment at the top of each
    adv file, e.g.
<p>
        // Some portions of the code for subroutines may not be necessary for
        the
        // functionality of this ado file since it has been produced with
        -copycode-.
        // More information is available on SSC: type -ssc help copycode-
        // A separate help file for the program below may be available on
        SSC.
<p>
    If the adv code is used as a subroutine, the user may be able to just
    read through the help file if it is available, instead of having to work
    through the code itself.
<p>
    Another downside is the limited ability to format the target file.  Last
    but not least, it takes a little while to understand how the command
    works (as you may have noticed).
<p>
<p>
<a name="nocopy"></a> <b><u>The 'nocopy' option</u></b>
<p>
    If you do not want to use <b>copycode</b> to generate your self-written final
    ado files, you can still put it to use to shed light on the dependency
    structure of your code files.
<p>
    You still have to create an input file like the one above that matches
    the direct dependencies of the projects that you have written.  The
    screen output of <b>copycode</b> and the results saved in <b>r()</b> will then tell you
    the details about the full dependency structure of your projects.
<p>
    Be sure to give your self-written ado file dependencies in your input
    file an adv extension.  These files may actually exist as ado files (not
    as adv files) on your hard drive.  You must still give them an adv
    extension in the input file, because only then will <b>copycode</b> check for
    their dependencies.
<p>
    Use option 'nocopy' then.  Then you do not have to create a bogus target
    file.  Also, <b>copycode</b> concerns itself only with the dependency structure
    that it can glean from the input file and does not check for the
    existence of files and the consistency of copy region limits within the
    code files.
<p>
<p>
<a name="misc"></a> <b><u>Miscellaneous remarks</u></b>
<p>
    <b>Relationship of ado mode / simple mode, option </b><b>force</b><b>, and option</b>
    <b>starbang</b>.  Running <b>copycode</b> in ado mode / simple mode, using option <b>force</b>
    and using option <b>starbang</b> are in principle three different things
    independent of each other.
<p>
         - Choosing ado mode / simple mode determines whether higher-order
           dependencies of a project should be copied.
         - Option <b>force</b> says that copy operations should not be confined to
           copy regions.
         - Option <b>starbang</b> determines whether starbang lines should be included
           in the copy operations.
<p>
    The only link between the above three features is that in ado mode
    <i>stb_mode</i> of option <b>starbang</b> defaults to "first".  In simple mode, it
    defaults to "all".
<p>
    <b>Potential function name clashes</b>.  There is a potential naming conflict
    between private subroutines that exist in adv/ado files referenced in the
    input file and other programs that you are refering to in the input file.
    As an example, consider the input file
<p>
           ------------------------------------------------
           proj_a    c:\ado\personal\proj_a.adv
           proj_a    c:\ado\personal\modular.ado
           proj_a    c:\ado\personal\sub1.stp
           ------------------------------------------------
<p>
    If modular.ado has a private subroutine (program) called "sub1" the
    output file produced by <b>copycode</b> will have two programs named "sub1" and
    Stata will refuse to load the ado.  One way to remedy this is to adopt
    appropriate naming conventions, e.g. give subroutines within adv/ado
    files prefixes according to the adv/ado file name, etc.
<p>
    It is perfectly fine to have subroutines in your main adv or any other
    adv/ado file.  If you have a special purpose program/function whose only
    application is within one particular adv/ado file, the only issue of
    adding this function to the adv/ado (project component) file is to pay
    attention to potential naming conflicts.  Make sure to keep these
    program/functions within copy regions so they will always be copied to
    the output file.
<p>
    If you have a subroutine that turns out to be useful in other contexts as
    well it is beneficial to include this program in a separate adv or stp
    file, and add corresponding stp entries to projects that make use of the
    subroutine.
<p>
    <b>Debugging and certification scripts.</b>  Each of the files that go into the
    final ado can be loaded separately into Stata for debugging purposes.  If
    you have a look at func1.mata used in the examples section, you can see
    that the code file func1.mata is used in the copycode system but can be
    loaded separately into memory:
<p>
        <b>. do func1.mata</b>
<p>
    will define func1() as a Mata function.  This works because the actual
    code that gets copied by <b>copycode</b> is confined to copy region limits.
<p>
    You can even push it further and use the file func1.mata as a
    certification script by adding initialization statements at the top of
    the file (see cscript) and add certification assert and confirm
    statements at the bottom of the file.  You will still be able to use this
    file within the <b>copycode</b> context since, by default, <b>copycode</b> only copies
    the code that is located within copy region limits.  If all
    certification-related lines are located outside of copy regions, you can
    use func1.mata as both a source code file for the <b>copycode</b> system and as
    a certification script.  The same holds true for adv and for stp files.
<p>
    <b>Using code from other users.</b>  If your project depends on an ado file
    written by some other user, you can include this ado file in your
    <b>copycode</b> project as a dependency in order to make your project modular.
    Your final ado file will then contain the code from the "third-party"
    user-written ado file.  It goes without saying that in these cases you
    should ask for permission first and give proper acknowledgements in your
    help files when you distribute your code.
<p>
    <b>Version statements.</b>  Another potential conflict concerns version
    statements.  If you plan to build a new ado, say under "version 11", and
    accidentially include a program via <b>copycode</b> that has a "version 12"
    statement, the ado file will not execute under Stata 11.  A cursory look
    at the (top of the) ado code, however, would (misleadingly) suggest that.
    You must manually check for appropriate version control statements in
    your output ado files.
<p>
    <b>Exit statements.</b>  If you routinely include "exit" statements at the end
    of your main adv definition programs (after the closing "end" statement),
    make sure to exclude them from the copy region so they do not show up in
    the new composite ado file.  Otherwise it will not work.
<p>
<a name="matastructures"></a>    <b>Mata structures.</b>  In ado mode, within each file extension group, the
    order of files copied is the order of appearance in the input file.  This
    is important if you use Mata structures.  In the Mata code, structures
    have to be defined before they can be used in subsequent code.  If you
    use Mata structure definitions in separate files, it is the safest
    strategy to put these files right underneath the main adv file of your
    project.
<p>
    <b>Other uses.</b>  You may discover other uses of <b>copycode</b>, especially using
    option <b>simplemode</b>.  For example, you can use it to produce nice
    estimation output reports.  First, generate various smcl log files with
    estimation output and manually write other smcl files that comment on the
    output.  You can then use <b>copycode</b> to copy the smcl files into one file
    in any order desired, that way producing a nice and clean report.
<p>
    <b>Reverting to non-modular ado files.</b> All you have to do is to create a
    copy of your input file and comment out all adv files of a project except
    for the main adv.  Using the two input files you can very easily switch
    between creating modular ado files and non-modular ado files.
<p>
    <b>Using do-files.</b> If you have many ado files, you probably want to have a
    "master" do file that processes all of your projects.  For the input file
    used above, this do file could read
<p>
           copycode_runall.do:
             --------------------------------------------------------
             // FILE PURPOSE: GENERATE ALL SELF-WRITTEN ADO FILES
             copycode proj_a, inp(c:\ipath\myinput.txt)
             target(c:\tpath\proj_a.ado) replace
             copycode proj_b, inp(c:\ipath\myinput.txt)
             target(c:\tpath\proj_b.ado) replace
             copycode proj_c, inp(c:\ipath\myinput.txt)
             target(c:\tpath\proj_c.ado) replace
           --------------------------------------------------------------------
             &gt; --------
<p>
<p>
    <b>Operating system</b>.  While <b>copycode</b> can be used on any operating system
    that Stata runs on, it has only been tested on Windows.
<p>
<p>
<a name="examples"></a> <b><u>Examples</u></b>
<p>
    Consider the following input file
<p>
           input.txt: -------------------------------------
           //        Files for project A
           proj_a    c:\ado\personal\proj_a.adv
           proj_a    c:\ado\personal\sub1.stp
           proj_a    c:\ado\personal\func1.mata
           //        Files for project B
           proj_b    c:\ado\personal\proj_b.adv
           proj_b    c:\ado\personal\proj_a.adv
           proj_b    c:\ado\personal\sub1.stp
           proj_b    c:\ado\personal\func2.mata
           ------------------------------------------------
<p>
<a name="example_a"></a> 
    The files that go into the final ado could look like this:
<p>
           proj_a.adv: ------------------------------------
                     // !copycodebeg=&gt;
                     *! version 1.0.1 12jun2011 dcs
                     program define proj_a
                      display "hello world says proj_a"
                      proj_a_sub1
                      sub1
                      /* !copycodeend||
                      TODO: improve sub1
                      by switching to...
                      <i>(...)</i>
                      !copycodebeg=&gt; */
                      mata: func1()
                     end
                     
                     program define proj_a_sub1
                      <i>(...)</i>
                     end
                     
                     // !copycodeend||
                     
                     /*
                     TODO:
                     - make the routine do something useful
                     - <i>(...)</i>
                     
                     VERSION HISTORY
                     0.0.1 12apr 2011 <i>(...)</i>
                     */
           ------------------------------------------------
<p>
<p>
           sub1.stp: ------------------------------------
                     capture program drop sub1
                     // !copycodebeg=&gt;
                     program define sub1
                      <i>(...)</i>
                     end
                     
                     // !copycodeend||
                     
                     /*
                     TODO
                      <i>(...)</i>
                     */
           ------------------------------------------------
<p>
<p>
           func1.mata: ------------------------------------
                     capture mata mata drop func1()
                     // !copycodebeg=&gt;
                     mata:
                     void func1() {
                      <i>(...)</i>
                     }
                     end
                     
                     // !copycodeend||
                     
                     /*
                     TODO
                      <i>(...)</i>
                     */
           ------------------------------------------------
<p>
    The statement
<p>
        <b>. copycode proj_a, inputfile(c:\mypath\input.txt)</b>
        <b>targetfile(c:\mytargetdir\proj_a.ado)</b>
<p>
    would produce c:\mytargetdir\proj_a.ado which reads:
<p>
           proj_a.ado: ------------------------------------
                     *! version 1.0.1 12jun2011 dcs
                     program define proj_a
                      display "hello world says proj_a"
                      proj_a_sub1
                      sub1
                      mata: func1()
                     end
                     
                     program define proj_a_sub1
                      <i>(...)</i>
                     end
                     
                     program define sub1
                      <i>(...)</i>
                     end
                     
                     mata:
                     void func1() {
                      <i>(...)</i>
                     }
                     end
           ------------------------------------------------
<p>
    From the above example, note the following:
         
         - <b>copycode</b> found the first file of proj_a to be an adv file whose name
           is identical to the project.  It therefore entered ado mode.
           However, since there are no other adv files specified, there are no
           dependencies to detect.
         - By default, <b>copycode</b> copies only copy regions.  The private comments
           in the source code files do not show up in the output file.
         - In ado mode, the <b>starbang(</b><i>stb_mode</i><b>)</b> option defaults to "first",
           which means that the starbang lines from the main adv file are
           copied to the output file.
         - The main adv file contains a subroutine.  Prepending the name of the
           subroutine by the name of the adv file ("proj_a_sub1") prevented a
           function name clash.
<p>
<a name="example_b"></a> 
    If, in addition, we assume the following files:
<p>
           proj_b.adv: ------------------------------------
                     // !copycodebeg=&gt;
                     *! version 1.2.0 30dec2011 dcs
                     program define proj_b
                      display "hello world again"
                      proj_a
                      sub1
                      mata: func2()
                     end
                     
                     // !copycodeend||
                     
                     /*
                     TODO:
                     - <i>(...)</i>
                     
                     VERSION HISTORY
                     - <i>(...)</i>
                     */
           ------------------------------------------------
<p>
<p>
           func2.mata: ------------------------------------
                     capture mata mata drop func2()
                     // !copycodebeg=&gt;
                     mata:
                     void func2() {
                      <i>(...)</i>
                     }
                     end
                     
                     // !copycodeend||
                     
                     /*
                     TODO
                      <i>(...)</i>
                     */
           ------------------------------------------------
<p>
<p>
    The statement
<p>
        <b>. copycode proj_b, inputfile(c:\mypath\input.txt)</b>
        <b>targetfile(c:\mytargetdir\proj_b.ado)</b>
<p>
    would produce c:\mytargetdir\proj_b.ado which reads:
<p>
           proj_b.ado: ------------------------------------
                     *! version 1.2.0 30dec2011 dcs
                     program define proj_b
                      display "hello world again"
                      proj_a
                      sub1
                      mata: func2()
                     end
                     
                     program define proj_a
                      display "hello world says proj_a"
                      proj_a_sub1
                      sub1
                      mata: func1()
                     end
                     
                     program define proj_a_sub1
                      <i>(...)</i>
                     end
                     
                     program define sub1
                      <i>(...)</i>
                     end
                     
                     mata:
                     void func2() {
                      <i>(...)</i>
                     }
                     end
                     
                     mata:
                     void func1() {
                      <i>(...)</i>
                     }
                     end
           ------------------------------------------------
<p>
    From the above example, note the following:
         
         - <b>copycode</b> found the first file of proj_b to be an adv file whose name
           is identical to the project.  It therefore entered ado mode.  It
           found proj_a as an adv input to proj_b and checked for a proj_a
           project entry in the input file.  It included the files found there
           in the output file.
         - If proj_a would have had a component file proj_c.adv, <b>copycode</b> would
           have included the component files from proj_c as well, and so forth.
         - Again, in ado mode, option <b>starbang(</b><i>stb_mode</i><b>)</b> option defaults to
           "first", which means that the starbang lines from the main adv file
           are copied to the output file.  The starbang lines from proj_a have
           not been copied.
<p>
<p>
<a name="savedresults"></a> <b><u>Saved results</u></b>
<p>
    <b>copycode</b> saves the following in <b>r()</b>:
<p>
    Macros         
      <b>r(project)</b>          Name of project that has been processed
                          
                          in simple mode, the following is also saved:
      <b>r(dep_direct)</b>       File names of direct dependencies of the project
      <b>r(dep_direct_path)</b>  Full file paths of the direct dependencies
                          
                          in ado mode, the following is also saved:
      <b>r(dep_all)</b>          File names of all dependencies of the project
      <b>r(dep_adv)</b>          File names of adv dependencies
      <b>r(dep_ado)</b>          File names of ado dependencies
      <b>r(dep_stp)</b>          File names of stp dependencies
      <b>r(dep_mata)</b>         File names of mata dependencies
      <b>r(dep_other)</b>        File names of other dependencies
      <b>r(dep_all_path)</b>     Full file paths corresponding to r(dep_all)
      <b>r(dep_adv_path)</b>     Full file paths corresponding to r(dep_adv)
      <b>r(dep_ado_path)</b>     Full file paths corresponding to r(dep_ado)
      <b>r(dep_stp_path)</b>     Full file paths corresponding to r(dep_stp)
      <b>r(dep_mata_path)</b>    Full file paths corresponding to r(dep_mata)
      <b>r(dep_other_path)</b>   Full file paths corresponding to r(dep_other)
<p>
    All returned values are lower case, irrespective of what the actual
    casing of the files on disk or in the input file is.
<p>
<b><u>Author</u></b>
<p>
    Daniel C. Schneider, Goethe University Frankfurt,
        schneider_daniel@hotmail.com
<p>
<p>
<a name="acknowledgements"></a><b><u>Acknowledgements</u></b>
<p>
    I thank Kevin Crow from StataCorp and the participants of the German
    Stata Users Group Meeting 2012 for helpful comments.
<p>
<p>
<a name="references"></a><b><u>References</u></b>
<p>
    Schneider, D.C. (2012).  Modular Programming in Stata.  Presentation at
        the German Stata Users Group Meeting 2012, Berlin.  Available at
        http://www.stata.com/meeting/germany12/abstracts/desug12_schneider.pd
        &gt; f.
<p>
<p>
<a name="alsosee"></a><b><u>Also see</u></b>
<p>
    Online:  <b>[R] net</b>
<p>
    User-written, if installed:
<p>
    <b>adolist</b>        -help- -install- -remote help-
</pre>