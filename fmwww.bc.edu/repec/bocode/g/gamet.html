<pre>
-------------------------------------------------------------------------------
help for <b>gamet</b>
-------------------------------------------------------------------------------
<p>
<b><u>Game-theoretic calculations</u></b>
<p>
    <b>gamet</b> <b>,</b> <b><u>pay</u></b><b>off(</b><i>#U111</i><b>,</b><i>#U211</i><b>,</b> ... <b>,</b><i>#U11_c</i><b>,</b><i>#U21_c</i> ... <b>,</b><i>#U11_C</i><b>,</b><i>#U21_C</i>
              <b>\</b> ... <b>\</b>
                   <i>#U1_r1</i><b>,</b><i>#U2_r1</i><b>,</b> ... <b>,</b><i>#U1_r_c</i><b>,</b><i>#U2_r_c</i> ... <b>,</b><i>#U1_r_C</i><b>,</b><i>#U2_r_C</i> <b>\</b>
                 ... <b>\</b>
                   <i>#U1_R1</i><b>,</b><i>#U2_R1</i><b>,</b> ... <b>,</b><i>#U1_R_c</i><b>,</b><i>#U2_R_c</i> ... <b>,</b><i>#U1_R_C</i><b>,</b><i>#U2_R_C</i><b>)</b>
<p>
                 [ <b>ls1(</b><i>lab_s1</i><b>)</b> <b>ls2(</b><i>lab_s2</i><b>)</b>
                 <b>player1(</b><i>rlab1 ... rlab_r ... rlab_R</i><b>)</b>
                 <b>player2(</b><i>clab1 ... clab_c ... clab_C</i><b>)</b>
<p>
                 <b>domist</b> <b>elids</b> <b>neps</b> <b>nefms</b> <b>maximin</b> <b>gtree</b>
<p>
                 <b>npath</b> <b>aspect(</b><i>#</i><b>)</b> <b>mlabpls(</b><i>clockpos</i><b>)</b> <b>mlabppm(</b><i>clockpos</i><b>)</b>
                 <b>mlabpp1(</b><i>clockpos</i><b>)</b> <b>mlabpp2(</b><i>clockpos</i><b>)</b> <b>savingpf(</b><i>filename</i><b>)</b>
                 <b>textpp(</b><i>textsizestyle</i><b>)</b> <b>texts(</b><i>textsizestyle</i><b>)</b>
                 <b>msizepp(</b><i>relativesize</i><b>)</b> <b>msizes(</b><i>relativesize</i><b>)</b>
<p>
                 <i>scatter_options</i> ]
<p>
<b><u>Description</u></b>
<p>
    <b>gamet</b> represents the extensive form (game tree) and the strategic
          form (payoff matrix) of a non-cooperative game and
          identifies the solution of a non-zero and zero-sum game
          through: dominant and dominated strategies, iterated
          elimination of strictly dominated strategies, Nash
          equilibrium in pure and fully mixed strategies. Further,
          <b>gamet</b> is able to identify the solution of a zero-sum game
          through maximin criterion and the solution of extensive
          form through backward induction.
<p>
<b><u>Payoff matrix</u></b>
<p>
    ---------------------------------------------------------------------------
-----------
              |                                      <i>lab_s2</i>
       <i>lab_s1</i> |      <i>clab1</i>         ...         <i>clab_c</i>         ...          <i>clab</i>
<i>&gt; _C</i>
    ----------+----------------------------------------------------------------
-----------
        <i>rlab1</i> | (<i>#U111</i>; <i>#U211</i>)     ...   (<i>#U11_c</i>; <i>#U21_c</i>)     ...    (<i>#U11_C</i>; <i>#</i>
<i>&gt; U21_C</i>)
          ... |      ...           ...          ...           ...            ..
&gt; .
       <i>rlab_r</i> | (<i>#U1_r1</i>; <i>#U2_r1</i>)   ...   (<i>#U1_r_c</i>; <i>#U2_r_c</i>)   ...    (<i>#U1_r_C</i>; 
<i>&gt; #U2_r_C</i>)
          ... |      ...           ...          ...           ...            ..
&gt; .
       <i>rlab_R</i> | (<i>#U1_R1</i>; <i>#U2_R1</i>)   ...   (<i>#U1_R_C</i>; <i>#U2_R_C</i>)   ...    (<i>#U1_R_C</i>; 
<i>&gt; #U2_R_C</i>)
    ---------------------------------------------------------------------------
-----------
<p>
    <b><u>pay</u></b><b>off(</b>...<b>)</b> is not optional and provides a way to input, row after row, a
        general <i>R</i> by <i>C</i> payoff matrix (help matrix input), where
<p>
    <i>#U1_r_c</i> is the payoff for <i>lab_s1</i> if <i>lab_s1</i> chooses strategy <i>r</i> and <i>lab_s2</i>
        chooses strategy <i>c</i>
    <i>#U2_r_c</i> is the payoff for <i>lab_s2</i> if <i>lab_s1</i> chooses strategy <i>r</i> and <i>lab_s2</i>
        chooses strategy <i>c</i>
<p>
    with <i>r</i> = 1,2, ..., <i>R</i> and <i>c</i> = 1,2, ..., <i>C</i>
<p>
<b><u>Remark</u></b>
<p>
    <b>gamet</b> is an immediate command given that obtains data not from
          the data stored in memory but from numbers typed as
          arguments (help immed).
<p>
<b><u>Options</u></b>
<p>
    <b>ls1(</b><i>lab_s1</i><b>)</b> attaches a label to the set of strategies for player 1. The
        default is S1.
<p>
    <b>ls2(</b><i>lab_s2</i><b>)</b> attaches a label to the set of strategies for player 2. The
        default is S2.
<p>
    <b>player1(</b><i>rlab1 rlab2 ... rlab_r ... rlab_R</i><b>)</b> attaches a label for each
        strategy of player 1.  The default is A1, B2, C3 and so on.
<p>
    <b>player2(</b><i>clab1 clab2 ... clab_c ... clab_C</i><b>)</b> attaches a label for each
        strategy of player 2.  The default is a1, b2, c3 and so on.
<p>
    <b>domist</b> seeks strictly dominated and dominant strategies for each player.
    
    <b>elids</b> eliminates iteratively all strictly dominated strategies for each
        player.
<p>
    <b>neps</b> seeks Nash equilibrium in pure strategies.
<p>
    <b>nefms</b> seeks Nash equilibrium in fully mixed strategies (0&lt;p&lt;1 and 0&lt;q&lt;1).
        It works only if <i>R</i> and <i>C</i> are equal to 2.
<p>
    <b>maximin</b> seeks the saddle-point through the minimal column maximum for
        player 1 and maximal row minimum for player 2.  It works for zero-sum
        games. That is, <i>#U1_r_c</i> + <i>#U2_r_c</i> == 0.
<p>
    <b>gtree</b> seeks the equilibrium path through backward induction (player 1
        moves first).  It produces a graphical representation of a sequential
        game, called game tree.
<p>
    <b>savingpf(</b><i>filename</i><b>)</b> saves the variables obtained by the conversion of the
        payoff matrix in a file. If the option <b>elids</b> is specified <b>savingpf()</b>
        saves one file(<i>filename#</i>) for each iteration.
<p>
    <b>npath</b> specifies no equilibrium path on the game tree.
<p>
    <b>aspect(</b><i>#</i><b>)</b> modifies the aspect ratio (height/widht) of the plot region. By
        default is set to 1 (equal height and width) so the plot region is a
        square. See  graph_display.
<p>
    <b>mlabpls(</b><i>clockpos</i><b>)</b> specifies the position for label <i>lab_s1</i> and <i>lab_s2</i> on
        the game tree. Use clockpos to make changes from the default (9).
<p>
    <b>mlabppm(</b><i>clockpos</i><b>)</b> specifies the position for <i>#U1_r_c</i>, <i>#U2_r_c</i> on the game
        tree. Use clockpos to make changes from the default (3).
<p>
    <b>mlabpp1(</b><i>clockpos</i><b>)</b> specifies the position for strategies' labels on the
        game tree for player 1. Use clockpos to make changes from the default
        (12).
<p>
    <b>mlabpp2(</b><i>clockpos</i><b>)</b> specifies the position for strategies' labels on the
        game tree for player 2. Use clockpos to make changes from the default
        (9).
<p>
    <b>textpp(</b><i>textsizestyle</i><b>)</b> specifies the text size style for <i>lab_s1</i>, <i>lab_s2</i>
        and (<i>#U1_r_c</i>; <i>#U2_r_c</i>). Use textsizestyle to make changes from the
        default (<i>medium</i>).
<p>
    <b>texts(</b><i>textsizestyle</i><b>)</b> specifies the text size style for strategies'
        labels. Use textsizestyle to make changes from the default (<i>small</i>).
<p>
    <b>msizepp(</b><i>relativesize</i><b>)</b> choices for sizes for objects <i>lab_s1</i>, <i>lab_s2</i> and
        (<i>#U1_r_c</i>; <i>#U2_r_c</i>).  Use relativesize to make changes from the
        default (2).
<p>
    <b>msizes(</b><i>relativesize</i><b>)</b> choices for sizes for strategies' labels. Use
        relativesize to make changes from the default (2).
<p>
    <i>scatter_options</i> are options of scatter.
<p>
<b><u>Examples</u></b>
<p>
     <b>. gamet, payoff(2, 2, 0, 1 \ 3, 0 , 1, 1) player1(High Low) player2(Buy No</b>
<b>&gt; t_buy) ///</b>
     <b>           ls1(Provider) ls2(Customer) domist</b>
<p>
     <b>. gamet, pay(3, 0, 0 , 2 , 0, 3\2, 0 , 1, 1 , 2, 0 \ 0, 3 , 0 , 2, 3, 0 ) </b>
<b>&gt; ///   </b>
     <b>          ls1(C1) ls2(C2) player1(x1 y1 z1)  player2(x2 y2 z2) elids</b>
<p>
     <b>. gamet, payoff(0,0,12,8,18,9,36,0\ 8,12,16,16,20,15,32,0\9,18,15,20,18,18</b>
<b>&gt; ,27,0\0,36,0,32,0,27,0,0)///</b>
     <b>          player1(H M L N) player2(h m l n) ls1(Firm_I) ls2(Firm_II) elids</b>
<b>&gt;  </b>
<p>
     <b>. gamet, payoff(3, 1, 0, 0\0, 0, 1, 3) player1(Football Ballet) player2(Fo</b>
<b>&gt; otball Ballet) /// </b>
     <b>           ls1(Boy) ls2(Girl) neps</b>
<p>
     <b>. gamet, pay(0, 0, -10, 10 \ -1, 0, -6, -90) player1(Not_inspect Inspect) </b>
<b>&gt; ///</b>
     <b>            player2(Comply Cheat) ls1(I) ls2(II) nefms </b>
<p>
     <b>. gamet, payoff(2, 2, 0, 1 \ 3, 0 , 1, 1) player1(High Low) ///  </b>
     <b>               player2(Buy Not_buy) ls1(I) ls2(II) gtree</b>
<p>
     <b>. gamet, payoff(0,0,12,8,18,9,36,0\ 8,12,16,16,20,15,32,0\9,18,15,20,18,18</b>
<b>&gt; ,27,0\0,36,0,32,0,27,0,0)///</b>
     <b>          player1(H M L N) player2(h m l n) ls1(Firm_I) ls2(Firm_II) gtree</b>
<p>
     <b>. gamet, payoff(-5,5,3,-3,1,-1,20,-20\5,-5,5,-5,4,-4,6,-6\-4,4,6,-6,0,0,-5</b>
<b>&gt; ,5) /// </b>
     <b>               player1(1 2 3) player2(1 2) maximin </b>
<p>
<b><u>Authors</u></b>
<p>
    Nicola Orsini, Institute of Environmental Medicine, Karolinska
                   Institutet, Stockholm, Sweden.
    Debora Rizzuto, Department of Public Health, University of Siena, Italy.
    Nicola Nante, Department of Public Health, University of Siena, Italy.
<p>
<b><u>Reference</u></b>
<p>
    Myerson, R. B. 1991. <i>Game Theory: Analysis of Conflict</i>, Harvard
    University Press, Cambridge (MA).
<p>
<b><u>Support</u></b>
<p>
    http://nicolaorsini.altervista.org
    nicola.orsini@imm.ki.se
<p>
<b><u>Also see</u></b>
<p>
On-line:  help for matrix, _variables, tabdisp, macrolists
<p>
</pre>