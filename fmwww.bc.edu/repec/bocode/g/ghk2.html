<pre>
<b>help ghk2()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>ghk2()</b> -- Geweke-Hajivassiliou-Keane (GHK) multivariate normal simulator
                       using pre-generated points
<p>
<p>
<b><u>Syntax</u></b>
<p>
                   <i>P</i> <b>=</b> <b>ghk2setup(</b><i>real scalar n</i><b>, </b><i>real scalar m</i><b>, </b><i>real scalar d</i><b>,</b>
                         <i>string scalar type</i><b>,</b>
                         <b>| </b><i>real scalar pi</i><b>, </b><i>pointer (real colvector function)</i>
                         <i>pfn</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2(</b><i>P</i><b>, </b><i>real matrix X</i><b>, </b><i>real matrix V</i><b>, </b><i>real scalar</i>
                         <i>anti</i><b>, </b><i>real scalar start</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2(</b><i>P</i><b>, </b><i>real matrix Xl</i><b>, </b><i>real matrix Xu</i><b>, </b><i>real matrix V</i><b>,</b>
                         <i>real scalar anti</i><b>, </b><i>real scalar start</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2(</b><i>P</i><b>, </b><i>real matrix X</i><b>, </b><i>real matrix V</i><b>, </b><i>real scalar</i>
                         <i>anti</i><b>, </b><i>real scalar start</i><b>,</b> <i>real matrix dfdx</i><b>, </b><i>real</i>
                         <i>matrix dfdv</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2(</b><i>P</i><b>, </b><i>real matrix Xl</i><b>, </b><i>real matrix Xu</i><b>, </b><i>real matrix V</i><b>,</b>
                         <i>real scalar anti</i><b>, </b><i>real scalar start</i><b>,</b> <i>real matrix</i>
                         <i>dfdxl</i><b>, </b><i>real matrix dfdxu</i><b>, </b><i>real matrix dfdv</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2SqrtScrambler(</b><i>real scalar p</i><b>)</b>
<p>
        <i>real colvector </i><b>ghk2NegSqrtScrambler(</b><i>real scalar p</i><b>)</b>
<p>
    where <i>P</i>, if it is declared, should be declared
<p>
                <b>transmorphic</b> <i>P</i>
                
    where <i>pfn</i>, if it is passed, should point to a Mata function declared like
    ghk2SqrtScrambler() or ghk2NegSqrtScrambler(),
<p>
    and where <i>dfdx</i>, <i>dfdxl</i>, <i>dfdxu</i>, and <i>dfdv</i> are outputs
<p>
                <i>real matrix dfdx</i>
                <i>real matrix dfdxl</i>
                <i>real matrix dfdxu</i>
                <i>real matrix dfdv</i>
 
<p>
<b><u>Input parameters</u></b>
<p>
        <i>n</i>            Number of observations for which to prepare draws
        <i>m</i>            Draws per observation and simulated dimension
        <i>d</i>            Dimension of cumulative integrals for which to be
        prepared to simulate
        <i>type</i>         Sequence type
        <i>pi</i>           Optional starting index of prime bases for Halton
        sequences (1-&gt;2, 2-&gt;3, 3-&gt;5, 4-&gt;7...) (default=1)
        <i>pfn</i>          Optional pointer to scrambling function such as
        ghk2SqrtScrambler() or ghk2NegSqrtScrambler()
        <i>P</i>            Draws prepared by <b>ghk2setup()</b>
        <i>X</i>            Upper bounds of integration
        <i>Xl, Xu</i>       Lower and upper bounds of integration
        <i>V</i>            Covariance matrix
        <i>anti</i>         Optional dummy for inclusion of antithetics (default=0)
        <i>start</i>        Starting point to use in block of draws prepared by
        <b>ghk2setup()</b>
        <i>p</i>            Number, normally prime, for which the vector (0, 1, ...,
        p-1)' should be scrambled
                
<b><u>Output parameters</u></b>
<p>
        <i>dfdx</i>         Scores with respect to <i>X</i>
        <i>dfdxl, dfdxu</i> Scores with respect to <i>Xl, Xu</i>
        <i>dfdv</i>         Scores with respect to <i>V</i>, stored as vectorized
        lower-triangular matrices
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>ghk2()</b> implements the Geweke-Hajivassiliou-Keane algorithm for simulating
    the cumulative multivariate normal distribution, optionally computing
    scores, and optionally accepting lower as well as upper bounds. (See
    Cappellari and Jenkins 2003, 2005; Gates 2006.) It is modeled on
    ghkfast(), which is included in Stata 10, and which see for more
    explanation. Like <b>ghkfast()</b>, its first argument is a pre-generated set of
    points on the unit interval, in this case produced by <b>ghk2setup()</b>, which
    has the same syntax and semantics as ghkfastsetup(). The two commands'
    point sets are not interchangeable. <b>ghk2()</b> differs from ghkfast() in the
    following ways:
<p>
      * It accepts lower as well as upper bounds for integration (second and
        fourth syntaxes above). This allows efficient estimation of
        probabilities over bounded rectilinear regions such as {(x1, x2) |
        l1&lt;=x1&lt;=u1, l2&lt;=x2&lt;=u2}. Without this feature, the routine would need
        to be called 2^d times, where d is the dimension of distribution. For
        example, the probability just mentioned would have to be computed as
        Phi(u1, u2) - Phi(l1, u2) - Phi(u1, l2) + Phi(l1, l2), where Phi is a
        bivariate cumulative normal distribution with some given covariance
        structure. Individual entries in the lower and upper bounds, <i>Xl</i> and
        <i>Xu</i>, may be missing ("."), and are interpreted as -infinity and
        +infinity, respectively. The fourth syntax differs from the second in
        requesting score matrices for upper and lower bounds, as well as for
        the covariance matrix <i>V</i>.
<p>
      * <b>ghk2()</b> does not "pivot" the bounds of integration (in <i>X</i>, <i>Xl</i>, or <i>Xu</i>).
        On the recommendation of Genz (1992), ghk() and ghkfast() reorder
        each vector of bounds to put the larger entries toward the end, which
        reduces the variability of the simulated probability. However,
        pivoting has the disadvantage of creating discontinuities in results.
        Small changes in the bounds can produce relatively large ones in the
        results when they trigger reorderings of the pivoted vector.
        Especially when the number of draws is low, these discontinuities can
        stymie a search by ml. Thus <b>ghk2()</b> behaves very smoothly even at low
        draw counts, at the expense of more variability. (As of Stata 10.1,
        ghk() and ghkfast() also allow pivoting to be turned off.)
<p>
      * <b>ghk2()</b> works in Stata 9. Stata 9 does ship with ghk(), but this does
        not use pre-generated points, and so is slower.
<p>
      * <b>ghk2()</b> is generally faster than ghkfast(), at least in
        single-processor versions of Stata. It is optimized for contexts with
        a large number of observations relative to draws. In extreme cases,
        such as 10,000 observations and 10 draws, it can perform an order of
        magnitude faster. But at the opposite extreme, with, say, 100
        observations and 1,000 draws, it can run half as fast.
<p>
      * <b>ghk2()</b> accepts an optional scrambling function. Halton sequences
        based on large primes can have decidedly non-uniform coverage of the
        unit hypercube (Drukker and Gates 2006). "Scrambling" the sequences
        can increase uniformity (Kolenikov 2012).
<p>
      * The <i>start</i> argument allows the user to shift the starting observation
        within the pre-computed block of draws. E.g., if the pre-computed
        block of draws is for 200 observation rows, when calling <b>ghk2()</b> with
        a data matrix that has only 100 rows the <i>start</i> argument would allow
        rows 101-200 of the draws to be used rather than the usual 1-100.
<p>
      * The <i>anti</i> argument, specifying whether to include antithetical draws,
        is required. Any non-zero value is interpreted as requesting them.
<p>
      * It does not take a <i>rank</i> argument.  (ghk() and ghkfast() lost it in
        Stata 10.1 as well.)
<p>
<b><u>Remarks</u></b>
<p>
    The <i>type</i> argument may be <b>"halton"</b>, <b>"hammersley"</b>, <b>"random"</b>, or <b>"ghalton"</b>.
    "Random" and generalized Halton sequences are influenced by the state of
    the random number generator just before <b>ghk2setup()</b> is called. See [M-5]
    uniform().
<p>
    The <b>ghk2()</b> routine performs error checking and then calls one of four
    additional routines, whose syntaxes correspond to the four listed above:
    <b>_ghk2()</b>, <b>_ghk2_2()</b>, <b>_ghk2_d</b>, and <b>_ghk2_2d</b>. You can call these routines
    directly for a slight speed gain.
<p>
    <b>ghk2SqrtScrambler(p)</b> scrambles the modulo-p numbers u=(0, 1, ... p-1}'
    with the formula mod(u * floor(sqrt(p)), p). <b>ghk2NegSqrtScrambler(p)</b> uses
    mod(u * ( -floor(sqrt(p))), p). The user may provide alternative
    functions with the same type of arguments and output; see Kolenikov
    (2012) for ideas.
<p>
<b><u>Examples (colored text is clickable)</u></b>
<p>
    <b>* ghk() and ghkfast() syntax changed in Stata 10.1, but these examples</b>
        <b>are not updated yet.</b>
    . version 9.0
<p>
    <b>* Exact matches, using Halton sequence</b>
    p = ghkfastsetup(10000, 5, 3, "halton")
    p2 = ghk2setup(10000, 5, 3, "halton")
    V = 1, .5, .4 \ .5, 1, .3 \ .4, .3, 1
    rank = dfdx = dfdv = .
    anti = 0
    start = .
<p>
    <b>* Exact matches, using Halton sequence</b>
    ghk((1,2,3), V, (1,5), rank)
    ghkfast(p, (1,2,3), V, rank)
    ghk2(p2, (1,2,3), V, anti, start)
<p>
    <b>* Inexact matches because ghk() and ghkfast() pivot the data vector,</b>
        <b>ordering from low to high</b>
    ghk((3,2,1), V, (1,5), rank)
    ghkfast(p, (3,2,1), V, rank)
    ghk2(p2, (3,2,1), V, anti, start)
<p>
    <b>* Timing comparisons for many observations, few draws, with and without</b>
        <b>score computation</b>
    X = J(10000,3,1)
    timer_clear()
    timer_on(1); mean(ghkfast(p, X, V, rank, ., anti)); timer_off(1)
    timer_on(2); mean(ghk2(p2, X, V, anti, start)); timer_off(2)
    timer()
<p>
    timer_clear()
    timer_on(1); mean(ghkfast(p, X, V, rank, ., anti, dfdx, dfdv));
        timer_off(1)
    timer_on(2); mean(ghk2(p2, X, V, anti, start, dfdx, dfdv)); timer_off(2)
    timer()
<p>
    <b>* Timing comparisons for fewer observations, many draws, including</b>
        <b>antithetical draws</b>
    anti = 1
    p = ghkfastsetup(1000, 250, 3, "halton")
    p2 = ghk2setup(1000, 250, 3, "halton")
    X = J(1000,3,1)
    timer_clear()
    timer_on(1); mean(ghkfast(p, X, V, rank, ., anti)); timer_off(1)
    timer_on(2); mean(ghk2(p2, X, V, anti, start)); timer_off(2)
    timer()
<p>
    timer_clear()
    timer_on(1); mean(ghkfast(p, X, V, rank, ., anti, dfdx, dfdv));
        timer_off(1)
    timer_on(2); mean(ghk2(p2, X, V, anti, start, dfdx, dfdv)); timer_off(2)
    timer()
<p>
    <b>* Demonstration of using lower and upper bounds. The two versions agree</b>
        <b>asymptotically in the number of draws.</b>
    <b>* The first is 8 times faster than the last.</b>
    l1=l2=l3=0; u1=1; u2=2; u3=3
    ghk2(p2, (l1,l2,l3), (u1,u2,u3), V, anti, start)
    ghk2(p2,(u1,u2,u3),V,1,.)-ghk2(p2,(l1,u2,u3),V,1,.)-ghk2(p2,(u1,l2,u3),V,
        &gt; 1,.)-ghk2(p2,(u1,u2,l3),V,1,.)+ghk2(p2,(l1,l2,u3),V,1,.)+ghk2(p2,(u
        &gt; 1,l2,l3),V,1,.)+ghk2(p2,(l1,u2,l3),V,1,.)-ghk2(p2,(l1,l2,l3),V,1,.)
<p>
    <b>* Demonstration of scrambling. Square-root scrambling doesn't affect</b>
        <b>primes 2 and 3; negative square-root doesn't affect 2.</b>
    (0::1), ghk2SqrtScrambler(2), ghk2NegSqrtScrambler(2)
    (0::2), ghk2SqrtScrambler(3), ghk2NegSqrtScrambler(3)
    (0::4), ghk2SqrtScrambler(5), ghk2NegSqrtScrambler(5)
<p>
    <b>* Examples of scrambling in ghk2(): 4-dimensional problem uses primes 2,</b>
        <b>3, 5.</b>
    V = 1, .5, .5, .5 \ .5, 1, .5, .5 \ .5, .5, 1, .5 \ .5, .5, .5, 1
    p2 = ghk2setup(1, 5, 4, "halton", 1)
    ghk2(p2, (1,1,1,1), V, anti, start)
    p2 = ghk2setup(1, 5, 4, "halton", 1, &amp;ghk2SqrtScrambler())
    ghk2(p2, (1,1,1,1), V, anti, start)
    p2 = ghk2setup(1, 5, 4, "halton", 1, &amp;ghk2NegSqrtScrambler())
    ghk2(p2, (1,1,1,1), V, anti, start)
<p>
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>ghk2setup(</b><i>n</i><b>, </b><i>m</i><b>, </b><i>d</i><b>,</b> <i>type</i><b>, | </b><i>pi</i><b>)</b>:
                <i>n</i>:  1 <i>x</i> 1 
                <i>m</i>:  1 <i>x</i> 1
                <i>d</i>:  1 <i>x</i> 1 
             <i>type</i>:  1 <i>x</i> 1 
               <i>pi</i>:  1 <i>x</i> 1 
           <i>result</i>:  <i>transmorphic</i>
<p>
    <b>ghk2(</b><i>P</i><b>,</b> <i>X</i><b>, </b><i>V</i><b>, </b><i>anti</i><b>, </b><i>start</i><b>)</b>:
        <i>input:</i>
                <i>P</i>:  <i>transmorphic</i>
                <i>X</i>:  <i>n x d</i> 
                <i>V</i>:  <i>d x d</i> (symmetric, positive definite)
             <i>anti</i>:  1 <i>x</i> 1
            <i>start</i>:  1 <i>x</i> 1
        <i>output:</i>
           <i>result</i>:  n <i>x</i> 1 
<p>
    <b>ghk2(</b><i>P</i><b>,</b> <i>Xl</i><b>, </b><i>Xu</i><b>, </b><i>V</i><b>, </b><i>anti</i><b>, </b><i>start</i><b>)</b>:
        <i>input:</i>
                <i>P</i>:  <i>transmorphic</i>
               <i>Xl</i>:  <i>n x d</i> 
               <i>Xu</i>:  <i>n x d</i> 
                <i>V</i>:  <i>d x d</i> (symmetric, positive definite)
             <i>anti</i>:  1 <i>x</i> 1
            <i>start</i>:  1 <i>x</i> 1
        <i>output:</i>
           <i>result</i>:  n <i>x</i> 1 
<p>
    <b>ghk2(</b><i>P</i><b>,</b> <i>X</i><b>, </b><i>V</i><b>, </b><i>anti</i><b>, </b><i>start</i><b>, </b><i>dfdx</i><b>, </b><i>dfdv</i><b>)</b>:
        <i>input:</i>
                <i>P</i>:  <i>transmorphic</i>
                <i>X</i>:  <i>n x d</i>
                <i>V</i>:  <i>d x d</i> (symmetric, positive definite)
             <i>anti</i>:  1 <i>x</i> 1
            <i>start</i>:  1 <i>x</i> 1
        <i>output:</i>
           <i>result</i>:  <i>n x</i> 1
             <i>dfdx</i>:  <i>n x d</i>
             <i>dfdv</i>:  <i>n x d</i>(<i>d</i>+1)/2
<p>
    <b>ghk2(</b><i>P</i><b>,</b> <i>Xl</i><b>, </b><i>Xu</i><b>, </b><i>V</i><b>, </b><i>anti</i><b>, </b><i>start</i><b>, </b><i>dfdxl</i><b>, </b><i>dfdxu</i><b>, </b><i>dfdv</i><b>)</b>:
        <i>input:</i>
                <i>P</i>:  <i>transmorphic</i>
               <i>Xl</i>:  <i>n x d</i>
               <i>Xu</i>:  <i>n x d</i>
                <i>V</i>:  <i>d x d</i> (symmetric, positive definite)
             <i>anti</i>:  1 <i>x</i> 1
            <i>start</i>:  1 <i>x</i> 1
        <i>output:</i>
           <i>result</i>:  <i>n x</i> 1
            <i>dfdxl</i>:  <i>n x d</i>
            <i>dfdxu</i>:  <i>n x d</i>
             <i>dfdv</i>:  <i>n x d</i>(<i>d</i>+1)/2
<p>
    <b>ghk2SqrtScrambler(</b><i>p</i><b>)</b>:
        <i>input:</i>
                <i>p</i>:  <i>1 x</i> 1
        <i>output:</i>
           <i>result</i>:  <i>n x</i> 1
<p>
    <b>ghk2NegSqrtScrambler(</b><i>p</i><b>)</b>:
        <i>input:</i>
                <i>p</i>:  <i>1 x</i> 1
        <i>output:</i>
           <i>result</i>:  <i>n x</i> 1
<p>
<b><u>Source code</u></b>
<p>
    ghk2.mata
<p>
<p>
<b><u>References</u></b>
<p>
    Cappellari, L., and S. Jenkins. 2003. Multivariate probit regression
        using simulated maximum likelihood.  <i>Stata Journal</i> 3(3): 278-94.
    Cappellari, L., and S. Jenkins. 2006. Calculation of multivariate normal
        probabilities by simulation, with applications to maximum simulated
        likelihood estimation. <i>Stata Journal</i> 6(2): 156-89.
    Drukker, D., and R. Gates. 2006. Generating Halton sequences using Mata.
        <i>Stata Journal</i> 6(2): 214-28.
    Kolenikov, S. 2012. Scrambled Halton sequences in Mata. <i>Stata Journal</i>
        12(1): 29-44.
    Gates, R. 2006. A Mata Geweke-Hajivassiliou-Keane multivariate normal
        simulator. <i>Stata Journal</i> 6(2): 190-213.
    Genz, A. 1992. Numerical computation of multivariate normal
        probabilities. <i>Journal of Computational and Graphical Statistics</i> 1:
        141–149.
<p>
<b><u>Author</u></b>
<p>
    David Roodman
    Senior Fellow
    Center for Global Development
    Washington, DC
    droodman@cgdev.org
<p>
<p>
<b><u>Also see</u></b>
<p>
    Online:  <b>[M-5] ghk()</b>, <b>[M-5] ghkfast()</b>, <b>[M-5] halton()</b>
</pre>