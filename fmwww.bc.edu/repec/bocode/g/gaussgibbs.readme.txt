AUTHOR: KELVIN BALCOMBE.
The version was last updated on the Oct 2010.  I have run the code on Gauss 6 through to Gauss 10 with no problems. 

INTRO
This is the code that I have named "gaussgibbs", which is a subset of
code which does a far wider range of models. The code here does Gibbs sampling of 5 basic linear models. For each of the models, linear and inequality restrictions can be imposed using a common syntax. 

The instructions here are farly sparse. Experienced gauss users can look in the procs directory, and will be able to access a wider range of output than what is in the example files.

INSTALLING BAYESGIBBS
It is easiest if the code is installed directly onto the c drive, using the directory c:\bayesgibbs\

If so, the gauss.cfg requires that the additional paths be added.

# multiple paths for program files
src_path = $(GAUSSDIR)\gaussplot\src;$(GAUSSDIR)\gaussplot\examples;$(GAUSSDIR)\src;$(GAUSSDIR)\examples;c:\gaussgibbs\procs;

If this directory structure is used, then the example files should run. 


INSTALLING INTO A DIFFERENT DIRECTORY
If you wish to use an alternative directory, then you need to amend the path statement above accordingly. In addition
within the proc directory. You will find a file called direct (c:\gaussgibbs\procs\direct). You need to amend the directories
within that file to ones which are consistent with the ones are using. Otherwise, the output will not be sent to the directory and will induce an error.

If you are using Windows, then only the windows path needs to be amended. 

If you are using a Unix system, you will need to set unixon equal to 1 in the procs\direct file and then amend the directory accordingly.

EXAMPLE FILES
To understand how the code works. There is a set of files in the examples directory. These should automatically work
if the code has been installed directly.


CREATING JOBFILES
It is recommended that you leave the example files unaltered.

You can copy any of the example files into any other directory and it should work.  I use the "jobfiles" directory, so files are easily transfered from one machine to another





For any jobfile,  you need to have the statements at the top of the example file

new;
cls;
#include "gaussprocs";

Without this statement, the code will not run.


STRUCTURES
When running the code, a structure called a is automatically created. if you are unfamiliar with gauss structures
you may find it useful to read the help commands. However you should be able to run the code without an
understanding of structures. However, it is important that you understand that 

a.y  represents the element "y" of the structure a. 

or 

a.x represents the element "x" of the structure a. 

As you can see in the examples files. for all of the models you need to specify a.y (as the dependent) and a.x 
(as the explanatory variables).

OUTPUT
The structure including all the output from any model will automatically be saved in the output subdirectory. 
if you wish to access output of a model which has been run previously, you can use the loadwork command (see below)

DATA
The default input directory is automatically c:\bayesgibbs\data (called indirec unless you have altered this in the direct file within the procs
directory). It is recommended that data files in the data directory, but this is not a requirement. 


FURTHER INSTRUCTIONS
Essential output can be obtained using $a.table for most procedures.
for example typing 

a=ols_(a); will run an OLS regression.
then typing 
$a.table;

will print the output.

WARNING, running routine sequentially can cause problems because the elements of a structure from a previous
run may still exist.

                              


BAYESIAN PROCEDURES
The following are bayesian MCMC procedures.
1. for the GIBBS models then the procedure will depend on a.steptype, the default is standard gibbs sampling. If  a.steptype=1 then a halving and splitting procedure will be used. This is useful for imposing inequality restrictions.
   
2. For all these procedures both inequality restrictions can be set using a.bounds, must have bounds for all betas. For example if there was postivity bounds on the variable coefficient in a bivariate regression with an intercept a.bounds={-10000 10000, 0 100000 };
   
3. Equality restrictions can be defined by using a.rest_mat and a.equality, must be conformable. e.g. in a bivariate linear regression a.rest_mat={1 0} would restrict the intercept to 0
                a.rest_mat={1 0} and 
                a.equality=1 

would restrict the intercept to 1.
NOTE THAT if YOU ARE SPECIFIYING PROPER PRIORS THEN THEY NEED TO BE CONFORMABLE TO THE NUMBER OF FREE PARAMETERS
   
4. The number of iterations for all models is governed by a.trials, a.burn and a.skip. Defaults are 10000, 1000 and 1 respectively (if they are not specified within the code).a.trials is the total number of draws that will be used to map the posterior a.burn is the number of draws that will be thrown away at the beginning
   
   Note, that these defaults are not always sufficient for many models, and you will need to specify larger values within the jobfiles. It is recommend that it does not appear to have reasonable posterior distributions that you set a larger a.skip.
   a.skip=2 means that only every second draw will be recorded.

5. Default priors are non-informative. Informative priors can be set. 
NOTE THAT if YOU ARE SPECIFIYING PROPER PRIORS THEN THEY NEED TO BE CONFORMABLE TO THE NUMBER OF FREE PARAMETERS
  
6. Essential output can be obtained using $a.table.

7. MCMC output is listed in the a.mcmc1, 2,3, or 4. (a.mcmc1 will include the mcmc for beta in the model if there is one). For example a.mcmc1 will be of dimension a.trials by the number of coefficients in the regression model. a.mcmc2 will be a.trials by 1. It includes the precision draws (the inverse of the variance))

8. a.graphit will switch on the running graphs of the mcmc1 output for a subset of the procedures

MODELS
It is recommended that you look at the example files for each of these procedures.

A brief description is below:
 
a=bayes_linear(a);     =Linear  model using gibbs sampling (needs a.y,a.x)

a=bayers_ar1(a);       =Linear model with ar1 errors (needs a.y,a.x)

a=bayes_hetero(a);     =Linear Heteroscedastic Model, Variance of Unknown form, t-distributed errors (needs a.y,a.x) Can have a.hetero_prior ne {}, in which case the prior mean df for the t distribution is not 25. Can have a.lambda ne a.v_lambda, in which case the degrees of freedom for the t-dstribution is set. 
                       

a=bayes_probit(a);     =Binary probit model using gibbs sampling (needs a.y,a.x) (can be identified in two ways, by setting a.probit_ident ne {} and restricting one parameter)


a=bayes_tobit(a);      =Tobit model using gibbs sampling   (needs a.y,a.x)


a=bayes_ordprobit(a)     =Ordered Probit, needs a.y and a.x a.y needs to be in the form of positive integers 1,2,3,4.... etc. The thresholds are a.lambda and in the mcmc3 output.It will choose a default starting value for lambda if one is not specified.Note that in a 5 group model the number of thresholds will b3 5-2 etc.
                                          
         
To access old work by loading and existing structure use 
struct reg a;
a.job=number;
a=loadwork(a);  (a) must be an existing saved structure with a job number
                 mcmc routinees have a default job number of 0
                          
              
