<pre>
<b>help mata mm_callf()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>mm_callf() -- Pass varying number of optional arguments to function</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
             <i>setup</i> = <b>mm_callf_setup(</b><i>f</i><b>,</b> <i>n</i> [<b>,</b> <i>p1</i><b>,</b> <i>p2</i><b>,</b> <i>...</i><b>,</b> <i>p10</i>]<b>)</b>
<p>
        <i>transmorphic</i> <b>mm_callf(</b><i>setup</i> [<b>,</b> <i>o1</i><b>,</b> <i>o2</i><b>,</b> <i>o3</i><b>,</b> <i>o4</i><b>,</b> <i>o5</i>]<b>)</b>
<p>
<p>
    where
<p>
            <i>f</i>:  <i>pointer scalar</i> containing address of function; usually this
                is coded <b>&amp;</b><i>funcname</i><b>()</b>
<p>
            <i>n</i>:  <i>real scalar</i> containing number of "active" optional arguments
<p>
    <i>p1</i> to <i>p10</i>:  potential optional arguments to pass to function <i>f</i>
<p>
     <i>o1</i> to <i>o5</i>:  non-optional arguments to pass to function <i>f</i>
<p>
        <i>setup</i>:  a variable used for communication between <b>mm_callf_setup()</b>
                and <b>mm_callf()</b>; if you declare <i>setup</i>, declare it to be
                <i>transmorphic</i>
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>mm_callf_setup()</b> and <b>mm_callf()</b> are helper tools to implement passing
    through optional arguments to functions.  Up to 10 optional arguments and
    up to 5 non-optional arguments are supported. The tools are based on a
    suggestion made by Bill Gould on Statalist. See 
    http://www.stata.com/statalist/archive/2006-06/msg00303.html.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    <b>mm_callf_setup()</b> and <b>mm_callf()</b> are useful if you are programming
    functions that pass on optional arguments to functions. The difficulty
    with passing optional arguments is that the number of arguments may not
    be known in advance. Usage of <b>mm_callf_setup()</b> and <b>mm_callf()</b> is
    illustrated by the following two examples.
<p>
<p>
    <u>Example 1: static wrapper</u>
<p>
    Say, you intend to program a function called <b>func1()</b> that is a wrapper
    for a function called <b>func2()</b>. Assume, that <b>func2()</b> has one non-optional
    argument, <b>x</b>, and two optional arguments, <b>mean</b> and <b>variance</b>. You may code:
<p>
        function func1(x, | mean, variance)
        {
                transmorphic p
<p>
                p = mm_callf_setup(&amp;func2(), args()-1, mean, var)
<p>
                return(mm_callf(p, x))
        }
<p>
    If a user specifies <b>func1(x)</b>, then <b>mm_callf()</b> will simply execute
    <b>func2(x)</b>. If, however, the user specifies <b>func1(x, mean)</b>, then <b>mm_callf()</b>
    will execute <b>func2(x, mean)</b>. Finally, if <b>func1(x, mean, var)</b> is
    specified, then <b>mm_callf()</b> will execute <b>func2(x, mean, var)</b>.
<p>
    The only tricky part here is the <i>n</i> argument in <b>mm_callf_setup()</b>. It
    should reflect the number of pass-through arguments that have been
    specified by the user. This number can be computed as <b>args()-</b><i>#</i>, where <i>#</i>
    is the number of other arguments (1 in the example above, <b>x</b>).
<p>
    Note that <b>func1()</b> may itself have its own optional arguments. The only
    important thing is that the pass-through arguments come last and that
    <b>args()-</b><i>#</i> properly computes the number of specified pass-through
    arguments. Example:
<p>
        function func1(x, | log, mean, variance)
        {
                transmorphic p
<p>
                if (args()==1) log = 0
<p>
                p = mm_callf_setup(&amp;func2(), args()-2, mean, var)
<p>
                if (log) return(mm_callf(p, log(x)))
                return(mm_callf(p, x))
        }
<p>
    See the source code of <b>mm_kint()</b> for a real example.
<p>
<p>
    <u>Example 2: dynamic wrapper</u>
<p>
    A more complicated case is when you are programming a function that
    receives a function as an argument and optional arguments are to be
    passed on to this received function. (If you have not read <b>[M-2] ftof</b>
    yet, please read it now.) Let the wrapper function again be called
    <b>func1()</b>. Assume that there are two non-optional arguments, <b>x</b> and <b>w</b>, and
    that the maximum number of optional arguments to be passed through is
    three. The code of <b>func1()</b> may then be:
<p>
        function func1(pointer(function) scalar f, x, w,
                        | a1, a2, a3)
        {
                transmorphic p
<p>
                p = mm_callf_setup(f, args()-3, a1, a2, a3)
<p>
                return(mm_callf(p, x, w))
        }
<p>
    See the source code of <b>mm_bs()</b> or <b>mm_jk()</b> for real examples.
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>mm_callf_setup(</b><i>f</i><b>,</b> <i>n</i><b>,</b> <i>p1</i><b>,</b> <i>...</i><b>,</b> <i>p10</i><b>)</b>
           <i>f</i>:  1 <i>x</i> 1
           <i>n</i>:  1 <i>x</i> 1
     <i>p1</i> etc.:  (depending on function <i>f</i>)
      <i>result</i>:  <i>struct mm_callf_o10</i>
<p>
    <b>mm_callf(</b><i>setup</i><b>,</b> <i>o1</i><b>,</b> <i>...</i><b>,</b> <i>o5</i><b>)</b>
       <i>setup</i>:  <i>struct mm_callf_o10</i>
     <i>o1</i> etc.:  (depending on function <i>f</i>)
      <i>result</i>:  (depending on function <i>f</i>)
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    None.
<p>
<p>
<b><u>Source code</u></b>
<p>
    mm_callf.mata
<p>
<b><u>Author</u></b>
<p>
    Ben Jann, ETH Zurich, jann@soz.gess.ethz.ch
<p>
<p>
<b><u>Also see</u></b>
<p>
</pre>