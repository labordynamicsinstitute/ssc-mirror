<pre>
<b>help for mim</b>                         P Royston, JC Galati, JB Carlin &amp; IR White
-------------------------------------------------------------------------------
<p>
<p>
<b><u>Title</u></b>
<p>
    <b>mim</b> -- A prefix command for analysing and manipulating multiply imputed
    datasets
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <b>mim</b> [<b>,</b><i> mim_options</i>] <b>:</b> <i>command</i>
<p>
        <b>mim</b> [<b>,</b><i> replay_options</i>]
<p>
<p>
<p>
    <i>mim_options</i>            Description
    -------------------------------------------------------------------------
    General
    * <b><u>cat</u></b><b>egory(</b><i>cat_type</i><b>)</b>   where <i>cat_type</i> is <b>fit</b>, <b>manip</b> or <b>combine</b> - specify
                             whether <i>command</i> is estimation, data manipulation
                             or one whose (scalar) results are to be combined
                             using Rubin's rules
      <b><u>noi</u></b><b>sily</b>              display output from execution of <i>command</i> within
                             each of the imputed datasets
<p>
    Estimation (valid only for estimation commands)
      <b><u>dot</u></b><b>s</b>                 display progress dots during model fitting
      <b>from(</b><i>#</i><b>)</b>              fit model, starting from imputation <i>#</i>
      <b>to(</b><i>#</i><b>)</b>                fit model, ending with imputation <i>#</i>
      <b><u>st</u></b><b>orebv</b>              fills <b>e(b)</b>, <b>e(V)</b> etc. with multiple-imputation
                             estimates
<p>
    Manipulation (valid only for data manipulation commands)
    + <b><u>so</u></b><b>rtorder(</b><i>varlist</i><b>)</b>   one or more variables that uniquely identify the
                             observations in a given imputed dataset
                             following each execution of <i>command</i>
<p>
    Combination (valid for a wide range of Stata commands)
      <b>est(</b><i>est_spec</i><b>)</b>        specifies the scalar (called <i>est</i>) to be combined
                             across imputations
      <b>se(</b><i>se_spec</i><b>)</b>          specifies the standard error of <i>est</i> to be combined
                             across imputations
      <b><u>byv</u></b><b>ar</b>                uses byvar (rather than the default, statsby) to
                             extract and store <i>est</i> and its SE in each
                             imputation
<p>
    -------------------------------------------------------------------------
    * only necessary for estimation and data manipulation commands not listed
      under Description
    + not valid for append and reshape; MANDATORY for all other data
      manipulation commands.
<p>
<p>
    <i>replay_options</i>         Description
    -------------------------------------------------------------------------
      <b><u>cl</u></b><b>earbv</b>              clears <b>e(b)</b>, <b>e(V)</b> etc., but leaves other <b>mim</b>
                             estimates intact
      <b>j(</b><i>#</i><b>)</b>                 fills <b>e(b)</b>, <b>e(V)</b> etc. with estimates corresponding
                             to imputed dataset <i>#</i>
      <b><u>mc</u></b><b>error</b>              displays a table of Monte Carlo standard errors
                             for quantities in the table of regression
                             coefficients
      <b><u>st</u></b><b>orebv</b>              same as for estimation, unless <b>j</b> option is
                             specified
      <i>reporting_options</i>    level and eform options supported by <i>command</i>
    -------------------------------------------------------------------------
<p>
    <b>xi</b> is allowed as a prefix to <b>mim</b>, but not as prefix to <i>command</i>, see xi.
    <b>svy</b> is allowed as a prefix to <i>command</i>, see svy.
    <b>version</b> is allowed as a prefix to <i>command</i>, see version.
<p>
<p>
<p>
<a name="description"></a><b><u>Description</u></b>
<p>
    <b>mim</b> is a prefix command for working with multiply-imputed (MIM) datasets,
    where <i>command</i> can be any of a wide range of Stata commands. The function
    that <b>mim</b> performs depends on the category of <i>command</i> passed to <b>mim</b>;
    either estimation, data manipulation, post estimation or utility. A
    limited range of commands can be used with <b>mim</b> without specifying the
    <b>category</b> mim_option. These are:
<p>
        <i>Estimation:</i>  regress, mean, proportion, ratio, logistic, logit, 
        ologit, mlogit, probit, oprobit, poisson, glm, binreg, nbreg, gnbreg,
        blogit, clogit, cnreg, mvreg, rreg, qreg, iqreg, sqreg, bsqreg, 
        stcox, streg, xtgee, xtreg, xtlogit, xtnbreg, xtpoisson, xtmixed, 
        svy:regress, svy:mean, svy:proportion, svy:ratio, svy:logistic, 
        svy:logit, svy:ologit, svy:mlogit, svy:probit, svy:oprobit, 
        svy:poisson, stepwise
<p>
        <i>Post Estimation:</i>  lincom, testparm, predict
<p>
        <i>Data Manipulation:</i>  reshape, append, merge
<p>
        <i>Utility:</i>  <b>check</b>, <b>genmiss</b>
<p>
    With one exception, <i>command</i> is specified with its full usual syntax. The
    exception is merge, where only one "using" file is allowed. Also, <i>command</i>
    may be one of two internal utility commands, <b>check</b> and <b>genmiss</b>, where the
    required syntaxes are
<p>
        <b>mim</b> <b>:</b> <b>check</b> [<i>varlist</i>]
<p>
        <b>mim</b> <b>:</b> <b>genmiss</b> <i>varname</i>
<p>
    respectively (see Utility commands for more details regarding these two
    commands).
<p>
    Note that the <i>command</i> <b>stepwise</b> expects the synatx of Stata's <b>stepwise</b>
    command, and is itself a 'prefix' command. It uses P-values from Wald
    tests for deciding whether to include or exclude variables in a model.
<p>
    Further Stata estimation and data manipulation commands can be used with
    <b>mim</b> by specifying the mim_option <b>category(</b><i>mim_type</i><b>)</b>, where <i>mim_type</i> may
    be <b>fit</b> for estimation commands, <b>manip</b> for data manipulation commands or
    <b>combine</b> for combining scalar estimates and their SE's according to
    Rubin's rules. See Combining estimates using Rubin's rules for more
    details of <b>mim, category(combine)</b>, and Combining estimates using Rubin's
    rules for a warning about combining estimates in this way. Use of <b>mim</b> in
    these ways is at the user's discretion, and the results are not
    guaranteed.
<p>
    The dataset structure used by <b>mim</b> is a stacked format. In Stata 11 it may
    be either the new <i>flong</i> style or that created by Royston's ice (if
    installed) command. Details of the dataset format may be found under MIM
    dataset format below. Also, please study the following remarks on how <b>mim</b>
    functions under different versions of Stata.
<p>
    <b><u>mim and Stata 11</u></b>
<p>
    With Stata 11, <b>mim</b> recognizes the 'old' ice-style format variables (<b>_mi</b>
    and <b>_mj</b>) and the new <b>mi</b>-style variables (<b>_mi_id</b> and <b>_mi_m</b>). Note that
    multiply imputed data created by ice can be imported into the <b>mi</b> <i>flong</i>
    style by using the command mi import ice<b>, clear automatic</b>. The <b>automatic</b>
    option ensures that the imputed variables are correctly registered. If
    you omit the option, you may encounter difficulties.
<p>
    If <b>mim</b> is called by a Stata version below 11.0, it recognizes only <b>_mi</b>
    and <b>_mj</b> as format variables. If called by Stata version 11.0 or higher,
    <b>mim</b> first looks for <b>_mi</b> and <b>_mj</b>. If it fails to find them, it checks for
    an <b>mi</b>-style data structure and if necessary converts the data to style
    <i>flong</i> (see mi set and mi convert). Note that the <i>flong</i> style persists
    after <b>mim</b> has finished. Finally, if neither type of formatting is found,
    <b>mim</b> gives up and issues an error message.
<p>
    In what follows, the format variables are called <b>_mi_id</b> and <b>_mi_m</b> with
    the implicit understanding that if the data are in the <b>ice</b> format, we
    mean <b>_mi</b> and <b>_mj</b>, respectively.
<p>
    With Stata 11, if the data are in <b>mi</b> format and <b>mim</b> creates new
    variables, e.g. with the <b>mim: predict</b> <i>newvar</i> command, make sure you keep
    such variables unregistered. To avoid possible data loss in Stata 11 when
    working with <b>mim</b>, do NOT convert the data to a different <b>mi</b> style using 
    mi convert.
<p>
    When <b>mim</b> starts, it checks and reports which format is being used.
<p>
<p>
<b><u>Options</u></b>
<p>
        +---------+
    ----+ General +----------------------------------------------------------
<p>
    <b>category</b> specifies the type of command that is being passed to <b>mim</b>,
        either estimation (category <b>fit</b>) or data manipulation (category
        <b>manip</b>).
<p>
    <b>noisily</b> specifies that the results of the application of <i>command</i> to each
        of the individual imputed datasets should be displayed.
<p>
        +------------+
    ----+ Estimation +-------------------------------------------------------
<p>
    <b>dots</b> specifies that progress dots should be displayed.
<p>
    <b>from(</b><i>#</i><b>)</b> fits the specified model from imputation <i>#</i> (i.e. for <b>_mi_m &gt;= </b><i>#</i>).
        <i>#</i> must be an integer between 1 and <i>m</i>, the maximum value of <b>_mi_m</b> in
        the dataset.  Default <i>#</i> is 1.
<p>
    <b>storebv</b> specifies that the standard list of returned results for
        estimation commands be filled using the multiple-imputation results.
        In particular this forces the multiple-imputation coefficient and
        covariance matrix estimates into <b>e(b)</b> and <b>e(V)</b>, respectively,
        enabling application at the user's own discretion of Stata
        post-estimation commands that use these quantities directly (see
        Replay of estimation results [advanced] for further details).
<p>
    <b>to(</b><i>#</i><b>)</b> fits the specified model between imputation <b>from()</b> and imputation
        <i>#</i>.  <i>#</i> must be an integer between 2 and <i>m</i>, where <i>m</i> is the maximum
        value of <b>_mi_m</b> in the dataset. Note that if <i>#</i> &gt; <i>m</i> then <i>#</i> is assumed
        to equal <i>m</i> and no error is raised. Default <i>#</i> is <i>m</i>.
<p>
        +--------------+
    ----+ Manipulation +-----------------------------------------------------
<p>
    <b>sortorder</b> specifies a list of one or more variables that uniquely
        identify the observations in each of the datasets in a <b>mim</b>-compatible
        dataset; for data manipulation, this option must specify a list of
        variables that together uniquely identify the observations in each
        dataset AFTER <i>command</i> has been applied to the given dataset (note
        that <i>varlist</i> cannot include <b>_mi_id</b>, since the <b>_mi_m</b> and <b>_mi_id</b>
        variables are dropped from each dataset prior to the call to
        <i>command</i>).
<p>
        +-------------+
    ----+ Combination +------------------------------------------------------
<p>
    <b>byvar</b> specifies that <b>byvar</b> be used to execute the required <i>stata_cmd</i> in
        each imputation and store the required statistic (and optionally, its
        SE) in new variable(s), to be combined by <b>mim</b> according to Rubin's
        rules. The default is to use <b>statsby</b>. Use of <b>byvar</b> affects the syntax
        of the options <b>est()</b> and <b>se()</b>, see below.
<p>
    <b>est(</b><i>est_spec</i><b>)</b> specifies the scalar <i>est</i> to be combined across imputations.
        <i>est_spec</i> depends on whether the <b>byvar</b> option is used or not. By
        default, <b>statsby</b> is used to compute <i>est</i> from <i>stata_cmd</i> according to
        <i>est_spec</i>.
<p>
        The following table shows what <i>est_spec</i> looks like when the estimand,
        <i>est</i>, is a regression coefficient, its SE, or a quantity (usually a
        scalar) returned by <i>stata_cmd</i> in either an <b>e()</b> or an <b>r()</b> result:
<p>
        ---------------------------------------------------------------
        Type of estimand (<i>est</i>)        <b>statsby</b> (default)        <b>byvar</b>     
        ---------------------------------------------------------------
        Regression coefficient        [<i>eq</i>]<b>_b[</b><i>varname</i><b>]</b>        <b>b(</b><i>varname</i><b>)</b> 
        SE of regression coefficient  [<i>eq</i>]<b>_se[</b><i>varname</i><b>]</b>      <b>se(</b><i>varname</i><b>)</b> 
        Quantity returned in e()       <b>e(</b><i>quantityname</i><b>)</b>  <b>e(</b><i>quantityname</i><b>)</b> 
        Quantity returned in r()       <b>r(</b><i>quantityname</i><b>)</b>  <b>r(</b><i>quantityname</i><b>)</b> 
        ---------------------------------------------------------------
<p>
        The optional <i>eq</i> refers to an 'equation'; <i>eq</i> may be <b>#</b><i>#</i>, where <i>#</i> is an
        equation number, or an equation name. <b>byvar</b> does not currently
        support multiple equations.
<p>
    <b>se(</b><i>se_spec</i><b>)</b> specifies the standard error of <i>est</i> to be used with Rubin's
        rules. Note that <b>se()</b> is optional; if omitted, only the mean of <i>est</i>
        across imputations is calculated. <i>se_spec</i> follows the same rules as
        <i>est_spec</i> (see <b>est()</b> above).
<p>
        +--------+
    ----+ Replay +-----------------------------------------------------------
<p>
    <b>clearbv</b> specifies that the additional items returned using the <b>storebv</b> or
        <b>j</b> options be cleared, but that all other estimation results returned
        by <b>mim</b> be left intact.
<p>
    <b>j(</b><i>#</i><b>)</b> specifies that the standard results returned by estimation commands
        be filled using the estimates from the last fit of an estimation
        command applied to the <i>#</i>th imputed dataset, and that these estimates
        be replayed.
<p>
    <b>mcerror</b> displays a table of Monte Carlo standard errors for the
        quantities presented in the main table of multiple-imputation
        results. The MC standard errors measure the uncertainty in the
        estimated quantities due to the use of a finite number m of
        imputations.  In general, MC error decreases as m is increased.  The
        MC error for the regression coefficients is computed as the square
        root of the between-imputation variance (B) divided by the square
        root of the number of imputations.  For the other quantities,
        jackknife estimates (leaving out one imputation each time) (Efron &amp;
        Gong 1983) are presented.  The <b>mcerror</b> option may not be combined
        with other replay options other than <i>reporting_options</i>, nor may it be
        specified at model-fitting time.
<p>
    <b>storebv</b>, same as for estimation, unless the <b>j</b> option is specified.
<p>
    <i>reporting_options</i> specifies <b>level()</b> and <b>eform</b> options supported by
        <i>command</i>.
<p>
<p>
    There are no <i>mim_options</i> for <b>mim: check</b> and <b>mim: genmiss</b>.  <b>mim: predict</b>
    allows options appropriate to <b>predict</b> after <i>command</i> - see Notes on mim:
    predict for further information.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Remarks are presented under the headings <i>MIM dataset format</i>, <i>Display of</i>
    <i>regression results</i>, <i>Combining estimates using Rubin's rules</i>, <i>Notes on</i>
    <i>mim: predict</i>, and <i>Score labels in -mlogit-</i>.
<p>
<a name="format"></a>    <b><u>MIM Dataset format</u></b>
<p>
    For a multiply-imputed dataset to be compatible with <b>mim</b>, the dataset
    must contain:
<p>
        a numeric variable called <b>_mi_m</b> whose values identify the individual
            dataset to which each observation belongs,
        a numeric variable called <b>_mi_id</b> whose values identify the
            observations within each individual dataset.
<p>
    Moreover, if the original data with missing values are to be stored in
    the dta file, then those observations must be identified with the value
    <b>_mi_m==0</b>, while imputed datasets are identified using positive <b>_mi_m</b>
    values. In particular, the dataset in the stack identified by <b>_mi_m==0</b> is
    ignored for the purpose of model fitting with <b>mim</b>. For convenience, a
    multiply-imputed dataset satisfying the above requirements is called a
    <b>MIM dataset</b>.
<p>
    The requirements above have been kept as simple as possible. They allow a
    set of multiply-imputed datasets stored in separate files to be stacked
    into the format required by <b>mim</b> using only the basic data processing
    commands <b>generate</b>, <b>append</b> and <b>replace</b>. (Nevertheless, for convenience, a
    dedicated command mimstack has been provided for this purpose.)
<p>
    An example of a multiply imputed dataset in <b>mim</b>-compatible format is
    shown below. The original data consist of a completely observed variable
    y and a variable x with missing values in the 3rd, 4th and 6th
    observations, and there are 2 imputed copies of the original dataset in
    the stack.
<p>
                     <b>_mi_m</b>      <b>_mi_id</b>       <b>y</b>        <b>x</b>    
                      ----------------------------------
                         0        1      1.1        105 
                         0        2      9.2        106 
                         0        3      1.1          . 
                         0        4      2.3          . 
                         0        5      7.5        108 
                         0        6      7.9          . 
                         1        1      1.1        105 
                         1        2      9.2        106  
                         1        3      1.1    109.796  
                         1        4      2.3    110.456  
                         1        5      7.5        108  
                         1        6      7.9    102.243  
                         2        1      1.1        105  
                         2        2      9.2        106 
                         2        3      1.1    107.952 
                         2        4      2.3    115.968 
                         2        5      7.5        108 
                         2        6      7.9    114.479 
<p>
<p>
<a name="display"></a>    <b><u>Display of regression results</u></b>
<p>
    <b>mim</b> displays parameter estimates (obtained by Rubin's rules - see Model
    fitting) and their standard errors, taking into account between- and
    within-imputation variation.  Confidence intervals and test statistics
    for regression coefficients are based on the t distribution with
    estimated degrees of freedom (d.f.) obtained using the method of Barnard
    and Rubin. The final entry for each parameter estimate in the model is
    "FMI", standing for "fraction of missing information". For each
    predictor, the FMI is a function of the ratio of the between- to
    within-imputation variance of the estimated coefficient and its d.f.:
<p>
        FMI = [r + 2/(d.f. + 3)]/(r + 1)
<p>
    where r is the "relative increase in variance due to non-response"
    (Rubin). Since d.f. is always positive, FMI lies between 0 and 1, and
    since d.f. is usually considerably larger than 3, FMI is approximately
    r/(r + 1).  The larger the value of FMI, the greater the loss of
    information (hence loss of precision) that has been induced in the
    estimated coefficient by the missing data.
<p>
    It is important to remember that the reported FMI is an <i>estimate</i>.  For a
    small number of imputations, the estimate may be imprecise.  Just how
    imprecise may be gauged to some extent by increasing the number of
<a name="combine_estimates_r"></a>    imputations, refitting the model in <b>mim</b> and inspecting the resulting FMI.
    Combining estimates using Rubin's rules {pstd} While statistical theory
    guarantees the asymptotic normality of regression coefficients estimated
    by maximum likelihood, the same guarantee does not apply in general. One
    should be aware that combining estimates across imputations using Rubin’s
    rules may not always make sense.  In particular, it assumes that the
    sampling distribution of the estimate is approximately normal, with the
    corresponding SE (if supplied).  It may be appropriate to transform the
    scale of the parameter (e.g. Fisher’s transform for the correlation
<a name="mimpredict"></a>    coefficient) before obtaining MI combined estimates.  Notes on mim:
    predict {pstd} The syntax of <b>mim: predict</b> is {phang}<b>mim: predict</b>
    <i>newvarname</i> <b>,</b> [ <i>predict_options</i> ] {pstd} where <i>predict_options</i> are options
    appropriate to <b>predict</b> for <i>command</i>, the regression command just run by
    <b>mim</b>. Note that <b>mim: predict</b> can only predict one new variable
    (<i>newvarname</i>) at a time. Thus syntaxes of <b>predict</b> that allow one to
    predict several variables at once are disallowed. The most obvious
    example is <b>mlogit</b>. For example, suppose <b>y</b> was a 3-level categorical
    outcome variable, coded 1, 2, 3, and a model of the form <b>mim: mlogit y</b>
    <i>explanatory_variables</i> had just been fit. The command {phang}<b>. mim:</b>
    <b>predict yhat1 yhat2 yhat3, xb</b> {pstd} would result in an error message
    (<b>too many variables specified</b>), whereas following regular <b>mlogit</b>, it
    would be valid. The solution with <b>mim: predict</b> is {phang}<b>. mim: predict</b>
    <b>yhat1, outcome(1) xb</b>{p_end} {phang}<b>. mim: predict yhat2, outcome(2)</b>
    <b>xb</b>{p_end} {phang}<b>. mim: predict yhat3, outcome(3) xb</b>{p_end} {pstd} The
    default action for <b>mim: predict</b> is the same as the default for <b>predict</b>
    after <i>command</i>. For example, when <i>command</i> is <b>logit</b>, <b>mim: predict</b> produces
    the event probability, not the linear predictor. The option <b>xb</b> must be
    included to obtain the linear predictor.  The values returned in the
    imputed datasets (<b>_mj</b> &gt; 0) use imputation-specific parameter estimates
    and (if appropriate) the imputed covariate values. The values returned in
    the <b>_mj</b> = 0 section of the dataset are obtained by combining the
    predictions from the imputed datasets using Rubin’s rules.  {pstd} As
    just mentioned, the across-imputation average of whatever is being
    predicted is stored in imputation 0 (<b>_mj</b> = 0). Note, however, that if
    after fitting (say) a <b>mim: logit</b> model you do <b>mim: predict p</b> and <b>mim:</b>
    <b>predict xb, xb</b>, then logit(<b>p</b>) = <b>xb</b> for <b>_mj</b> &gt; 0 but not for <b>_mj</b> = 0.  The
    behaviour is logical, but should nevertheless be borne in mind.  {pstd}
    There may be better ways to perform multiple-imputation inference for a
    desired predicted quantity, particularly when the latter is a highly
    non-linear function of the original model parameters.  In the case of
    logistic regression, for example, a user might prefer to combine on the
    linear predictor scale before obtaining inferences for predicted
    probabilities by back-transformation, i.e.  <b>mim: predict xb, xb</b> followed
    by <b>gen p = invlogit(xb)</b>, which will not give the same results as <b>mim:</b>
    <b>predict p</b>. There appears to be no clear statistical theory to guide these
    decisions.  Score labels in -mlogit- {pstd} It is legal in Stata for
    score labels to contain periods (UK English: full stops). For example,
    {phang}<b>. label define edulbl 1 "Less than H.S." 2 "H.S." 3 "Assoc. or</b>
    <b>higher"</b>{p_end} {phang}<b>. label values edu edulbl</b> {pstd} is perfectly
    valid. Such labels define equation-names when used with the <b>mlogit</b>
    command. However, Stata does not allow them to be transferred "manually"
    to matrices, a feature which would stop <b>mim</b> in its tracks.  To avoid the
    problem, <b>mim</b> converts the periods in such labels to underscores when
<a name="results"></a>    reporting <b>mlogit</b> model equations.  Saved results {pstd} After model
    fitting, <b>mim</b> returns results in <b>e()</b> as follows.  {synopthdr:Result}
    {syntab:<i>Matrices</i>} {synopt:<b>e(MIM_Q)</b>}coefficient estimates{p_end}
    {synopt:<b>e(MIM_T)</b>}total covariance matrix estimate{p_end}
    {synopt:<b>e(MIM_TLRR)</b>}Li-Raghunathan-Rubin (1999) estimate of total
    covariance matrix{p_end} {synopt:<b>e(MIM_W)</b>}within imputation covariance
    matrix estimate{p_end} {synopt:<b>e(MIM_B)</b>}between imputation covariance
    matrix estimate{p_end} {synopt:<b>e(MIM_dfvec)</b>}vector of MI degrees of
    freedom{p_end} {synopt:<b>e(MIM_lambda)</b>}vector of fraction of missing
    information (FMI){p_end} {synopt:<b>e(MIM_r)</b>}vector of increase in variance
    due to missing information{p_end} {syntab:<i>Scalars</i>}
    {synopt:<b>e(MIM_dfmin)</b>}minimum of <b>e(MIM_dfvec)</b>{p_end}
    {synopt:<b>e(MIM_dfmax)</b>}maximum of <b>e(MIM_dfvec)</b>{p_end}
    {synopt:<b>e(MIM_Nmin)</b>}minimun number of observations used in
    estimation{p_end} {synopt:<b>e(MIM_Nmax)</b>}maximum number of observations used
    in estimation{p_end} {syntab:<i>Macros</i>} {synopt:<b>e(MIM_m)</b>}number of imputed
    datasets used in estimation{p_end} {synopt:<b>e(MIM_levels)</b>}values of <b>_mi_m</b>
    variable used in estimation{p_end} {synopt:<b>e(MIM_prefix)</b>}value of
    <b>e(</b><i>prefix</i><b>)</b> returned by <i>command</i>{p_end} {synopt:<b>e(MIM_prefix2)</b>}<b>mim</b>{p_end}
    {synopt:<b>e(MIM_cmd)</b>}the name of the estimation command specified in
    <i>command</i>{p_end} {synopt:<b>e(MIM_depvar)</b>}value of <b>e(depvar)</b> returned by
    <i>command</i>{p_end} {synopt:<b>e(MIM_title)</b>}value of <b>e(title)</b> returned by
    <i>command</i>{p_end} {synopt:<b>e(MIM_properties)</b>}value of <b>e(properties)</b> returned
    by <i>command</i>{p_end} {synopt:<b>e(MIM_eform)</b>}value of <b>e(eform)</b> returned by
    <i>command</i>{p_end} {syntab:<i>Additional results (returned when</i><b> storebv</b><i> option</i>
    <i>is specified)</i>} {synopt:<b>e(b)</b>}equal to <b>e(MIM_Q)</b>{p_end} {synopt:<b>e(V)</b>}equal
    to <b>e(MIM_T)</b>{p_end} {synopt:<b>e(N)</b>}equal to <b>e(MIM_Nmin)</b>{p_end}
    {synopt:<b>e(sample)</b>}equal to 1 for observations in the estimation sample, 0
    otherwise{p_end} {synopt:<b>e(cmd)</b>}equal to <b>e(MIM_cmd)</b>{p_end}
    {synopt:<b>e(depvar)</b>}equal to <b>e(MIM_depvar)</b>{p_end} {synopt:<b>e(df_r)</b>}equal to
    <b>e(MIM_dfmin)</b>{p_end} {synopt:<b>e(properties)</b>}equal to
    <b>e(MIM_properties)</b>{p_end} Examples {pstd} Examples and accompanying
    remarks are given under the headings <i>Model fitting</i>, <i>Data manipulation</i>,
    <i>Post-estimation</i>, <i>Replay of estimation results [advanced]</i>, <i>Utility</i>
<a name="fitting"></a>    <i>commands</i>, and <i>Combining estimates using Rubin's rules</i>.  Model fitting
    {pstd} When invoked for model fitting, <b>mim</b> applies <i>command</i> to each of the
    imputed datasets in the current MIM dataset, and then combines the
    individual estimates using Rubin's rules for multiple-imputation-based
    inferences. In most cases fitting a statistical model to a
    multiply-imputed dataset with <b>mim</b> is simply a matter of loading the
    MIM-format dataset into Stata and executing the desired estimation
    command, prefixing it with the <b>mim</b> prefix. Several examples are provided
    below.  {phang} <b>. use mymimdataset1, clear</b> {p_end} {phang} <b>. mim: regress</b>
    <b>y x1 x2 x3 x4</b> {p_end} {phang} <b>. use mymimdataset2, clear</b> {p_end} {phang}
    <b>. mim: logistic y x1 x2, coef</b> {p_end} {phang} <b>. use mymimdataset3, clear</b>
    {p_end} {phang} <b>. xi: mim: glm low age lwt i.race smoke ptl ht ui, f(bin)</b>
    <b>l(logit) le(90)</b> {p_end} {phang} <b>. xi: mim: stepwise, pr(0.05): glm low</b>
    <b>age lwt (i.race) smoke ptl ht ui, f(bin) l(logit) le(90)</b> {p_end} {phang}
    <b>. use mymimdataset4, clear</b> {p_end} {phang} <b>. mim: svy: proportion</b>
    <b>heartatk</b> {p_end} {phang} <b>. mim: svy: logistic heartatk age weight height</b>
    {p_end} {phang} <b>. mim, noi: svy jackknife, nodots: logit highbp height</b>
    <b>weight age age2 female black, or</b> {p_end} {phang} <b>. use mymimdataset5,</b>
    <b>clear</b> {p_end} {phang} <b>. mim: xtmixed gsp private emp water other unemp ||</b>
    <b>region: R.state, l(90)</b> {p_end} {pstd} Additionally, other Stata
    estimation commands may by fitted to a MIM dataset using the
    <b>category(fit)</b> option of <b>mim</b>. Two examples are given below.  {phang} <b>. use</b>
    <b>mymimdataset6, clear</b> {p_end} {phang} <b>. mim, cat(fit): mvprobit (private =</b>
    <b>years logptax loginc) (vote=years logptax loginc), nolog</b> {p_end} {phang}
    <b>. use mymimdataset7, clear</b> {p_end} {phang} <b>. mim, cat(fit): MyNewCommand</b>
    <b>y x1 x2</b> {p_end} Data manipulation {pstd} The stacked dataset format used
    by <b>mim</b> allows simple data manipulation such as generating and replacing
    variables to be performed using existing Stata commands. More complex
    data manipulation tasks, particularly those that alter the number of
    observations in each of the imputed datasets, usually require more
    detailed programming. For convenience, three common tasks, namely
    reshaping, appending and merging datasets, can be accomplished by
    prefixing the relevant command with <b>mim</b>. The first two are
    straightforward, and in most instances will be applied by simply
    prefixing the usual syntax with <b>mim</b>.  {phang} <b>. use mymimdataset7, clear</b>
    {p_end} {phang} <b>. mim: reshape wide income, i(id) j(year)</b> {p_end} {phang}
    <b>. mim: reshape long</b> {p_end} {phang} <b>. use mymimdataset8, clear</b> {p_end}
    {phang} <b>. mim: append using mymimdataset9</b> {p_end} {pstd} Merging two
    <b>mim</b>-compatible datasets requires a little further explanation, since it
    requires that the <b>sortorder</b> option be specified to <b>mim</b>. This option is
    necessary so that <b>mim</b> can generate a new <b>_mi_id</b> variable once merging is
    complete. For example, suppose that <b>mymimdataset10</b> is a <b>mim</b>-compatible
    dataset containing patient details, with each patient having a unique <b>id</b>,
    and <b>mymimdataset11</b> is a second stacked dataset containing additional
    longitudinal measurements on each patient, with each measurement uniquely
    identified by the two variables <b>id time</b>. Merging these data into a single
    dataset would usually be accomplished by a match-merge on the <b>id</b>
    variable. However, once merging is complete, the observations in the
    merged dataset are determined by the pair of variables <b>id</b> and <b>time</b>. Using
    <b>mim</b> the merge would be accomplished as follows:  {phang} <b>. use</b>
    <b>mymimdataset10, clear</b> {p_end} {phang} <b>. mim, sortorder(id time): merge id</b>
    <b>using mymimdataset11</b> {p_end} {pstd} Additionally, other Stata commands
    that either manipulate a single dataset or a master/using pair of
    datasets may by applied to a multiply-imputed dataset using the <b>category</b>
    option of <b>mim</b>. This is most likely to be of interest when <i>command</i> is a
    user-written program designed to accomplish a project-specific task.
    {phang} <b>. use mymimdataset12, clear</b> {p_end} {phang} <b>. mim,</b>
<a name="postestimation"></a>    <b>category(manip) so(id): mystatacmd x1 x2 x3</b> {p_end} Post-estimation
    {pstd} In general Stata's standard post-estimation methods cannot be
    directly applied with multiply-imputed data. Methods relying on
    likelihood comparisons (<b>lrtest</b>) are not applicable because multiple
    imputation does not involve calculation of likelihood functions for the
    data. Furthermore, application of a post-estimation command directly to
    the multiple-imputation estimates will not in general produce valid
    simultaneous inferences for multiple parameters, since applying Rubin's
    rules to the vector of parameter estimates and their associated
    variance-covariance matrices does not work reliably (Li et al, 1991).
    Performing inferences for target parameters that are scalar
    (unidimensional) is however easily accomplished using Rubin's rules, and
    this has enabled us to create multiple-imputation versions of <b>lincom</b> and
    <b>predict</b>. In addition, we have implemented the method of Li et al (1991)
<a name="testparm"></a>    to create a <b>mim</b>-specific version of <b>testparm</b>, which allows the testing of
    null hypotheses relating to a vector of parameters.  Examples of the use
<a name="lincom"></a>    of <b>mim: lincom</b>, <b>mim: testparm</b> and <b>mim: predict</b> are given below. For other
    post-estimation tasks see the additional remarks under Replay of
    estimation results [advanced].  {pstd} Warning: <b>mim: lincom</b> has an
    anomalous feature.  Stata's <b>lincom</b> following <b>logistic</b> behaves atypically
    compared with other Stata regression commands such as <b>stcox</b>. If you wish
    to get odds ratio estimates with <b>mim: logistic</b> followed by <b>mim: lincom</b>,
    you should specify the model as <b>mim: logit ..., or</b> and the lincom command
    as <b>mim: lincom</b> <i>exp</i><b>, or</b>.  {phang} <b>. use mymimdataset2, clear</b> {p_end}
    {phang} <b>. mim: logit y x1 x2</b> {p_end} {phang} <b>. mim: lincom x1 + 2 * x2</b>
    {p_end} {phang} <b>. mim: lincom x1 + x2, or</b> {p_end} {phang} <b>. mim: testparm</b>
    <b>_all</b> {p_end} {phang} <b>. mim: predict yhat, xb</b> {p_end} {phang} <b>. mim:</b>
<a name="replay"></a>    <b>predict yhatse, stdp</b> {p_end} Replay of estimation results [advanced]
    {pstd} Multiple-imputation estimates may be replayed by simply typing <b>mim</b>
    at the command line. If the estimates for a given imputed dataset have
    previously been called up using the <b>j(</b><i>#</i><b>)</b> option, the overall (Rubin's
    rules) estimates may be re-displayed by typing <b>mim, storebv</b> or <b>mim,</b>
    <b>clearbv</b>. A <b>level(</b><i>#</i><b>)</b> option and any <b>eform</b> options supported by <i>command</i> may
    be specified during replay.  {phang} <b>. use mymimdataset2, clear</b> {p_end}
    {phang} <b>. mim: logit y x1 x2</b> {p_end} {phang} <b>. mim, or l(90)</b> {p_end}
    {pstd} Multiple-imputation estimates may be copied into <b>e(b)</b>, <b>e(V)</b> etc.
    by specifying the <b>storebv</b> option during replay. Note that use of
    multiple-imputation estimates in this way is at the user's descretion,
    and validity of the results is not guaranteed. In particular, forcing the
    multiple-imputation estimates into <b>e(b)</b> and <b>e(V)</b> allows application of a
    Stata post-estimation command directly to the multiple-imputation
    estimates. While this may be valid in specific cases, it is certainly not
    valid in general (see Post-estimation for additional comments).  {phang}
    <b>. mim, storebv</b> {p_end} {pstd} (Note that the <b>storebv</b> option may also be
    specified during model fitting.) {pstd} Alternatively, by specifying the
    <b>j(</b><i>#</i><b>)</b> option of <b>mim</b>, the estimates corresponding to the application of
    <i>command</i> to one of the individual imputed datasets are copied into their
    usual place in <b>e()</b> (that is, into <b>e(b)</b>, <b>e(V)</b> etc.). <i>command</i> can also be
    replayed directly in this situation, for example {phang} <b>. mim: logit y</b>
    <b>x1 x2</b> {p_end} {phang} <b>. mim, j(1)</b> {p_end} {phang} <b>. logit, or</b> {p_end}
    {pstd} displays the estimated odds ratios for imputation #1.  {pstd} The
    facility to replay individual estimates has been incorporated with
    extensibility in mind, particularly with regard to post-estimation. The
    most likely application is to loop over the individual estimates,
    replaying and capturing necessary quantities from each set of results in
    turn, and then combining these in some way, where the standard approach
    for simple scalar estimation would be to use Rubin's rules.  {phang} <b>.</b>
    <b>use mymimdataset2, clear</b> {p_end} {phang} <b>. mim: logit y x1 x2</b> {p_end}
    {phang} <b>. local levels `"`e(MIM_levels)'"'</b> {p_end} {phang} <b>. foreach j of</b>
    <b>local levels {</b> {p_end} {phang} <b>.    quietly mim, j(`j')</b> {p_end} {phang} <b>.</b>
    <b>   </b><i>... apply some post-estimation command or capture some stored results</i>
    <i>here ...</i>  {p_end} {phang} <b>. }</b> {p_end} {phang} <b>. </b><i>combine results from</i>
    <i>individual estimations using Rubin's rules ...</i>  {p_end} {pstd} Finally,
    to avoid inadvertent application of a Stata post-estimation command to
    estimates copied into <b>e(b)</b>, <b>e(V)</b> etc. using either the <b>j(</b><i>#</i><b>)</b> or <b>storebv</b>
    option, the <b>clearbv</b> option is provided to allow one to clear these
    estimates when finished (without losing the multiple imputation estimates
    from memory). It is recommended always to make use of this facility.
<a name="utility"></a>    {phang} <b>. mim, clearbv</b> {p_end} Utility commands {pstd} The <b>check</b> command
    provides a detailed integrity check of a multiply imputed dataset in
    stacked format. The main checks are that non-missing values must be
    constant across imputed datasets and that all missing values must have
    been imputed. Note that the utility commands are only applicable when the
    original dataset with missing values has been included in the stacked
    dataset (see MIM dataset format).  {phang} <b>. use mymimdataset12, clear</b>
    {p_end} {phang} <b>. mim: check</b> {p_end} {phang} Alternatively, the check can
    be restricted to selected variables.  {phang} <b>. mim: check x1 x2 x3 x4 x5</b>
    {p_end} {pstd} The <b>genmiss</b> command generates a missing indicator variable
    for a specified variable.  {phang} <b>. mim: genmiss x1</b> {p_end} {pstd} In
    this case the generated indicator variable is called <b>_mim_x1</b> (and in
<a name="combine_estimates"></a>    general the naming convention used is to prefix <i>varname</i> with <i>_mim_</i>).
    Combining estimates using Rubin's rules {pstd} Some simple examples of
    <b>mim, category(combine)</b> may help to clarify how to use this powerful
    facility. One small point to note: the degrees of freedom used in
    calculating the t-statistic for confidence intervals are slightly larger
    according to <b>mim, category(combine)</b> than to <b>mim</b> when fitting regression
    models.  The result is that <b>mim, category(combine)</b> gives slightly
    narrower confidence intervals.  {pstd}<u>1. The mean of </u><b><u>x</u></b><u> with its SE and</u>
    <u>95% CI computed in different ways</u> {pmore}Using the default calculating
    tool (<b>statsby</b>):  {pmore}<b>. mim, cat(combine) est(_b[x]) se(_se[x]) : mean</b>
    <b>x</b>{p_end} {pmore}<b>. mim, cat(combine) est(_b[_cons]) se(_se[_cons]) :</b>
    <b>regress x</b>{p_end} {pmore}<b>. mim, cat(combine) est(r(mean))</b>
    <b>se(sqrt(r(Var)/r(N))) : ameans x</b>{p_end} {pmore}Note the use of an
    expression for the SE of the mean, namely <b>se(sqrt(r(Var)/r(N)))</b>. <b>statsby</b>
    allows this flexibility but <b>byvar</b> doesn't.  {pmore}Using the alternative
    calculating tool (<b>byvar</b>):  {pmore}<b>. mim, cat(combine) byvar est(b(x))</b>
    <b>se(se(x)) : mean x</b>{p_end} {pmore}<b>. mim, cat(combine) byvar est(b(_cons))</b>
    <b>se(se(_cons)) : regress x</b>{p_end} {pstd}<u>2. Area under a ROC curve</u> {pmore}
    The aim is to fit a logistic regression of <b>y</b> on <b>x1</b> and <b>x2</b>, and compute
    the AUROC (area under the ROC curve) for the resulting linear predictor
    in each imputation, combine the AUROC values across imputations and
    report the mean AUROC with its SE and 95% CI.  {pmore}<b>. mim: logit y x1</b>
    <b>x2</b>{p_end} {pmore}<b>. mim: predict xb</b>{p_end} {pmore}<b>. mim, cat(combine)</b>
    <b>est(r(area)) se(r(se)) : roctab y xb</b>{p_end} {pmore}<b>. mim, cat(combine)</b>
    <b>byvar est(r(area)) se(r(se)) : roctab y xb</b>{p_end} {pmore} We have noticed
    that <b>byvar</b> is substantially faster than <b>statsby</b> in some examples; in the
    <b>roctab</b> example just given, it takes one third of the time taken by
    <b>statsby</b>. The reason appears to be that <b>statsby</b> executes <i>stata_cmd</i> first
    for the entire dataset, then for each imputation, whereas <b>byvar</b> only does
    it for each imputation.  {pstd}<u>3. Using a sequence of Stata commands</u>
    {pmore} Note the feature of <b>byvar</b> that <i>stata_cmd</i> can be a sequence of
    Stata commands, separated by <b>@</b>. The feature is not available with
    <b>statsby</b>.  {pmore} For example, the mean AUROC in the second example above
    could be obtained by the following single command:  {pmore}<b>. mim,</b>
    <b>cat(combine) byvar est(r(area)) : logit y x1 x2 @ lroc, nograph</b>{p_end}
    {pmore} Since <b>lroc</b> does not return the SE of the AUROC, the <b>se()</b> option
    of <b>mim, category(combine)</b> is omitted and only the mean AUROC is reported.
    {pstd}<u>4. Combining estimates of a parameter from a multi-equation model</u>
    {pmore}This is purely a pedagogic example, since <b>mim</b> reports combined
    results for all parameters of a multi-equation model anyway:  {phang2}<b>.</b>
    <b>mim, cat(combine) est([ln_p]_b[_cons]) se([ln_p]_se[_cons]) : streg x1</b>
    <b>x2, distribution(weibull)</b>{p_end} Authors {pstd} John C. Galati &amp; John B.
    Carlin, Clinical Epidemiology &amp; Biostatistics Unit Murdoch Children’s
    Research Institute &amp; University of Melbourne{break}
    john.carlin@mcri.edu.au {pstd} Patrick Royston, MRC Clinical Trials Unit,
    London.{break} pr@ctu.mrc.ac.uk References {phang} Carlin JB, Galati JC
    and Royston P. 2008.  A new framework for managing and analyzing multiply
    imputed data in Stata.  <i>Stata Journal</i> 8(1): 49-67.  {phang} Carlin JB, Li
    N, Greenwood P and Coffey C. 2003.  Tools for analyzing multiple imputed
    datasets. <i>Stata Journal</i> 3(3): 226-244.  {phang} Efron B, Gong G. 1983. A
    leisurely look at the bootstrap, the jackknife, and cross-validation. <i>The</i>
    <i>American Statistician</i> 37: 36-48.  {phang} Li KH, Raghunathan TE, Rubin
    DB. 1991. Large-sample significance levels from multiply-imputed data
    using moment-based statistics and an F reference distribution.  <i>Journal</i>
    <i>of the American Statistical Association</i> 86: 1065-1073.  {phang} Royston
    P. 2004. Multiple imputation of missing values.  <i>Stata Journal</i> 4(3):
    227-241.  {phang} Royston P. 2005. Multiple imputation of missing values:
    update.  <i>Stata Journal</i> 5(2): 188-201.  {phang} Royston P. 2005. Multiple
    imputation of missing values:  update of ice. <i>Stata Journal</i> 5(4):
    527-536.  {phang} Royston P. 2007. Multiple imputation of missing values:
    further update of ice, with an emphasis on interval censoring. <i>Stata</i>
    <i>Journal</i> 7(4): 445–464.  {phang} Royston P, Carlin JB and White IR. 2009.
    Multiple imputation of missing values:  new features for mim. <i>Stata</i>
    <i>Journal</i> to appear.  Also see {pstd} Online:  help for mim, mimstack, mi
</pre>