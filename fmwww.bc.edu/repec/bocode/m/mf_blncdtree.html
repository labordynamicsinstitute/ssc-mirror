<pre>
<b>help mata blncdtree</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>blncdtree() -- Balanced search tree functions used by somersd</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <i>real matrix</i>    <b>blncdtree(</b><i>nnode</i><b>)</b>
<p>
        <i>void</i>           <b>_blncdtree(</b><i>tree</i><b>,</b> <i>imin</i><b>,</b> <i>imax</i><b>)</b>
<p>
                <i>tidot</i> = <b>tidottree(</b><i>x</i><b>,</b> <i>y</i> [ <b>,</b> <i>weight</i> [ <b>,</b> <i>xcen</i> [ <b>,</b> <i>ycen</i> ] ] ] <b>)</b>
<p>
                <i>tidot</i> = <b>tidot(</b><i>x</i><b>,</b> <i>y</i> [ <b>,</b> <i>weight</i> [ <b>,</b> <i>xcen</i> [ <b>,</b> <i>ycen</i> ] ] ] <b>)</b>
<p>
    where
<p>
                <i>nnode</i>:  <i>real scalar</i>
                 <i>tree</i>:  <i>real matrix</i>
                 <i>imin</i>:  <i>real scalar</i>
                 <i>imax</i>:  <i>real scalar</i>
                <i>tidot</i>:  <i>real colvector</i>
                    <i>x</i>:  <i>real colvector</i>
                    <i>y</i>:  <i>real colvector</i>
               <i>weight</i>:  <i>real colvector</i>
                 <i>xcen</i>:  <i>real colvector</i>
                 <i>ycen</i>:  <i>real colvector</i>
<p>
<p>
<b><u>Description</u></b>
<p>
    These functions are used by the <b>somersd</b> package to create balanced binary
    search trees and to calculate <i>tidot</i> vectors as defined below under
    <b>Remarks</b>.  Applications of these functions are discussed in the file
    <b>somersd.pdf</b>, which is distributed with the <b>somersd</b> package.
<p>
    <b>blncdtree(</b><i>nnode</i><b>)</b> returns a balanced binary search tree matrix,
    representing a balanced binary search tree whose nodes are the positive
    integer indices from 1 to <i>nnode</i>.  The result is defined as an <i>nnode</i> x 2
    matrix, whose <i>i</i>th row contains, in column 1, the left daughter index of
    the index <i>i</i> (or zero if <i>i</i> has no left daughter) and contains, in column
    2, the right daughter index of the index <i>i</i> (or zero if <i>i</i> has no right
    daughter).  A balanced binary search tree has the feature that, for any
    index <i>i</i>, the numbers of indices in the left and right subtrees of <i>i</i>
    differ by no more than one.  The root node of the returned balanced
    binary search tree matrix is the index given by the Mata expresstion
    <b>trunc((1+</b><i>nnode</i><b>)/2)</b>.
<p>
    <b>_blncdtree(</b><i>tree</i><b>,</b> <i>imin</i><b>,</b> <i>imax</i><b>)</b> inputs an existing matrix in <i>tree</i> and
    reassigns columns 1 and 2 of rows <i>imin</i> to <i>imax</i> of <i>tree</i>, so that these
    rows define a balanced binary search tree whose nodes are the row indices
    <i>i</i> such that <i>imin</i> &lt;= <i>i</i> &lt;= <i>imax</i>.  The root node of this search tree is the
    index given by the Mata expression <b>trunc((</b><i>imin</i><b>+</b><i>imax</i><b>)/2)</b>.  <b>blncdtree()</b>
    works by calling <b>_blncdtree()</b>, which works by assigning daughter indices
    to the root node and then calling itself recursively to produce left and
    right subtrees for the root node.  <b>_blncdtree()</b> is a fast program that
    performs no conformability or consistency checks, although it will abort
    if the matrix <i>tree</i> has fewer than two columns.
<p>
    <b>tidottree(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>weight</i><b>,</b> <i>xcen</i><b>,</b> <i>ycen</i><b>)</b> inputs a vector of X values in <i>x</i> and
    a parallel vector of Y values in <i>y</i>, and, optionally, other parallel
    vectors in <i>weight</i>, <i>xcen</i>, and <i>ycen</i>, containing, respectively, the weights,
    the censorship indicators for <i>x</i>, and the censorship indicators for <i>y</i>.  A
    censorship indicator value is interpreted as implying left-censorship if
    negative, right-censorship if positive, and noncensorship if zero.
    <b>tidottree()</b> assumes that <i>weight</i> is a vector of ones and that <i>xcen</i> and
    <i>ycen</i> are vectors of zeros, if these arguments are not provided by the
    user.  <b>tidottree()</b> returns, as output, a new vector <i>tidot</i>, parallel to
    the input vectors, which will contain the weighted sums of
    concordance-discordance differences corresponding to the input vectors,
    assuming that the data matrix defined by these input vectors is sorted in
    ascending order of <i>x</i>.  <b>tidottree()</b> performs no checks that the input data
    matrix is indeed sorted by <i>x</i>.  However, <b>tidottree()</b> uses a search tree
    algorithm, which calculates the <i>tidot</i> values in a time proportional to
    <i>N</i><b>*log(</b><i>N</i><b>)</b>. It creates the search tree by calling <b>blncdtree()</b>.
<p>
    <b>tidot(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>weight</i><b>,</b> <i>xcen</i><b>,</b> <i>ycen</i><b>)</b> inputs the same vectors as <b>tidottree()</b>
    and returns the same output vector <i>tidot</i>, which in this case contains
    concordance-discordance totals whether or not the input data matrix is
    sorted.  However, <b>tidot()</b> does not use the search tree algorithm and
    therefore requires a time proportional to the square of <i>N</i>.  <b>tidot()</b> is
    therefore less efficient than <b>tidottree()</b> for large datasets, even after
    accounting for the time taken to sort the dataset before calling
    <b>tidottree()</b>.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    The vector <i>tidot</i> calculated by <b>tidottree</b> and <b>tidot</b> is defined as follows.
    For scalars <i>u</i>, <i>p</i>, <i>v</i>, and <i>q</i>, define the function
<p>
                csign(<i>u</i>,<i>p</i>,<i>v</i>,<i>q</i>)
<p>
    as 1 if <i>u</i>&gt;<i>v</i> and <i>p</i>&gt;=0&gt;=<i>q</i>, -1 if <i>u</i>&lt;<i>v</i> and <i>p</i>&lt;=0&lt;=<i>q</i>, and 0 otherwise. For row
    indices <i>i</i> and <i>j</i>, define
<p>
                <i>T</i>_<i>ij</i> = csign(<i>x_i</i>,<i>xcen_i</i>,<i>x_j</i>,<i>xcen_j</i>) *
                  csign(<i>y_i</i>,<i>ycen_i</i>,<i>y_j</i>,<i>ycen_j</i>)
<p>
    as the concordance-discordance difference between rows <i>i</i> and <i>j</i> of the
    input data vectors.  Then the vector <i>tidot</i>, returned by <b>tidottree</b> or
    <b>tidot</b>, is defined by
<p>
                          <i>N</i>
                <i>tidot_i</i> = Sum <i>weight_j</i> * <i>T</i>_<i>ij</i>
                          <i>j=1</i>
<p>
    for each index <i>i</i>. The function <b>tidot()</b> calculates <i>tidot</i> by calculating
    all the <i>T</i>_<i>ij</i> and summing them, taking a time asymptotically proportional
    to the square of <i>N</i>.  The function <b>tidottree()</b> uses a search tree
    algorithm to calculate <i>tidot</i> in a time asymptotically proportional to
    <i>N</i><b>*log(</b><i>N</i><b>)</b>.  The algorithm used by <b>tidottree()</b> is a more advanced version
    of the one presented in Newson (2006) and assumes that the input data
    vectors are sorted in ascending order of the values of <i>x</i>.  <b>tidottree()</b>
    calls <b>blncdtree()</b> to create a search tree with one row for each value of
    <i>y</i> and uses this search tree to calculate <i>tidot</i> without calculating the
    individual <i>T</i>_<i>ij</i>.
<p>
    Applications of these functions are discussed in the manual <b>somersd.pdf</b>,
    which is distributed with the <b>somersd</b> package as an ancillary file.
    Balanced binary search trees are discussed in Wirth (1976).
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>blncdtree(</b><i>nnode</i><b>)</b>:
            <i>nnode</i>:  1 <i>x</i> 1
<p>
    <b>_blncdtree(</b><i>tree</i><b>,</b> <i>imin</i><b>,</b> <i>imax</i><b>)</b>:
             <i>tree</i>:  <i>M x K</i> where <i>K</i> &gt;= 2
             <i>imin</i>:  1 <i>x</i> 1
             <i>imax</i>:  1 <i>x</i> 1
<p>
    <b>tidottree(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>weight</i><b>,</b> <i>xcen</i><b>,</b> <i>ycen</i><b>)</b>:
                <i>x</i>:  <i>N x</i> 1
                <i>y</i>:  <i>N x</i> 1
           <i>weight</i>:  <i>N x</i> 1
             <i>xcen</i>:  <i>N x</i> 1
             <i>ycen</i>:  <i>N x</i> 1
<p>
    <b>tidot(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>weight</i><b>,</b> <i>xcen</i><b>,</b> <i>ycen</i><b>)</b>:
                <i>x</i>:  <i>N x</i> 1
                <i>y</i>:  <i>N x</i> 1
           <i>weight</i>:  <i>N x</i> 1
             <i>xcen</i>:  <i>N x</i> 1
             <i>ycen</i>:  <i>N x</i> 1
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    <b>blncdtree(</b><i>nnode</i><b>)</b> aborts with error if <i>nnode</i> &lt; 0.
<p>
    <b>_blncdtree(</b><i>tree</i><b>,</b> <i>imin</i><b>,</b> <i>imax</i><b>)</b> aborts with error if <b>cols(</b><i>tree</i><b>)</b> &lt; 2.
<p>
    <b>blncdtree(0)</b> can return a 0 <i>x</i> 2 result.
<p>
<p>
<b><u>Source code</u></b>
<p>
    blncdtree.mata, _blncdtree.mata, tidottree.mata, tidot.mata
<p>
<p>
<b><u>Author</u></b>
<p>
    Roger Newson, Imperial College London, UK.
    Email: r.newson@imperial.ac.uk
<p>
<p>
<b><u>References</u></b>
<p>
    Newson, R. 2006. Efficient calculation of jackknife confidence intervals
        for rank statistics.  <i>Journal of Statistical Software</i> 15: 1-10.
<p>
    Wirth, N. 1976. <i>Algorithms + Data Structures = Programs</i>. Englewood
        Cliffs, NJ: Prentice-Hall.
<p>
<p>
<b><u>Also see</u></b>
<p>
    Manual:  <b>[M-0] intro</b>
<p>
    Online:  <b>mata</b>,
             <b>somersd</b> (if installed)
</pre>