<pre>
<p>
<b><u>Title</u></b>
<p>
    <b>integrate()</b> -- Numerical integration of Mata functions
<p>
<a name="syntax"></a><b><u>Syntax</u></b>
<p>
    <i>real scalar</i> <b>integrate(</b><i>&amp;function()</i><b>,</b> <i>real scalar lower</i><b>,</b><i> real scalar upper</i>
        |<b>,</b><i> real scalar quadpts</i><b>,</b><i> real rowvector xarg</i><b>)</b>
<p>
<p>
    where
<p>
       <i>&amp;function()</i> is the function that is integrated, the first argument of
           this function will be the unit of integraion.
<p>
       <i>xarg</i> is an optional argument that is passed to the integrand.
<p>
       <i>lower</i> is the lower limit of the integral, a "." value represents
           -infinity
<p>
       <i>upper</i> is the upper limit of the integral, a "." value represents
           +infinity
<p>
       <i>quadpts</i> specifies the number of quadrature points used in the
           numerical integration; the default is 60.
<p>
<a name="description"></a><b><u>Description</u></b>
<p>
    <b>integrate</b> is an implementation of three numerical integration algorithms:
    Gauss-Legendre quadrature; Gauss-Hermite quadrature ; and Gauss-Laguerre.
    Gauss-Legendre quadrature is used for the definite integrals,
    Gauss-Hermite quadrature is used for the indefinite integral between
    -infinity and +infinity; and Gauss-Laguerre quadrature is used for the
    indefinite integral is between 0 and +infinity. Any limits can be chosen
    and the command will select a combination of quadrature techniques to
    calculate the result. The current command does not attempt to look at
    numerical errors but the user can alter the number of quadrature points
    to inspect any numerical instabilities.
<p>
    The number of quadrature points can be chosen to be any number above 1
    but the larger this number the slower the algorithm.  There is no upper
    limit because the quadrature points are chosen by calculating the
    eigenvalues and eigenvectors of a companion matrix.
<p>
<a name="examples"></a><b><u>Examples</u></b>
<p>
    Below we use the integrate() function to evaluate the integration of x
    between -1 and 1:
<p>
<p>
<b>real rowvector f1(real rowvector x)</b>
<b>{</b>
<b>  return(x)</b>
<b>}</b>
<p>
<p>
    Then to integrate this function type
<p>
<p>
<b>: integrate(&amp;f1(), -1, 1)</b>
<b>2.27336e-15</b>
<p>
<p>
    The analytical solution is 0 and given this is a numerical evaluation the
    answer is a very small number. In fact this accuracy cannot be improved
    by increasing the quadrature points as this is the accuracy of adding
    numbers.
<p>
    The integrate function can handle double integrals but will become
    increasingly more computer intensive with each additional integral.
    Double integration will square the number of operations. As an example
    integrate the function<b> x+y</b> with respect to x and then y over the unit
    square.
<p>
<p>
<b>real rowvector fin(real rowvector x, real rowvector y)</b>
<b>{</b>
<b>  return(x:+y)</b>
<b>}</b>
<b>real rowvector fout(real rowvector y)</b>
<b>{</b>
<b>  for(i=1; i&lt;=cols(y);i++) {</b>
<b>    if (i==1) f=integrate(&amp;fin(), -1, 1, 40, y[i])</b>
<b>    else f = f, integrate(&amp;fin(), -1, 1, 40, y[i])</b>
<b>  }</b>
<b>  return(f)</b>
<b>}</b>
<p>
<p>
    Note that the integrate function <b>requires</b> the integrand to return a
    rowvector, however, integrate() only returns a real scalar. The function
    fout() above loops over the elements of y and produces the integration
    with respect to x for each value of y and then returns these multiple
    elements as a rowvector. Note that because fin() requires two arguments
    the integrate() function requires five arguments including the number of
    quadrature points specified as 40.  To evaluate the integral type the
    following
<p>
<p>
<b>: integrate(&amp;fout(), -1, 1)</b>
<b>  -1.14925e-16</b>
<p>
<p>
    Again the answer is very close to 0.
<p>
    The last example is one where the upper limit of the inner integral is a
    function of y. The integral to be evaluates is the integration from 0 to
    2 with respect to y of the integral from 0 to y^2 of 6xy with respect to
    x. The example follows the same as the first double integral with the
    exception in the fout2() function that the upper limit is y[i]^2.
<p>
<p>
<b>real rowvector fin2(real rowvector x, real rowvector y)</b>
<b>{</b>
<b>  return(6:*x:*y)</b>
<b>}</b>
<b>real rowvector fout2(real rowvector y)</b>
<b>{</b>
<b>  for(i=1; i&lt;=cols(y);i++) {</b>
<b>    if (i==1) f=integrate(&amp;fin2(), 0, y[i]^2, 40, y[i])</b>
<b>    else f = f, integrate(&amp;fin2(), 0, y[i]^2, 40, y[i])</b>
<b>  }</b>
<b>  return(f)</b>
<b>}</b>
<p>
<p>
    This example was chosen because it is easy to confirm analytically that
    the answer is 32. The following command shows that the integrate gets the
    correct answer
<p>
<p>
<b>: integrate(&amp;fout2(), 0, 2)</b>
<b>  32</b>
<p>
<p>
<p>
<b><u>Author</u></b>
<p>
Adrian Mander, MRC Biostatistics Unit, Cambridge, UK.
<p>
Email adrian.mander@mrc-bsu.cam.ac.uk
<p>
</pre>