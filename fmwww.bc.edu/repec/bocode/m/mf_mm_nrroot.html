<pre>
<b>help mata mm_nrroot()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>mm_nrroot() -- Newton-Raphson univariate zero (root) finder</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <i>rc</i> = <b>mm_nrroot(</b><i>x</i><b>,</b> <i>fdf</i> [<b>,</b> <i>tol</i><b>,</b> <i>itr</i><b>,</b> <i>...</i>]<b>)</b>
<p>
    where
<p>
           <i>rc</i>:  the return code; <i>rc</i>!=0 indicates that no valid solution has
                been found
<p>
            <i>x</i>:  <i>real scalar</i> containing initial guess; <i>x</i> will be replaced by a
                <i>real scalar</i> containing solution
<p>
          <i>fdf</i>:  <i>pointer scalar</i> containing address of function supplying the
                function value and the first derivative; usually this is
                coded <b>&amp;</b><i>funcname</i><b>()</b>
<p>
          <i>tol</i>:  <i>real scalar</i> specifying acceptable tolerance for the root
                estimate (default is <i>tol</i>=0 to find the root as accurate as
                possible)
<p>
          <i>itr</i>:  <i>real scalar</i> specifying the maximum number of iterations
                (default is <i>itr</i>=1000)
<p>
          <i>...</i>:  up to 10 additional arguments to pass on to function <i>fdf</i>
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>mm_nrroot()</b> uses the Newton-Raphson method to search for the root of a
    function with respect to its first argument.  That is, <b>mm_nrroot()</b>
    approximates the value <i>x</i> for which the function evaluates to zero. The
    accuracy of the approximation is 4e+4*epsilon(<i>x</i>) + <i>tol</i>.
<p>
    <b>mm_nrroot()</b> stores the found solution in <i>x</i> and issues return code <i>rc</i>.
    Possible return codes are:
<p>
         0: everything went well
<p>
         1: convergence has not been reached within the maximum number of
            iterations; <i>x</i> will contain the current approximation
<p>
    <b>mm_nrroot()</b> is based on the example given in Press et al. (1992:365-366).
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Example:
<p>
        : function myfunc(x, a) {
        &gt;         fn = x^2 - a
        &gt;         df = 2*x
        &gt;         return(fn, df)
        &gt; }
<p>
        : a = 2/3
        
        : mm_nrroot(x=1, &amp;myfunc(), 0, 1000, a)
          0
<p>
        : x
          .8164965809
<p>
        : mm_nrroot(x=1, &amp;myfunc(), 0.01, 1000, a)
          0
<p>
        : x
          .8164965986
<p>
        : sqrt(a)
          .8164965809
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>mm_nrroot(</b><i>x</i><b>,</b> <i>fdf</i><b>,</b> <i>tol</i><b>,</b> <i>itr</i><b>,</b> <i>...</i><b>)</b>:
           <i>x</i>:  1 <i>x</i> 1
         <i>fdf</i>:  1 <i>x</i> 1
         <i>tol</i>:  1 <i>x</i> 1
         <i>itr</i>:  1 <i>x</i> 1
         <i>...</i>:  (depending on function <i>fdf</i>)
      <i>result</i>:  1 <i>x</i> 1
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    <i>x</i> will be set to missing if the function value or the derivative
    evaluates to missing at some point in the algorithm.
<p>
<p>
<b><u>Source code</u></b>
<p>
    mm_nrroot.mata
<p>
<p>
<b><u>References</u></b>
<p>
    Press, William H., Saul A. Teukolsky, William T. Vetterling, Brian P.
        Flannery (1992). Numerical Recipes in C. The Art of Scientific
        Computing. Second Edition. Cambridge University Press.  
        http://www.numerical-recipes.com/
<p>
<p>
<b><u>Author</u></b>
<p>
    Ben Jann, ETH Zurich, jann@soz.gess.ethz.ch
<p>
<p>
<b><u>Also see</u></b>
<p>
</pre>