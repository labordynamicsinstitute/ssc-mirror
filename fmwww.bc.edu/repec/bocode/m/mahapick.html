<pre>
<p>
-------------------------------------------------------------------------------
help for <b>mahapick</b>
-------------------------------------------------------------------------------
<p>
<b><u>Select matching observations based on a Mahalanobis scoring</u></b>
<p>
        <b>mahapick</b> <i>varlist</i> [<i>weight</i>] <b>, idvar(</b><i>idvarname</i><b>)</b> <b>treated(</b><i>treatedvar</i><b>)</b> [
                 <b>pickids(</b><i>pickidvars</i><b>)</b> <b>genfile(</b><i>filename</i><b>)</b> <b>replace</b>
                 <b>prime_id(</b><i>prime_id_var</i><b>)</b> <b>matchnum(</b><i>matchnum_var</i><b>)</b> <b>nummatches(</b><i>#</i><b>)</b>
                 <b>full</b> <b>matchon(</b><i>matchonvars</i><b>) sliceby(</b><i>slicebyvars</i><b>)</b> <b>clear fast</b>
                 <b>score</b> <b>scorevar(</b><i>scorevarname</i><b>)</b> <b>all</b> <b><u>unsq</u></b><b>uared</b> <b><u>eucl</u></b><b>idean</b>
                 <b><u>disp</u></b><b>lay(</b><i>display_options</i><b>)</b> <b>float</b> <b><u>nocovtrlim</u></b><b>itation</b> ]
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>mahapick</b> seeks matching observations for a set of "treated" observations,
    using a Mahalanobis distance measure which it calculates.
<p>
    The "treated" observations are the ones for which you are seeking
    matches; the others, the non-treated, form the pool of potential matches
    (or "control" observations).  (The use of the term "treated" comes from
    the study of medical treatments.)  Both the treated and non-treated
    observations are expected to be present together in one dataset,
    currently in memory. The treated observations are identified by
    <i>treatedvar</i>.
<p>
    For each treated observation, the closest matching non-treated
    observation(s) will be chosen, according to the calculated distance
    measure, and subject to the constraints of <b>matchon(</b><i>matchonvars</i><b>)</b> if that
    option is used. The selection of matches is done independently for each
    treated observation; a given control abservation may appear as a match
    for more than one treated observation.  (But, of course, matched control
    observations are unique within the set selected for any particular
    treated observation, if multiple matches are chosen.)
<p>
           --------------------------------------------------------------------
            <b>technical note:</b> Choosing unique matches is a beyond the
            scope of what <b>mahapick</b> was designed for, and involves a
            multitude of complex issues.  However, users can take
            the output of <b>mahapick</b> and perform further processing
            to arrive at a uniquely-chosen set.  See the <b>score</b> and
            <b>all</b> options for more remarks about this topic. See also
            mahascores.
<p>
            Users desiring a unique selection based on a
            randomization process should see mahaselectunique.
           --------------------------------------------------------------------
<p>
    <i>varlist</i> (the "covariates") is a set of numeric variables on which to
    build the distance measure - the Mahalanobis score. For each pair of
    observations, the distance measure (or score) is the matrix product d'Xd,
    where d is a vector of differences in the set of variables, and X is the
    inverse of the covariance matrix of <i>varlist</i>.  If i and j are indices of
    two observations, then d = (v1[i]-v1[j] \ v2[i]-v2[j] \ ... \
    vn[i]-vn[j]), where v1 v2 ... vn are the variables of <i>varlist</i>.
<p>
    Thus, the score is the sum of all the possible products of pairs of
    elements of d, weighted by corresponding elements of X.  See mahascore
    for a further explanation of this. Note that the result is the square of
    what is properly the Mahalanobis distance, but this distinction should
    have no effect on the selection of closest matches (lowest scores). The
    <b>unsquared</b> option will cause the scores to be the proper unsquared values.
<p>
    The covariaces are computed on the treated observations only, also
    limited to the set of observations that have all elements of <i>varlist</i>
    non-missing. I.e., the computation of covariances uses case-wise deletion
    when encountering missing values; the resulting values are potentially
    different from pair-wise covariances. This may seem like a limitation but
    it is appropriate; any treated observation with a missing value in one or
    more elements of <i>varlist</i> will get no matches, so it might as well be
    excluded at the outset.  See <b>nocovtrlimitation</b> for how to override the
    limitation to treated observations.
<p>
    Weights are allowed, but affect only the computation of the covariances.
<p>
    The variables of <i>varlist</i> should be of numeric significance - not
    categorical.  Any categorical variables should be replaced by a set of
    indicator variables.
<p>
<p>
<b><u>Required Options</u></b>
<p>
    <b>idvar(</b><i>idvarname</i><b>)</b> specifies an identifying variable.  It can be of any
    type, but it must be a single variable.  Thus, if the existing
    identifying scheme consists of multiple variables, you should find a way
    to combine them uniquely into a single variable.
<p>
    It is the user's responsibility to assure that <i>idvarname</i> uniquely
    identifies all observations, thus assuring a usable result.
<p>
    <b>treated(</b><i>treatedvar</i><b>)</b> specifies a numeric variable that distinguishes the
    treated observations.  Its values must be 0 or 1, where 1 indicates a
    treated observation.
<p>
<p>
<b><u>Semi-required Options</u></b>
<p>
    <b>pickids(</b><i>pickidvars</i><b>)</b> and <b>genfile(</b><i>filename</i><b>)</b> are two ways of preserving the
    results of the matching.  You must use one or the other, or both.
<p>
    <b>pickids(</b><i>pickidvars</i><b>)</b> specifies a set of one or more pre-existing variables
    to hold the id's of the matched observations.  It/they must be of the
    same type as <i>idvarname</i>, and must be filled with missing values ("" for
    strings) unless the <b>clear</b> option is specified.
<p>
    If <i>pickidvars</i> consists of more than one variable, then the first will get
    the best match, the second will get the second best match, and so on.
<p>
    <b>genfile(</b><i>filename</i><b>)</b> specifies a file into which to post the results.
<p>
    Note that <b>pickids(</b><i>pickidvars</i><b>)</b> puts the results into wide form within the
    current dataset, whereas <b>genfile(</b><i>filename</i><b>)</b> puts them into long form in a
    separate dataset.  (See reshape for a discussion of wide- versus
    long-shaped data.)
<p>
    Another difference between these methods is that with
    <b>pickids(</b><i>pickidvars</i><b>)</b>, it is up to the user to subsequently save the
    dataset - (or use it directly after its creation), whereas
    <b>genfile(</b><i>filename</i><b>)</b> writes the results to a separate file.
<p>
    If you create a (wide) dataset using <b>pickids(</b><i>pickidvars</i><b>)</b>, you can
    subsequently convert it to long form using stackids.
<p>
           --------------------------------------------------------------------
            <b>Technical note:</b> <b>pickids</b> was the original method
            provided; <b>genfile</b> was a later addition, and is probably
            more useful.
           --------------------------------------------------------------------
<p>
    If <b>genfile(</b><i>filename</i><b>)</b> is used, the resulting file is a Stata dataset with
    these variables:
<p>
        A "prime_id" variable of the same type as <i>idvarname</i>.  This holds the
          id of the treated observation for which matches are being found.
          The default name for this is _prime_id; it can be changed using the
          <b>prime_id</b> option.
<p>
        <i>idvarname</i> - the same name and type as in <b>idvar(</b><i>idvarname</i><b>)</b>.  This
          holds the ids of all observations - treated or matching control
          observations.
<p>
        A "matchnum" variable - an int to count up the series of matches for
          each treated observation.  The default name is _matchnum; it can be
          changed using the <b>matchnum</b> option.  This variable will range from 0
          to <i>#</i>.
<p>
        Optionally, a "score" variable, if the <b>score</b> option is specified.
          This holds the score - the distance measure between the treated
          (prime_id) observation and the given control observation.  See the
          <b>score</b> option for more about this.
<p>
    Within this file, there will be, for each treated observation...
<p>
        one observation representing the treated observation itself, with
          _matchnum=0, <i>idvarname</i>=_prime_id (or <i>prime_id_var</i>), and _score (or
          <i>scorevarname</i>) =0 (if <b>score</b> was specified); this is followed by...
<p>
        zero or more observations for the matches, with _matchnum=1, 2, ... ,
          <i>#</i>, and <i>idvarname</i> holding the id of the matched observations.  The
          first will get the best match, the second will get the second best
          match, and so on.
<p>
    For each treated observation, _prime_id (or <i>prime_id_var</i>) is a constant,
    equaling the id of the treated observation.  Note that <i>idvarname</i> =
    _prime_id for the observations where _matchnum=0.
<p>
    The notion of "best match" and "second best match", etc., is ambiguous
    when ties occur in the scoring.  In this case, the present sort order
    determines the choices.  See "identical scorings" under <u>Remarks</u> for more
    on this matter.
<p>
<p>
<b><u>Optional Options</u></b>
<p>
    <b>matchon(</b><i>matchonvars</i><b>)</b> imposes a restriction on the matching process, such
    that matches will be made only to observations that completely agree with
    the treated observation on the values in <i>matchonvars</i>.  In other words,
    the dataset is logically partitioned into subsets, as determined by the
    values in <i>matchonvars</i>, and matching will occur only within each
    partition.  (<i>matchonvars</i> may not include <i>treatedvar</i>.)
<p>
    It is best that the variables in <i>matchonvars</i> take a fairly small set of
    values; generally, only categorical variables are appropriate.  The types
    may be numeric or string.
<p>
    Do not confuse <i>matchonvars</i> with <i>varlist</i>.  <i>varlist</i> is a set of variables
    on which you want the matches to be "close"; <i>matchonvars</i> are variables on
    which you require perfect agreement.
<p>
    Missing values (including the extended missing values .a .b, etc.) in
    <i>matchonvars</i> are regarded as distinct.
<p>
    <b>sliceby(</b><i>slicebyvars</i><b>)</b> imposes the same kind of restriction as does
    <b>matchon()</b>, restricting the matching to stay within the subsets as
    determined by the values in <i>slicebyvars</i>.  However, <b>sliceby()</b> achieves the
    effect by different means, dividing the dataset into subsets, running the
    matching process separately on each subset, and reuniting them
    afterwards.  By contrast, <b>matchon()</b> (without <b>sliceby()</b>) merely limits the
    matches that are chosen.
<p>
    <b>sliceby(</b><i>slicebyvars</i><b>)</b> may only be specified if <b>matchon(</b><i>matchonvars</i><b>)</b> is
    also specified, and <i>slicebyvars</i> must be a subset of <i>matchonvars</i>.  Thus,
    <i>matchonvars</i> gives the full set of variables on which the matches must
    completely agree; <i>slicebyvars</i> specifies which of those variables will be
    the basis for actual slicing of the dataset to achieve the effect.  Of
    course, <i>slicebyvars</i> may equal <i>matchonvars</i>, but there may be some
    advantage to not doing that, as will be explained shortly.
<p>
    <b>sliceby()</b> can result in very significant speed improvements for large
    datasets.  But, of course, it is appropriate only where such a
    partitioning is an existing requirement of the desired matching
    operation.
<p>
    <b>sliceby()</b> achieves its speed advantage by reducing unnecessary sorting -
    at the expense of manipulating many intermediary files.  If the slices
    are exceedingly fine, the work involved in slicing may overshadow the
    advantages gained.  Thus, it may be better for the slices to be coarser
    than the matchon sets; i.e., use <b>sliceby()</b> to go part-way in dividing up
    the data, and use <b>matchon()</b> (with one or more additional variables) to
    complete the effect.
<p>
    Because <i>slicebyvars</i> is a subset of <i>matchonvars</i>, all remarks regrding
    <i>matchonvars</i> apply to <i>slicebyvars</i>.  In particular, they ought to be
    categorical, all types are allowed, and extended missing values are
    regarded as distinct.
<p>
           --------------------------------------------------------------------
            <b>Technical note:</b> it was not functionally necessary to
            require <i>slicebyvars</i> to be a subset of <i>matchonvars</i>.  But
            it makes for clearer syntax in that it reminds the user
            that slicing implicitly restricts the matching.  That
            is, regardless of that requirement, the use of
            <b>sliceby(</b><i>slicebyvars</i><b>)</b> implies the same effect as having
            <i>slicebyvars</i> among the <i>matchonvars</i>.
<p>
            Also note that the requirement that <i>slicebyvars</i> be a
            subset of <i>matchonvars</i> imposes the opposite relation
            between the corresponding subsets of the data; the data
            subsets corresponding to <i>matchonvars</i> are subsets of
            those corresponding to <i>slicebyvars</i>.) 
           --------------------------------------------------------------------
<p>
    Note that the covariance matrix and its inverse are precalculated on the
    whole set (of treated observations only), not on each slice or matchon
    set.  Thus, the use of <b>matchon(</b><i>matchonvars</i><b>)</b>, with or without
    <b>sliceby(</b><i>slicebyvars</i><b>)</b>, is not the same as if you were to run <b>mahapick</b> on
    each matchon set separately.
<p>
    <b>fast</b> applies only if <b>sliceby</b> is specified.  It causes <b>mahapick</b> to bypass
    the preserve and restore commands that surround the slicing operation,
    and thereby can save some time - at the expense of safety.  Without <b>fast</b>,
    if you press the Break key during the processing of the slices, the
    original dataset will be restored (though any matches made during the
    processing and recorded using <b>pickids()</b> will be lost).  With <b>fast</b>, if you
    press the Break key during the processing of the slices, you will be left
    with only the present slice.
<p>
    <b>nocovtrlimitation</b> specifies that the covariance computation not be
    limited to treated observations.
<p>
    <b>unsquared</b> modifies the score values to be the unsquared values, that is,
    the square roots of the default values. As mentioned elsewhere, the
    choice of squared or unsquared values ought to have no effect on the
    selection of matches. Thus, this should only affect the <b>genfile</b> option.
<p>
    <b>euclidean</b> specifies that the normalized Euclidean measure is to be used,
    rather than the true Mahalanobis measure - meaning that the off-diagonal
    elements of the covariance matrix are replaced with zeroes prior to
    inverting. The result is a measure that accounts for the scale of
    measurement in each variable of <i>varlist</i>, but ignores correlation between
    the variables. This is probably not desirable, given the advantages of
    the true Mahalanobis measure, but is provided as an alternative and for
    comparison to (or emulation of) earlier releases of mahascore and 
    mahapick. See notes under <u>Change History</u> as well as mahascore for more
    details on this matter.
<p>
    <b>display(</b><i>display_options</i><b>)</b> turns on the display of certain data structures
    used in the computation. If <i>display_options</i> contains <b>covar</b>, then the
    covariance matrix is listed; if is contains <b>invcov</b>, then the inverse
    covariance matrix is listed.  Any other content is ignored.
<p>
<p>
<b><u>Options for use with </u></b><b><u>pickids</u></b><b><u> only</u></b>
<p>
      <b>clear</b> indicates that if <i>pickidvars</i> are not all missing, then it is okay
      to go ahead and replace them with missing values at the start of the
      process.
<p>
<p>
<b><u>Options for use with </u></b><b><u>genfile</u></b><b><u> only</u></b>
<p>
      <b>replace</b> indicates that if <i>filename</i> already exists, then it is okay to
      replace it.
<p>
      <b>prime_id(</b><i>prime_id_var</i><b>)</b> allows you to specify the name for the prime_id
      variable.  The default name is _prime_id.
<p>
      <b>matchnum(</b><i>matchnum_var</i><b>)</b> allows you to specify the name for the matchnum
      variable.  The default name is _matchnum.
<p>
      <b>nummatches(</b><i>#</i><b>)</b> specifies how many matches to collect for each treated
      observation.  The default is 1.  Note that this corresponds to the
      number of <i>pickidvars</i> in the <b>pickids</b> option.
<p>
      <b>full</b> specifies that if matches cannot be made, then observations with
      missing values in <i>idvarname</i> are to be written so that there will always
      be <i>#</i> +1 observations (i.e., <i>#</i> "matches") for each treated observation.
      Suppose that you specify <b>nummatches(3)</b>, and that for a given treated
      observation, only one match can be found.  Then by default, only two
      observations will be written: one for the treated observation, and one
      for the match.  If <b>full</b> is specified, then two additional observations
      (with missing values in <i>idvarname</i>) will be written.
<p>
      <b>score</b> specifies that the file will contain an additional variable,
      holding the computed distance measure between the treated observation
      and the control observation.  The default name is _score, and its type
      is double.
<p>
      Note that to record all the distance measures between all treated
      observations and all other observations "in place" (using <b>pickids()</b>)
      would require adding as many new variables as there are control
      observations, which may or may not be practical. Such a structure would
      be in wide form; the <b>score</b> option captures that information, but puts
      it in long form, which may be more practical.  See also the remarks
      about mahascores, below.
<p>
      One possible use for this option is to allow users to supplement the
      results with an algorithm for further refinement of the matchings, for
      example, to reduce a set of candidate matches to a smaller set of
      unique matches, while minimizing the sum of all distance measures in
      the selected observations.
<p>
           --------------------------------------------------------------------
            <b>technical note:</b> Implementing such an algorithm may be
            difficult in Stata; it may be necessary to export the
            results for use by a program written in a
            general-purpose programming language. On the other
            hand, it may be feasible to do it in Mata.
           --------------------------------------------------------------------
<p>
      <b>scorevar(</b><i>scorevarname</i><b>)</b> allows you to specify the name of the score
      variable, if the <b>score</b> option is used.  The default name is _score.
<p>
      <b>all</b> signifies that all possible control observations will be included.
      <b>all</b> without <b>full</b> renders <b>nummatches(</b><i>#</i><b>)</b> irrelevant, and is equivalent to
      specifying <b>nummatches(</b><i>#</i><b>)</b>, where <i>#</i> is at least as large as the maximal
      number of available control observations (within matchon groups, if
      specified).
<p>
      <b>all</b> with <b>full</b> causes <i>#</i> to be the miniumum number of control observation
      records written for each treated observation (possibly with some filled
      with missing values to fill out the quota), but there will be more
      control observations written if they are available.
<p>
      Note that with <b>all</b>, the action of <b>mahapick</b> process is not so much a
      selecting, but rather a scoring and ranking process.  Also, the number
      of control matches written per treated observation can vary from one
      matchon group to another, if <b>matchon</b> was specified.
<p>
      The intent of the <b>all</b> option is that it would be used with <b>score</b>, by
      users who want to take the scores (of all potential pairings) and do
      their own selection algorithm. But if the user desires the score
      values, without the sorting or selecting of control observations, then
      it is recommended to use mahascores instead of mahapick. That provides
      a way to simply capture the score values for all pairs of observations
      (or possibly all treated-to-non-treated pairs), and should prove to be
      faster than mahapick.
<p>
      <b>float</b> specifies that the type for the score variable generated by
      <b>genfile()</b> will be float, rather than double.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    If any of these conditions occur, then the score will be missing, and no
    matches will be made for the given treated observation:
<p>
        Any covariate (variable in <i>varlist</i>) is missing in the treated
        observation.
<p>
        Any of the variances are missing or zero (this would affect the whole
        set).  (You can automatically avoid this by the use of the <b>omitmiszer</b>
        option.)
<p>
    In addition, if any covariate is missing in a control observation, then
    that observation is excluded from consideration.
<p>
    It may happen that no matchable control observations are found for a
    given treated observation, and no match will be assigned.  More
    generally, there may be fewer than <i>#</i> (or fewer than the number of
    variables in <i>pickidvars</i>) matchable control observations.  For example, if
    you have <b>nummatches(3)</b> (or three <i>pickidvars</i>), and only two eligible
    matches are found for a given treated observation, then, only two matches
    will be recorded in <i>filename</i> (or only the first two of the <i>pickidvars</i>
    will be assigned) for that observation.
<p>
    Any of these situations are unlikely to occur if the pool of control
    observations is large - interpreted within each matchon group if
    <b>matchon()</b> is specified.
<p>
    There may be cases where identical scorings occur for several potential
    matches.  In this case, the existing sort order is used for breaking
    ties, taking the earlier-placed observations first (using a stable sort).
    Consequently, repeated runs will yield identical results, even if ties
    exist, provided that the initial sort order is kept the same.
<p>
    Identical scorings are less likely to occur if there are many variables
    in <i>varlist</i>, or if these variables take on many different values. When
    identical scorings occur, they usually are the result of identical values
    in <i>varlist</i> - including cases where <i>varlist</i> is the same for the treated
    and control observations (for a score of 0).
<p>
    Note that, while the processing involves sorting, the dataset is returned
    to its original sort order unless <b>sliceby(</b><i>slicebyvars</i><b>)</b> is specified, in
    which case, the order is that of a stable sort on <i>slicebyvars</i>.
<p>
    <b>mahapick</b> is rather noisy in its displayed output.
<p>
    This calls mahascore and covariancemat, other programs by the same
    author.
<p>
    It is up to the user to make use of the matches.  Generally, you will
    want to merge some "content" data onto the resulting set for analysis.
    If you use <b>genfile()</b> (or <b>pickids()</b>, followed by <b>stackids()</b>) your
    resulting set will be a "basis" in long form, with treated and matched
    observations together in the same dataset.  You will subsequently want to
    merge content data on to this, presumably using <i>idvarname</i> as the matching
    variable.  This is probably the most desirable form of the resulting data
    for analysis purposes.
<p>
    Presumably, <i>treatedvar</i> is an important variable in the analysis, but it
    may not be present in the basis set, if constructed as described above.
    You can recover it by including it in the merge, or you can reconstruct
    it by identifying observations where _matchnum==0.
<p>
    If you have used <b>pickids()</b> and are leaving the data in wide form, you
    would need to merge on the content data, once for the treated
    observation, and once for each pickid, with distinct variable names for
    the content data in each of these merges.  Such a data structure may be
    cumbersome, but it has the one advantage of directly embodying the
    connection between treated and matched observations - in case that is
    important to your planned analysis.  (For example, you can construct
    differences between the treated and matched observations.)
<p>
           --------------------------------------------------------------------
            <b>technical note:</b> If you have used <b>pickids()</b> (and not
            <b>genfile()</b>), but find that you prefer the results in
            long form, you can either rerun the match process using
            <b>genfile()</b>, or convert the results to long form using 
            stackids.  The latter option may be convenient if the
            matching process takes a lot of time.  (<b>stackids</b> is
            similar to reshape and stack, but includes provisions
            to preserve the correspondence between the treated and
            the matched observations.)
           --------------------------------------------------------------------
<p>
    One useful way of using <b>mahapick</b> is to take several more matches per
    treated observation than you actually expect to use.  That is, you
    specify a large <b>nummatches()</b> value (or a large set of <i>pickidvars</i>).  For
    example, if you want three matches per treated observation, you might
    collect, say, eight matches per treated observation (specifying
    <b>nummatches(8)</b>).  Then in subsequent analyses, using some code to
    pre-screen your data, you take the first (best) three "good" matches -
    good in the sense that they have no missing values in variables needed in
    the analysis.  (Those would be variables in the "content" data mentioned
    above, which are typically <i>not</i> among those used in the matching (i.e.,
    <i>varlist</i>).) The advantage of this is that, rather than filtering for
    observations with non-missing values in the content data before the
    match, you do it at the time you analyze the data.  In susbsequent
    analyses, you might adjust the set of variables involved, thereby
    potentially shifting the set of control observations to exclude.  But,
    given this setup, you will not need to rerun the match.  You can also
    have several analyses with different mixes of variables, each of which
    takes its own best set of matches.  The program screenmatches does this
    screening for you (with the data in long form).
<p>
    If the inverse covariance matrix is computed on a very small set of
    observations, it may not be valid and may yield strange results. It might
    fail to be positive semi-definite, and can yield negative measures.  (It
    may also cause the <b>unsquared</b> option to have a real effect on the choice
    of matches.)
<p>
    As it stands presently, there are no [<b>if</b> <i>exp</i>] or [<b>in</b> <i>range</i>] features
    provided.  They were not deemed essential when <b>mahapick</b> was first
    created, but could be added if there is a demand for them.
<p>
    See mahaselectunique for a further discussion of issues relating to the
    formulation of the covariate set and the quality of the scoring, as well
    as how that relates to unique selection.
<p>
<b><u>Examples</u></b>
<p>
    <b>. mahapick income age numkids, idvar(id0) genfile(myfile)</b> <b>nummatches(8)</b>
        <b>full</b> <b>treated(assisted)</b>
    <b>. mahapick income age numkids, idvar(id0) genfile(myfile)</b> <b>nummatches(8)</b>
        <b>full</b> <b>treated(assisted)</b> <b>matchon(sex region) sliceby(region)</b>
    <b>. mahapick income age numkids, idvar(id0) pickids(id1 id2 id3)</b>
        <b>treated(assisted)</b>
    <b>. mahapick income age numkids, idvar(id0) pickids(id1 id2 id3)</b>
        <b>treated(assisted)</b> <b>matchon(sex region)</b>
    <b>. mahapick income age numkids, idvar(id0) pickids(id1 id2 id3)</b>
        <b>treated(assisted)</b> <b>matchon(sex region) sliceby(region)</b>
<p>
<p>
<b><u>Change History</u></b>
<p>
    The 1Apr2008 release implements the full Mahalanobis measure.  Prior to
    that release, the normalized Euclidean measure was used, which is
    equivalent to the current version under the <b>euclidean</b> option.  Referring
    to the d vector mentioned under the description of <i>varlist</i>, the
    normalized Euclidean measure is the sum of the squares of the components
    of d, weighted by the inverse variance of each variable.
<p>
    The 1Apr2008 release eliminated the <b>common</b> and <b>omitmiszer</b> options, which
    were deemed as inappropriate for the changes to the program. Note that
    <b>common</b> was to limit variance computations to the set of common
    observations that have no missing values in <i>varlist</i>; the present method
    (for covariances) always imposes that limitation.
<p>
    The 1Apr2008 release added these options: <b>unsquared</b>, <b>euclidean</b>, <b>float</b>,
    <b>display()</b>, and <b>nocovtrlimitation</b>.
<p>
<p>
<b><u>Acknowledgement</u></b>
    The author wishes to thank Joseph Harkness, formerly of The Institute for
    Policy Studies at Johns Hopkins University for guidance in developing
    this program, as well as Heiko Giebler of Wissenschaftszentrum Berlin fur
    Sozialforschung GmbH, for suggesting further improvements.
<p>
<p>
<b><u>Author</u></b>
    David Kantor; initial development was done at The Institute for Policy
    Studies, Johns Hopkins University.  Email kantor.d@att.net if you observe
    any problems.
<p>
<b><u>Also See</u></b>
    mahascore, mahascores, mahascore2, covariancemat, variancemat, 
</pre>