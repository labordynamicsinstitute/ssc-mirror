<pre>
<b>help mata kdens()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>kdens() -- Univariate kernel density estimation</b>
<p>
<p>
<b><u>Contents</u></b>
<p>
    Information on functions (syntax, description, remarks, conformability,
    diagnostics) can be found below under the following headings:
<p>
        <i>Wrappers</i>
<p>
        <i>Elementary functions</i>
<p>
<p>
<b><u>Dependencies</u></b>
<p>
    <b>moremata</b> is required. Type
<p>
        . ssc describe moremata
<p>
<p>
<b><u>Methods and Formulas</u></b>
<p>
    See http://fmwww.bc.edu/RePEc/bocode/k/kdens.pdf.
<p>
<p>
<b><u>Source code</u></b>
<p>
    kdens.mata
<p>
<p>
<b><u>Author</u></b>
<p>
    Ben Jann, ETH Zurich, jann@soz.gess.ethz.ch
<p>
<p>
<b><u>Aknowledgements</u></b>
<p>
    Some of the code is loosely based on R code from the "KernSmooth" package
    (R port by Brian Ripley, S original by Matt Wand) and the "sm" package (R
    port by Brian Ripley, S original by Adrian W. Bowman and Adelchi
    Azzalini).
<p>
<p>
<b><u>Also see</u></b>
<p>
    Online:  help for <b>kdens</b>, <b>moremata</b>
<p>
<p>
<a name="s1"></a>-------------------------------------------------------------------------------
<b>Wrappers</b>
-------------------------------------------------------------------------------
<p>
<b><u>Syntax</u></b>
<p>
         <i>d =</i> <b>kdens(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i> [<b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>a</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i>]<b>)</b>
<p>
         <i>d =</i> <b>_kdens(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i> [<b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>a</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i>]<b>)</b>
<p>
         <i>v =</i> <b>kdens_var(</b><i>d</i><b>,</b> <i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i> [<b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i>]<b>)</b>
<p>
         <i>v =</i> <b>_kdens_var(</b><i>d</i><b>,</b> <i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i> [<b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i>]<b>)</b>
<p>
        <i>bw =</i> <b>kdens_bw(</b><i>x</i> [<b>,</b> <i>w</i><b>,</b> <i>method</i><b>,</b> <i>k</i><b>,</b> <i>m</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>ldpi</i>]<b>)</b>
<p>
         <i>g =</i> <b>kdens_grid(</b><i>x</i> [<b>,</b> <i>w</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>m</i><b>,</b> <i>min</i><b>,</b> <i>max</i>]<b>)</b>
<p>
<p>
    where
<p>
            <i>d</i>:  <i>real colvector</i> containing density estimate
<p>
            <i>v</i>:  <i>real colvector</i> containing variance estimate
<p>
           <i>bw</i>:  <i>real scalar</i> containing bandwidth; <b>kdens()</b> and <b>kdens_grid()</b>
                  may replace <i>bw</i> if it is too small
<p>
            <i>g</i>:  <i>real colvector</i> containing equally-spaced grid points at which
                  to estimate the density
<p>
            <i>x</i>:  <i>real colvector</i> containing data points
<p>
            <i>w</i>:  <i>real colvector</i> containing weights
<p>
       <i>method</i>:  <i>string scalar</i> containing <b>"silverman"</b> (default),
                  <b>"normalscale"</b>, <b>"oversmoothed"</b>, <b>"sjpi"</b>, or <b>"dpi"</b>
<p>
            <i>k</i>:  <i>string scalar</i> containing <b>"epanechnikov"</b>, <b>"epan2"</b> (default),
                  <b>"biweight"</b>, <b>"triweight"</b>, <b>"cosine"</b>, <b>"gaussian"</b>, <b>"parzen"</b>,
                  <b>"rectangle"</b> or <b>"triangle"</b>
<p>
            <i>a</i>:  <i>real scalar</i> specifying number of iterations for the adaptive
                  kernel density estimator (default 0)
<p>
           <i>pw</i>:  <i>real scalar</i> indicating that the weights are <b>pweight</b>s
                  (normalized to the number of observations)
<p>
            <i>m</i>:  <i>real scalar</i> containing size of evaluation grid (number of
                  evaluation points) (default is 512)
<p>
           <i>lb</i>:  <i>real scalar</i> indicating that the support of <i>x</i> is lower bounded
                  at <i>g</i>[1]
<p>
           <i>ub</i>:  <i>real scalar</i> indicating that the support of <i>x</i> is upper bounded
                  at <i>g</i>[rows(<i>g</i>)]
<p>
        <i>btype</i>:  <i>real scalar</i> specifying the method to be used for boundary
                  correction; <i>btype</i>==0: renormalization, <i>btype</i>==1:
                  reflection, <i>btype</i>==2: linear combination
<p>
           <i>ll</i>:  <i>real scalar</i> containing lower limit of support of <i>x</i>
<p>
           <i>ul</i>:  <i>real scalar</i> containing upper limit of support of <i>x</i>
<p>
         <i>ldpi</i>:  <i>real scalar</i> specifying the number of stages of functional
                  estimation for the <b>dpi</b> method (default is 2)
<p>
          <i>min</i>:  <i>real scalar</i> specifying minimum value of evaluation grid; will
                  be ignored if <i>min</i> is missing or larger than <b>min(x)</b>
<p>
          <i>max</i>:  <i>real scalar</i> specifying maximum value of evaluation grid; will
                  be ignored if <i>max</i> is missing or smaller than <b>max(x)</b>
<p>
         <i>lwbf</i>:  will be replaced by the local bandwidth factors in
                  [<b>_</b>]<b>kdens()</b>; <i>real colvector</i> containing local bandwidth
                  factors in [<b>_</b>]<b>kdens_var()</b>
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>kdens()</b> returns the binned approximation kernel density estimate of <i>x</i>
    using evaluation grid <i>g</i>. <i>g</i> must be a regular grid of equidistant points
    covering the whole range of <i>x</i>. Use <b>kdens_grid()</b> to produce <i>g</i>. The default
    kernel used by <b>kdens()</b> is the gaussian kernel function. Specify <i>k</i> as
    indicated above to use another kernel function. <i>bw</i> is the bandwidth. If
    <i>bw</i> is omitted, the optimal of Silverman is used. Note that <b>kdens()</b>
    imposes a minimum bandwidth (see help <b>kdens</b> for details). If <i>bw</i> is
    smaller than the minimum bandwidth, it is reset to this minimum. Specify
    <i>a</i> as an integer larger than zero to obtain the adaptive bandwidth kernel
    density, where <i>a</i> indicates the number of iterations applied to determine
    the local bandwidth factors. <b>kdens()</b> supports density estimation for
    bounded variables. Specify <i>lb</i>!=0 and <i>ub</i>!=0 to indicate that the support
    of <i>x</i> is bounded. The default method for estimation at the boundaries is
    the normalization method. Alternatively, <i>btype</i>==1 causes the reflection
    method to be used and <i>btype</i>==2 causes the linear combination method to be
    used. If specified, <i>lwbf</i> will be replaced by the local bandwidth factors
    (or set to 1 if <i>a</i>=0).
<p>
    <b>_kdens()</b> returns the exact kernel density estimate. <i>ll</i> and <i>ul</i> specify the
    lower and upper limits of the data support.
<p>
    <b>kdens_var()</b> returns asymptotic point-wise variance estimates for the
    binned approximation density estimate. Use <b>kdens_var()</b> after <b>kdens()</b>, but
    not after <b>_kdens()</b>. <i>pw</i>!=1 specifies that the weights <i>w</i> are (normalized)
    sampling weights. If <i>d</i> has been derived by the adaptive kernel density
    method (<i>a</i>&gt;=1 in <b>kdens()</b>), the local bandwidth factors, <i>lwbf</i>, should be
    provided to <b>kdens_var()</b>.
<p>
    <b>kdens_var()</b> returns asymptotic point-wise variance estimates for the
    exact density estimate. Use <b>_kdens_var()</b> after <b>_kdens()</b>, but not after
    <b>kdens()</b>.
<p>
    <b>kdens_bw()</b> returns an estimate of the "optimal" bandwidth given the data
    and kernel function. Available <i>method</i>s are <b>"silverman"</b> (optimal of
    Silverman; the default), <b>"normalscale"</b> (the normal scale rule),
    <b>"oversmoothed"</b> (the oversmoothed rule), <b>"sjpi"</b> (the Sheather-Jones
    plug-in estimate) and <b>"dpi"</b> (a variant of the Sheather-Jones plug-in
    estimate called the direct plug-in bandwidth estimate). If the <i>method</i> is
    <b>"sjpi"</b> or <b>"dpi"</b> you might want to set <i>m</i>, the number of evaluation points
    used to estimate the density functionals, and for bounded variables the
    lower and upper limits, <i>ll</i> and <i>ul</i>.  Furthermore, with the <b>"dpi"</b> method
    you may specify the the number of stages of functional estimation, <i>ldpi</i>
    (default is 2).
<p>
    <b>kdens_grid()</b> returns a grid of <i>m</i> equally-spaced points over the range of
    <i>x</i>. The default grid size is <i>m</i>=512. The default range of the grid is
    [min(<i>x</i>)-<i>bw</i>*tau, max(<i>x</i>)+<i>bw</i>*tau], where <i>bw</i> is the bandwidth and tau is the
    halfwidth of the support of kernel <i>k</i> (in the case of the gaussian kernel,
    tau is set to 3). Alternatively, if <i>min</i>&lt;=min(<i>x</i>) is specified, the lower
    limit of the grid is set to <i>min</i>. If .&gt;<i>max</i>&gt;=max(<i>x</i>) is specified, the upper
    limit of the grid is set to <i>max</i>. Note that, similar to <b>kdens()</b>,
    <b>kdens_grid()</b> imposes a minimum bandwidth and resets <i>bw</i> if it is too small
    (see above).
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Suppose, <b>x</b> is a data vector. To estimate the density of <i>x</i> using a
    gaussian kernel you could type, for example:
<p>
        : bw = kdens_bw(x, 1, "sjpi")
        : g  = kdens_grid(x, 1, bw)
        : d  = kdens(x, 1, g, bw)
        : v  = kdens_var(d, x, 1, g, bw)
<p>
    <b>g</b> and <b>d</b> could then be used, e.g., to plot the density function. <b>v</b> could
    be used to construct point-wise confidence intervals.
<p>
    If the adaptive estimator is used and the variance be estimated, the
    local bandwidth factors have to be passed to <b>kdens_var()</b>. Example:
<p>
        : bw = kdens_bw(x, 1, "sjpi")
        : g  = kdens_grid(x, 1, bw)
        : d  = kdens(x, 1, g, bw, "", 1, 0, 0, 0, l=.)
        : v  = kdens_var(d, x, 1, g, bw, "", 0, 0, 0, 0, l)
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>kdens(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>a</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i><b>)</b>,
    <b>_kdens(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>a</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i><b>)</b>,
    <b>kdens_var(</b><i>d</i><b>,</b> <i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i><b>)</b>,
    <b>_kdens_var(</b><i>d</i><b>,</b> <i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>,</b> <i>lbwf</i><b>)</b>,
    <b>kdens_grid(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>bw</i><b>,</b> <i>k</i><b>,</b> <i>m</i><b>,</b> <i>min</i><b>,</b> <i>max</i><b>)</b>:
        <i>result</i>:  <i>m x</i> 1
<p>
    <b>kdens_bw(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>method</i><b>,</b> <i>k</i><b>,</b> <i>m</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>ldpi</i><b>)</b>:
        <i>result</i>:  1 <i>x</i> 1
<p>
    where
<p>
             <i>x</i>:  <i>n x</i> 1
             <i>w</i>:  <i>n x</i> 1 or 1 <i>x</i> 1
             <i>g</i>:  <i>m x</i> 1
             <i>d</i>:  <i>m x</i> 1
            <i>bw</i>:  1 <i>x</i> 1
        <i>method</i>:  1 <i>x</i> 1
             <i>k</i>:  1 <i>x</i> 1
             <i>a</i>:  1 <i>x</i> 1
            <i>pw</i>:  1 <i>x</i> 1
             <i>m</i>:  1 <i>x</i> 1
            <i>lb</i>:  1 <i>x</i> 1
            <i>ub</i>:  1 <i>x</i> 1
         <i>btype</i>:  1 <i>x</i> 1
            <i>ll</i>:  1 <i>x</i> 1
            <i>ul</i>:  1 <i>x</i> 1
          <i>ldpi</i>:  1 <i>x</i> 1
           <i>min</i>:  1 <i>x</i> 1
           <i>max</i>:  1 <i>x</i> 1
          <i>lwbf</i>:  <i>n x</i> 1
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    <b>kdens()</b> and <b>kdens_var()</b> return invalid results if the grid <i>g</i> is not
    equally-spaced.
<p>
    <b>kdens_bw()</b> aborts with error if <i>ll</i>&gt;min(<i>x</i>) or <i>ul</i>&lt;max(<i>x</i>) and <i>method</i> is
    <b>"sjpi"</b> or <b>"dpi"</b>.  <b>_kdens()</b> and <b>_kdens_var()</b> abort with error if <i>ll</i>&gt;min(<i>x</i>)
    or <i>ul</i>&lt;max(<i>x</i>).
<p>
    The functions return invalid results if the data contain missing values.
<p>
    Weights are assumed to be normalized to the number of observations (i.e.
    sum of weights = number of observations).
<p>
<p>
<a name="s2"></a>-------------------------------------------------------------------------------
<b>Elementary functions</b>
-------------------------------------------------------------------------------
<p>
<b><u>Syntax</u></b>
<p>
<p>
        <i>real colvector</i> <b>kdens_gen(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i> [<b>,</b> <i>k</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i>]<b>)</b>
<p>
        <i>real colvector</i> <b>kdens_bin(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i> [<b>,</b> <i>k</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i>]<b>)</b>
<p>
        <i>real colvector</i> <b>kdens_dd(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i><b>,</b> <i>drv</i> [<b>,</b> <i>lb</i><b>,</b> <i>ub</i>]<b>)</b>
<p>
        <i>real colvector</i> <b>kdens_df(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i><b>,</b> <i>drv</i> [<b>,</b> <i>lb</i><b>,</b> <i>ub</i>]<b>)</b>
<p>
        <i>real colvector</i> <b>kdens_avar(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i><b>,</b> <i>d</i> [<b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i>]<b>)</b>
<p>
        <i>real colvector</i> <b>kdens_evar(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i><b>,</b> <i>d</i> [<b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i>]<b>)</b>
<p>
        <i>real scalar</i>    <b>kdens_bw_simple(</b><i>x</i><b>,</b> <i>w</i> [<b>,</b> <i>rule</i><b>,</b> <i>scale</i>]<b>)</b>
<p>
        <i>real scalar</i>    <b>kdens_bw_sjpi(</b><i>x</i><b>,</b> <i>w</i> [<b>,</b> <i>m</i><b>,</b> <i>scale</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i>]<b>)</b>
<p>
        <i>real scalar</i>    <b>kdens_bw_dpi(</b><i>x</i><b>,</b> <i>w</i> [<b>,</b> <i>m</i><b>,</b> <i>scale</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>ldpi</i>]<b>)</b>
<p>
        <i>real scalar</i>    <b>kdens_lbwf(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>d</i><b>)</b>
<p>
<p>
    where
<p>
            <i>x</i>:  <i>real colvector</i> containing data points
<p>
            <i>w</i>:  <i>real colvector</i> containing weights
<p>
            <i>g</i>:  <i>real colvector</i> containing grid points at which to estimate
                  the density
<p>
           <i>gc</i>:  <i>real colvector</i> containing grid counts
<p>
            <i>h</i>:  <i>real colvector</i> containing (local) bandwidth
<p>
            <i>d</i>:  <i>real colvector</i> containing preliminary density estimate
<p>
            <i>k</i>:  <i>string scalar</i> containing <b>"epanechnikov"</b>, <b>"epan2"</b> (default),
                  <b>"biweight"</b>, <b>"triweight"</b>, <b>"cosine"</b>, <b>"gaussian"</b>, <b>"parzen"</b>,
                  <b>"rectangle"</b> or <b>"triangle"</b>
<p>
          <i>drv</i>:  <i>real scalar</i> specifying the order of derivative
<p>
           <i>pw</i>:  <i>real scalar</i> indicating that the weights are <b>pweight</b>s
<p>
            <i>m</i>:  <i>real scalar</i> specifying the number of equally spaced grid
                  points (default: 401)
<p>
         <i>rule</i>:  <i>string scalar</i> containing <b>"silverman"</b> (default),
                  <b>"normalscale"</b>, or <b>"oversmoothed"</b>
<p>
        <i>scale</i>:  <i>string scalar</i> containing <b>"minim"</b> (default), <b>"stddev"</b>, <b>"iqr"</b>
<p>
           <i>lb</i>:  <i>real scalar</i> indicating that the support of <i>x</i> is lower bounded
                  at <i>g</i>[1]
<p>
           <i>ub</i>:  <i>real scalar</i> indicating that the support of <i>x</i> is upper bounded
                  at <i>g</i>[rows(<i>g</i>)]
<p>
        <i>btype</i>:  <i>real scalar</i> specifying the method to be used for boundary
                  correction; <i>btype</i>==0: renormalization, <i>btype</i>==1:
                  reflection, <i>btype</i>==2: linear combination
<p>
           <i>ll</i>:  <i>real scalar</i> containing lower boundary of support of <i>x</i>
<p>
           <i>ul</i>:  <i>real scalar</i> containing upper boundary of support of <i>x</i>
<p>
         <i>ldpi</i>:  <i>real scalar</i> specifying the number of stages of functional
                  estimation (default is 2)
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>kdens_gen()</b> returns the density estimate of <i>x</i> at the points <i>g</i> using
    bandwidth <i>h</i>. If <i>h</i> is a scalar, <b>kdens_gen()</b> returns a fixed bandwidth
    kernel density estimate. If <i>h</i> is vector, <b>kdens_gen()</b> returns an adaptive
    kernel density estimate. Furthermore, specify <i>ll</i>&lt;. and <i>ul</i>&lt;. if the
    support of <i>x</i> is bounded. The default method for estimation at the
    boundaries is the normalization method. Alternatively, <i>btype</i>==1 causes
    the reflection method to be used and <i>btype</i>==2 causes the linear
    combination method to be used.
<p>
    <b>kdens_bin()</b> returns a density estimate based on binned data. <i>g</i> contains a
    grid of equidistant evaluation points and <i>gc</i> contains the grid counts.
    Use <b>mm_makegrid()</b> and <b>mm_fastlinbin()</b> from the <b>moremata</b> package to
    produce <i>g</i> and <i>gc</i>. If possible, <b>kdens_bin()</b> computes the estimate as the
    convolution of fast Fourier transforms.
<p>
    <b>kdens_dd()</b> returns the <i>drv</i>th density derivative estimate based on binned
    data using the gaussian kernel function.  <b>kdens_dd()</b> is used by
    <b>kdens_df()</b>. <i>drv</i> should be a nonnegative integer. <b>kdens_dd()</b> supports
    bounded variables using the reflection method.
<p>
    <b>kdens_df()</b> returns a density functional estimate based on binned data
    using the gaussian kernel. <b>kdens_df()</b> is used by <b>kdens_bw_sjpi()</b> and
    <b>kdens_bw_dpi()</b>.  <i>drv</i> specifies the derivative in the functional and
    should be a nonnegative integer. <b>kdens_df()</b> supports bounded variables
    using the reflection method.
<p>
    <b>kdens_avar()</b> returns approximate point-wise variance estimates for the
    density estimate in <i>d</i>.
<p>
    <b>kdens_evar()</b> returns exact point-wise variance estimates for the density
    estimate in <i>d</i>.
<p>
    <b>kdens_bw_simple()</b> returns a quick and simple bandwidth estimate
    (standardized, see below). The available estimators are the optimal of
    Silverman (default), the normal scale rule, and the oversmoothed rule.
    The default estimator conforms to the automatic bandwidth selection in
    official Stata's <b>kdensity</b>. Use <i>scale</i> to determine the scale estimate that
    is used in bandwidth estimation. The default is to use the minimum of the
    standard deviation and the inter-quartile range/1.349.
<p>
    <b>kdens_bw_sjpi()</b> returns the Sheather-Jones plug-in bandwidth estimate
    (standardized, see below). <b>kdens_bw_sjpi()</b> supports bounded variables
    using the reflection method. If the Sheather-Jones plug-in estimate is
    larger than the oversmoothed bandwidth estimate (see above), the latter
    is returned (this may rarely happen with bounded variables). Missing is
    returned if the algorithm does not converge (for example, because the
    estimate is getting to small given the size of the evaluation grid).
<p>
    <b>kdens_bw_dpi()</b> returns a variant of the Sheather-Jones plug-in estimate
    called the direct plug-in bandwidth estimate (standardized, see below).
    <i>ldpi</i> in {0,1,...} specifies the number of stages of functional
    estimation. <i>level</i>=2 is the default. <b>kdens_bw_dpi()</b> supports bounded
    variables using the reflection method.
<p>
    Note that the bandwidth estimates returned by <b>kdens_bw_simple()</b>,
    <b>kdens_bw_sjpi()</b>, or <b>kdens_bw_dpi()</b> are standardized estimates. They
    should be multiplied by the kernel's canonical bandwidth before being
    used for density estimation. For example,
    <b>kdens_bw_sjpi(</b>...<b>)*mm_kdel0_epan2()</b> returns the Sheather-Jones plug-in
    bandwidth scaled for use with the <b>epan2</b> kernel.
<p>
    <b>kdens_lbwf()</b> returns the local bandwidth factors to be used for adaptive
    kernel density estimation based on a preliminary density estimate.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Suppose, <b>x</b> is the data vector (or the variable in the dataset) for which
    the density be estimated. The commands
<p>
        : h = kdens_bw_simple(x, 1) * mm_kdel0_gaussian()
        : g = mm_makegrid(x, 50, h)
        : d = kdens_gen(x, 1, g, h, "epanechnikov")
<p>
    produce a density estimate equivalent to
<p>
        . kdensity x
<p>
    Adaptive kernel density estimation can be implemented as
<p>
        : h = kdens_bw_simple(x, 1) * mm_kdel0_epan2()
        : g = mm_makegrid(x, 50, h)
        : d = kdens_gen(x, 1, g, h)
        : l = kdens_lbwf(x, 1, g, d)
        : d = kdens_gen(x, 1, g, h*l)
<p>
    The binned approximation estimator is
<p>
        : h = kdens_bw_simple(x, 1) * mm_kdel0_epan2()
        : g = mm_makegrid(x, 512, h)
        : gc = mm_fastlinbin(x, 1, g)
        : d = kdens_bin(g, gc, h)
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>kdens_gen(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i><b>,</b> <i>k</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>)</b>,
    <b>kdens_avar(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i><b>,</b> <i>d</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>)</b>,
    <b>kdens_evar(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>h</i><b>,</b> <i>d</i><b>,</b> <i>k</i><b>,</b> <i>pw</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>btype</i><b>)</b>:
             <i>h</i>:  <i>n x</i> 1 or 1 <i>x</i> 1
        <i>result</i>:  <i>m x</i> 1
<p>
    <b>kdens_bin(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i><b>,</b> <i>k</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>,</b> <i>btype</i><b>)</b>:
             <i>h</i>:  <i>m x</i> 1 or 1 <i>x</i> 1
        <i>result</i>:  <i>m x</i> 1
<p>
    <b>kdens_dd(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i><b>,</b> <i>drv</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>)</b>:
             <i>h</i>:  1 <i>x</i> 1
        <i>result</i>:  m <i>x</i> 1
<p>
    <b>kdens_df(</b><i>g</i><b>,</b> <i>gc</i><b>,</b> <i>h</i><b>,</b> <i>drv</i><b>,</b> <i>lb</i><b>,</b> <i>ub</i><b>)</b>:
             <i>h</i>:  1 <i>x</i> 1
        <i>result</i>:  1 <i>x</i> 1
<p>
    <b>kdens_bw_simple(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>rule</i><b>,</b> <i>scale</i><b>)</b>,
    <b>kdens_bw_sjpi(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>m</i><b>,</b> <i>scale</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>)</b>,
    <b>kdens_bw_dpi(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>m</i><b>,</b> <i>scale</i><b>,</b> <i>ll</i><b>,</b> <i>ul</i><b>,</b> <i>level</i><b>)</b>:
        <i>result</i>:  1 <i>x</i> 1
<p>
    <b>kdens_lbwf(</b><i>x</i><b>,</b> <i>w</i><b>,</b> <i>g</i><b>,</b> <i>d</i><b>)</b>:
        <i>result</i>:  <i>n x</i> 1
<p>
    where
<p>
             <i>x</i>:  <i>n x</i> 1
             <i>w</i>:  <i>n x</i> 1 or 1 <i>x</i> 1
             <i>g</i>:  <i>m x</i> 1
            <i>gc</i>:  <i>m x</i> 1
             <i>d</i>:  <i>m x</i> 1
             <i>k</i>:  1 <i>x</i> 1
           <i>drv</i>:  1 <i>x</i> 1
            <i>pw</i>:  1 <i>x</i> 1
             <i>m</i>:  1 <i>x</i> 1
          <i>rule</i>:  1 <i>x</i> 1
         <i>scale</i>:  1 <i>x</i> 1
            <i>lb</i>:  1 <i>x</i> 1
            <i>ub</i>:  1 <i>x</i> 1
         <i>btype</i>:  1 <i>x</i> 1
            <i>ll</i>:  1 <i>x</i> 1
            <i>ul</i>:  1 <i>x</i> 1
          <i>ldpi</i>:  1 <i>x</i> 1
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    The functions return invalid results if the data contain missing values.
<p>
    Weights are assumed to be normalized to the number of observations (i.e.
</pre>