<pre>
<b>help mata mm_polint()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>mm_polint() -- Polynomial interpolation and extrapolation</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <i>real vector</i> <b>mm_polint(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>xnew</i> [<b>,</b> <i>degree</i>]<b>)</b>
<p>
    where
<p>
            <i>x</i>:  <i>real vector</i> containing strictly monotone increasing or
                decreasing <i>x</i>-values
<p>
            <i>y</i>:  <i>real vector</i> containing associated <i>y</i>-values
<p>
         <i>xnew</i>:  <i>real vector</i> containing evaluation points
<p>
            <i>d</i>:  <i>real scalar</i> specifying degree of the polynomial (default: 1)
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>mm_polint()</b> evaluates the interpolating polynomial through <i>d</i>+1
    (<i>x</i>,<i>y</i>)-points at the value <i>xnew</i>. <i>x</i> should be strictly monotone increasing
    or decreasing. The set of data points is chosen such that the <i>x</i>-values
    are centered around <i>xnew</i>. However, the set is bounded by 1 at the left
    and length(<i>x</i>) at the right. Furthermore, choosing a centered set of data
    points is only possible if <i>d</i> is uneven. In this case (<i>d</i>+1)/2 points are
    on each side of <i>xnew</i>. If <i>d</i> is even and <i>x</i> is in ascending order, then
    <i>d</i>/2+1 points are below <i>xnew</i> and <i>d</i>/2 above. If <i>x</i> is in descending order
    <i>d</i>/2 points are below and <i>d</i>/2+1 above.  Therefore, if <i>d</i> is even, the
    returned result depends on whether <i>x</i> is increasing or decreasing.
<p>
    <i>d</i> is the degree of the polynomial. The default is to use a polynomial of
    degree one, i.e. to compute the linear interpolation (<i>d</i>=1).
<p>
<p>
<b><u>Remarks</u></b>
<p>
    <b>mm_polint()</b> is based on a translation into Mata of the <b>polint</b> rountine
    given in Press et al. (1992:109-110).
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>mm_polint(</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>xnew</i><b>,</b> <i>degree</i><b>)</b>:
           <i>x</i>: <i>n x</i> 1 or 1 <i>x n</i>
           <i>y</i>: <i>n x</i> 1 or 1 <i>x n</i>
        <i>xnew</i>: <i>m x</i> 1 or 1 <i>x m</i>
      <i>degree</i>: 1 <i>x</i> 1
      <i>result</i>: <i>m x</i> 1 or 1 <i>x m</i>.
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    <b>mm_polint()</b> requires <i>x</i> be in ascending or descending order.
<p>
    <i>d</i> must be an integer equal to one or larger and must be smaller than the
    number of input data points (i.e., <i>d</i>&lt;length(<i>x</i>)).
<p>
<p>
<b><u>Source code</u></b>
<p>
    mm_polint.mata
<p>
<p>
<b><u>References</u></b>
<p>
    Press, William H., Saul A. Teukolsky, William T. Vetterling, Brian P.
        Flannery (1992). Numerical Recipes in C. The Art of Scientific
        Computing. Second Edition. Cambridge University Press.  
        http://www.numerical-recipes.com/
<p>
<p>
<b><u>Author</u></b>
<p>
    Ben Jann, ETH Zurich, jann@soz.gess.ethz.ch
<p>
<p>
<b><u>Also see</u></b>
<p>
    Online:  help for <b>ipolate</b>, <b>mm_ipolate()</b>, <b>spline3()</b>, <b>[M-4] utility</b>, 
</pre>