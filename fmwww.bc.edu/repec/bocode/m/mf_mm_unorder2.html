<pre>
<b>help mata mm_unorder2()</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
    <b>mm_unorder2() -- Stable unorder</b>
<p>
<p>
<b><u>Syntax</u></b>
<p>
        <i>real colvector</i>       <b>mm_unorder2(</b><i>real scalar n</i><b>)</b>
<p>
        <i>transmorphic matrix</i>  <b>mm_jumble2(</b><i>transmorphic matrix X</i><b>)</b>
<p>
        <i>void</i>                 <b>mm__jumble2(</b><i>transmorphic matrix X</i><b>)</b>
<p>
<p>
    where <i>X</i> may not be a pointer matrix.
<p>
<p>
<b><u>Description</u></b>
<p>
    The results from official Stata's <b>unorder()</b> are not reproducible if <i>n</i> is
    large. That is, differing results may be obtained from <b>unorder()</b>,
    although the random-number seed has been set beforehand (see help for 
    <b>[M-5] uniform()</b>). <b>mm_unorder2()</b> is an improved version of official
    <b>unorder()</b> that produces stable results.
<p>
    <b>mm_jumble2()</b> and <b>mm__jumble2()</b> are stable versions of official <b>jumble()</b>
    and <b>_jumble()</b>.
<p>
    For descriptions of <b>unorder()</b>, <b>jumble()</b>, and <b>_jumble()</b> see help for 
    <b>[M-5] sort()</b>.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    The following example illustrates the problem:
<p>
        : for (i=1;i&lt;=10;i++) {
        &gt;         uniformseed(3)
        &gt;         p1 = unorder(100000)
        &gt;         uniformseed(3)
        &gt;         p2 = unorder(100000)
        &gt;         if (p1!=p2) {
        &gt;                 printf("round %g: unequal results\n", i)
        &gt;                 break
        &gt;         }
        &gt; }
        round 2: unequal results
<p>
    Explanation: <b>uniform()</b> may return duplicate pseudo random numbers due to
    computer precision constraints. Example:
<p>
        : uniformseed(3)
        
        : rows(uniqrows(uniform(100000,1)))
          99999
<p>
    Since the results from <b>unorder()</b> rely on the sort order of uniform pseudo
    random numbers and since the sort order of duplicate values is randomized
    independently from the usual random-number seed, results from <b>unorder()</b>
    may differ.
<p>
    <b>mm_unorder2()</b> solves the problem by using two pseudo random-number
    sequences instead of one.
<p>
<p>
<b><u>Conformability</u></b>
<p>
    <b>mm_unorder2(</b><i>n</i><b>)</b>:
                <i>n</i>:  1 <i>x</i> 1
           <i>result</i>:  <i>n x</i>  1
<p>
    <b>mm_jumble2(</b><i>X</i><b>)</b>:
                <i>X</i>:  <i>r1 x c1</i>
           <i>result</i>:  <i>r1 x c1</i>
<p>
    <b>mm__jumble2(</b><i>X</i><b>)</b>:
                <i>X</i>:  <i>r1 x c1</i>
           <i>result</i>:  <i>void</i>; <i>X</i> row order modified
<p>
<p>
<b><u>Diagnostics</u></b>
<p>
    See help for <b>[M-5] sort()</b>.
<p>
<p>
<b><u>Source code</u></b>
<p>
    mm_unorder2.mata, mm_jumble2.mata, mm__jumble2.mata.
<p>
<p>
<b><u>Author</u></b>
<p>
    Ben Jann, ETH Zurich, jann@soz.gess.ethz.ch
<p>
<p>
<b><u>Also see</u></b>
<p>
    Manual:  <b>[M-5] sort()</b>
<p>
    Online:  help for <b>[M-5] sort()</b>; <b>moremata</b>
</pre>