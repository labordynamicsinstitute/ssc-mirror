<pre>
<a name="validvalid"></a><p>
<b><u>Valid Validation Rules</u></b>
<p>
    There are 4 ways to create valid validation rules: give a bound, give a
    range or set of allowable values (the <b>in</b> syntax), give the name of
    another variable which is checked in the same way (the <b>like</b> syntax), or
    to use a series of Stata commands (the <b>complex rule</b> syntax). These are
    explained below.
<p>
<p>
<a name="boundSyntax"></a><b><u>The </u></b><b><u>bound</u></b><b><u> syntax</u></b>
<p>
        {<b>&gt;=</b> | <b>&gt;</b> | <b>==</b> | <b>&lt;</b> | <b>&lt;=</b>} <i>number</i>
<p>
    For variables which should be either larger or smaller than a number, one
        of the above will suffice. Only one such bound can be given.
<p>
<a name="boundExamples"></a><b><u>Examples of bounds</u></b>
<p>
    <b>&gt;0</b>
            checks to see if the values are all positive.
<p>
    <b>&lt;= 100</b>
            checks to see if the values are less than or equal to 100. It
            does not check anything else, such as whether the values are also
            non-negative.
<p>
    <b>&gt;= 0 &amp; &lt;= 100</b>
            results in an error. Only one bounding criterion can be
            specified.  If the numbers are restricted to a range, use the <b>in</b>
            syntax below.
<p>
<a name="inSyntax"></a><b><u>The </u></b><b><u>in</u></b><b><u> syntax</u></b>
<p>
        <b>in</b> {<i>Stata numlist</i> | <i>set notation</i>}
<p>
    <i>Stata numlist</i> is any type of list of numbers which Stata can understand.
        See numlist for the available syntaxes.
<p>
    <i>set notation</i> allows using set notation to specify the list. To specify a
        set of discrete numbers, enclose them in curly braces (<b>{</b> and <b>}</b> and
        separate them with commas. To specify ranges of numbers, use square
        braces <b>[</b> and <b>]</b> to include the endpoints and and round braces <b>(</b> and <b>)</b>
        to exclude endpoints. The missing value symbol <b>.</b> is used for
        infinity.
<p>
<a name="inExamples"></a><p>
<b><u>Examples of </u></b><b><u>in</u></b>
<p>
    <b>in {3,4,5,6}</b>
            checks to see if the values are in given values. Note that this
            would be identical any of the following Stata numlists
            <b>3 4 5 6</b>
            <b>3(1)6</b>
            <b>3 4 to 6</b>
        
<p>
    <b>in [1,5]</b>
            checks to see if the values are between 1 and 5 inclusive.
<p>
    <b>in [1,5)</b>
            checks to see if the values are from &gt;=1 and &lt;5.
<p>
    <b>in [0,.)</b>
            checks to see if the values are non-negative (i.e. 0 is a valid
            value). This is the same as <b>&gt;=0</b>, but looks more impressive.
        
    <b>in (-.,0)</b>
            checks to see if the values are negative (i.e. 0 is not a valid
            value).  This is the same as <b>&lt;0</b>.
<p>
<a name="likeSyntax"></a><p>
<b><u>The </u></b><b><u>like</u></b><b><u> syntax</u></b>
<p>
        <b>like</b> <i>varname</i>
<p>
    <b>like</b> simply says that the rule given for <i>varname</i> should be used for this
        variable, also. This allows having just one copy of a rule for a
        series of similar variables, such as in a wide dataset, making the
        checking more reliable and easier to alter.
<p>
<b><u>Example of </u></b><b><u>like</u></b>
<p>
    <b>like wow</b> will use the same validation rule as is used for the variable
        <b>wow</b>.
<p>
<a name="complexSyntax"></a><p>
<b><u>The </u></b><b><u>complex</u></b><b><u> syntax</u></b>
<p>
    There really is no syntax for this, since there could be a possible
    series of commands which are being run. It is best to edit these commands
    by using the ckvaredit dialog box and pushing the <b>Edit Complex Command</b>
    button. This will invoke the docharedit command, allowing the use of
    Stata's doedit do file editor. There are a couple of things to keep in
    mind when writing a complex rule:
<p>
        The variable for which the rule is being written is refered to as
        <b>`self'</b> (note the open and close quotes!). This will ensure that the
        rule works properly when called using a <b>like</b> syntax or if the
        variable itself is renamed.
<p>
        If the rule is being used as a validation rule, so that valid values
        will generate non-zero results and invalid values will generate
        zeros, the variable holding the results is called <b>`valid'</b> (note the
        quotes, again!). If the rule will flag errors, so that non-zero
        results are errors, and zeros correspond to valid values, use the
        variable name <b>`error'</b> (quotes required!). Finally, if the routine is
        a scoring routine, then the new variable must be called <b>`score'</b>
        (quotes!).
<p>
<a name="complexExamples"></a><p>
<b><u>Examples using the </u></b><b><u>complex</u></b><b><u> syntax</u></b>
<p>
    <b>gen byte `valid' = `self'&gt;=0</b>
            could be used to check if the values are non-negative (i.e. &gt;=
            0).
<p>
    <b>gen byte `error' = `self'&lt;0</b>
            could also be used to check if the values are non-negative (i.e.
            &gt;= 0).
<p>
    <b>gen byte `valid' = `self' &gt;= someOtherVar</b>
            could be used to check if the values of the checked variable are
            at least as big as that of another variable. Note that if the
            second variable is renamed, the validation rule will break.
<p>
    <b>gen byte `score' = `self'=="a" + .5*(`self'=="b")</b>
            would give 1 full point (mark) for the answer "a", and 1/2 point
            (mark) for the answer "b" when grading questionnaire or
            multiple-choice exam.
</pre>