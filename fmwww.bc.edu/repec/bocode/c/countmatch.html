<pre>
-------------------------------------------------------------------------------
help for <b>countmatch</b>
-------------------------------------------------------------------------------
<p>
<b><u>Count matching values for one variable in another</u></b>
<p>
        <b>countmatch</b> <i>var1</i> <i>var2</i> [<i>if</i>] [<i>in</i>] [ <b>,</b> <b><u>g</u></b><b>enerate(</b><i>newvar</i><b>)</b> <b>by(</b><i>byvarlist</i><b>)</b>
            <b><u>miss</u></b><b>ing</b> <i>list_options</i> ]
<p>
<p>
<b><u>Description</u></b> 
<p>
    <b>countmatch</b> counts observations for which each distinct value of <i>var1</i> is
    matched by (is equal to) <i>var2</i>, whether for the same observation or for
    some different observation(s). <i>var1</i> and <i>var2</i> should be both numeric or
    both string.
<p>
<p>
<b><u>Options</u></b> 
<p>
    <b>generate()</b> specifies the name of a new variable to hold information on
        match counts. If <b>generate()</b> is not specified, data and counts will be
        <b>list</b>ed.
<p>
    <b>by()</b> specifies that matching is to be carried out only within distinct
        groups defined by <i>byvarlist</i>. Observations with equal values must
        belong to the same group to count as matching.
<p>
    <b>missing</b> indicates that missing values of <i>var1</i> should be included in the
        comparison. By default, they are excluded.
<p>
    <i>list_options</i> are options of list, which may be used to tune the output of
        any listing.
<p>
<p>
<b><u>Remarks</u></b> 
<p>
    ---------------------------------------------------------------------------
    <i>Examples</i>
<p>
    For concreteness, consider data on friendships. Two variables are <b>name</b>
    and <b>bestfriendname</b>. Then <b>countmatch name bestfriendname</b> counts how many
    people name each person in <b>name</b> as their best friend in <b>bestfriendname</b>.
    This will include all those who name themselves as their own best
    friends.
<p>
    Alternatively, two variables are <b>name</b> and <b>friendname</b> and each observation
    specifies a person and one of their friends, so that the data occur in
    blocks, one block for each person.  Then <b>countmatch name friendname</b>
    counts how many people name each person in <b>name</b> as their friend in
    <b>friendname</b>. This will, again, include all those who name themselves as
    their own friends.  The count will necessarily be the same for each
    observation on a particular person. Downstream of this you may wish to
    list each person and the corresponding count just once, and egen's tag()
    function offers a way to do this.
<p>
    Doing this with <b>by()</b> adds a restriction: count only within distinct
    groups of <i>byvarlist</i>. You might be counting only friends of the same race
    or gender, for example. Getting all friends and all friends in the same
    group will allow you to determine all friends outside the same group by
    subtraction.
<p>
    ---------------------------------------------------------------------------
    <i>Do-it-yourself</i>
<p>
    Although <b>countmatch</b> automates a solution, the following notes on how to
    do this for yourself may be interesting or useful.
<p>
    We focus on a simple version of the problem.  For different values of
    <i>var1</i>, how many values of <i>var2</i> are the same?
<p>
    We will need to loop over the distinct values of <i>var1</i>.  Each time round
    the loop there will be a count, and then the result will be put into a
    variable in the right place(s).  To do that we need to have a variable to
    put it in.
<p>
        <b>. gen long count = 0</b>
<p>
    initialises a counter variable. The <b>long</b> is cautious, just in case the
    counts get really big. Another variable type may well be fine for your
    problem. Initialising to missing (not 0) is another good way.
<p>
    For toy examples, we can use levelsof confidently.  (In an updated Stata
    8, use levels instead.) Frequently, <i>var1</i> and <i>var2</i> are both string, so let
    us focus on that situation.
<p>
        <b>. levelsof </b><i>var1</i><b>, local(levels)</b>
<p>
    puts the distinct values into a local macro.
<p>
        <b>.  quietly foreach l of local levels {</b>
        <b>.        count if `"`l'"' == </b><i>var2</i>
        <b>.        replace count = r(N) if </b><i>var1</i><b> == `"`l'"'</b>
        <b>. }</b>
<p>
    gives a first solution. Compound double quotes <b>`" "'</b> are used just in
    case there are double quotes lurking in the strings. That may be
    unlikely, but it does no harm.
<p>
    Now this code pivots on both variables being string. Also, in a
    industrial-strength solution, you would not want to rely on all the
    distinct values fitting into a macro, so <b>levelsof</b> may be set on one side.
    One thing we can always do is map the distinct values to successive
    integers:
<p>
        <b>. egen group = group(</b><i>var1</i><b>)</b>
        <b>. su group, meanonly</b>
        <b>. local ngroup = r(max)</b>
<p>
    <b>egen, group()</b> maps the distinct values of <i>var1</i> to the integers
    1,...,#groups; and we can retrieve #groups by a summarize and then
    peeking at the saved results.  Initialise as before:
<p>
        <b>. gen long count = 0</b>
<p>
    Another variable will come in useful, holding the observation numbers.
    Then once again the counting is done in a loop.
<p>
        <b>. gen long obs = _n</b>
<p>
        <b>. qui forval i = 1/`ngroup' {</b>
        <b>.        su obs if group == `i', meanonly</b>
        <b>.        local first = r(min)</b>
        <b>.        count if </b><i>var1</i><b>[`first'] == </b><i>var2</i>
        <b>.        replace count = r(N) if group == `i'</b>
        }
<p>
    The loop uses a look-up technique. When we are focusing on <b>group == 1</b>,
    for example, how we know what value of <i>var1</i> we are dealing with?  (By
    construction, <i>var1</i> is constant for each distinct value of <b>group</b> - we set
    up a one-to-one mapping - but what is that constant?) Notice that it is
    not general enough to go
<p>
        <b>. su </b><i>var1</i><b> if group == `i'</b>
<p>
    and look at the saved results, because in general <i>var1</i> could be a string.
    We have to be one step more devious.  We just need to find the
    observation number for any observation in a particular group, and then we
    can get at the corresponding value of <i>var1</i>. That is where the <b>obs</b>
    variable comes in useful.  There are two saved results after a summarize
    that will work here, the minimum or the maximum, and you can choose. (The
    mean will not work in general: consider, for example, a group with just
    two representatives, in observation 8 and observation 10: the mean at 9
    does not identify a representative.)
<p>
    ---------------------------------------------------------------------------
    <i>Existence of match deducible from count of matches</i>
<p>
    Whether or not a match exists is determined by <b>inrange(</b><i>count</i><b>,1,.)</b>.
<p>
    ---------------------------------------------------------------------------
    <i>Multiple variables</i>
<p>
    Given <i>var1</i> and some <i>varlist</i> over which we wish to count matches, loop
    over <i>varlist</i>. This will fail if variables are not either all numeric or
    all string. One way of checking first is to use ds.
<p>
        <b>. qui foreach v of var </b><i>varlist</i><b> {</b>
        <b>.         countmatch </b><i>var1</i><b> `v', gen(`v'_m)</b>
        <b>. }</b>
<p>
    ---------------------------------------------------------------------------
    <i>Matches in the same observation</i>
<p>
    Given <i>var1</i> and some <i>varlist</i> over which we wish to count matches in the
    same observation, initialise a count variable and then loop over <i>varlist</i>.
    This will fail if variables are not either all numeric or all string. One
    way of checking first is to use ds.
<p>
        <b>. gen count = 0</b>
        <b>. qui foreach v of var </b><i>varlist</i><b> {</b>
        <b>.         replace count = count + (`v' == </b><i>var1</i><b>)</b>
        <b>. }</b>
<p>
<p>
<b><u>Examples</u></b> 
<p>
    <b>. countmatch name bestfriend</b>
    <b>. countmatch name bestfriend, gen(nfriends)</b>
<p>
<p>
<b><u>Author</u></b> 
<p>
    Nicholas J. Cox, Durham University, U.K.
    n.j.cox@durham.ac.uk
<p>
<p>
<b><u>Acknowledgments</u></b>
<p>
    This is a rewriting of <b>fndmtch2</b>. The original problem was suggested by
    Brian Uzzi. A bug was reported by Socrates Mokkas, which prompted this
    rewriting. Marcello Pagano pointed out some unclear wording in this help.
<p>
 
<b><u>See also</u></b> 
<p>
    Online: help for duplicates; fndmtch (if installed)
<p>
<p>
</pre>