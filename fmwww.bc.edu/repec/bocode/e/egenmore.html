<pre>
-------------------------------------------------------------------------------
help for <b>egenmore</b>
-------------------------------------------------------------------------------
<p>
<b><u>Extensions to generate (more extras)</u></b>
<p>
        <b>egen</b> [<i>type</i>] <i>newvar</i> <b>=</b> <i>fcn</i><b>(</b><i>arguments</i><b>)</b> [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [<b>,</b> <i>options</i>]
<p>
<p>
<b><u>Description</u></b>
<p>
    egen creates <i>newvar</i> of the optionally specified storage type equal to
    <i>fcn</i><b>(</b><i>arguments</i><b>)</b>.  Depending on <i>fcn</i><b>()</b>, <i>arguments</i> refers to an expression, a
    varlist, a numlist, or an empty string. The options are similarly
    function dependent.
<p>
<p>
<b><u>Functions</u></b>
<p>
    (The option <b>by(</b><i>byvarlist</i><b>)</b> means that computations are performed
    separately for each group defined by <i>byvarlist</i>.)
<p>
    Functions are grouped thematically as follows:
        Grouping and graphing
        Strings, numbers and conversions
        Dates, times and time series
        Summaries and estimates
        First and last
        Random numbers
        Row operations
<p>
<p>
<b><u>Grouping and graphing</u></b> 
<p>
    <b>axis(</b><i>varlist</i><b>)</b> [ <b>, gap</b> <b>label(</b><i>lblvarlist</i><b>)</b> <b><u>miss</u></b><b>ing</b> <b><u>rev</u></b><b>erse</b> ] resembles 
        egen's <b>group()</b>, but is specifically designed for constructing
        categorical axis variables for graphs, hence the name. It creates a
        single variable taking on values 1, 2, ...  for the groups formed by
        <i>varlist</i>.  <i>varlist</i> may contain string, numeric, or both string and
        numeric variables.  The order of the groups is that of the sort order
        of <i>varlist</i>.  <b>gap</b> overrides the default numbering of 1 up by adding a
        gap of 1 whenever a variable changes.  <b>label()</b> specifies that labels
        are to be assigned based on the value labels or values of <i>lblvarlist</i>;
        if not specified, <i>lblvarlist</i> defaults to <i>varlist</i>.  <b>missing</b> indicates
        that missing values in <i>varlist</i> (either numeric missing or <b>""</b>) are to
        be treated like any other value when assigning groups, instead of
        missing values being assigned to the group missing. <b>reverse</b> reverses
        labelling so that groups that would have been assigned values of 1
        ...  whatever are instead assigned values of whatever ... 1. (Stata 8
        required.)
<p>
    To order groups of a categorical variable according to their values of
    another variable, in preparation for a graph or table:
<p>
    <b>. egen meanmpg = mean(-mpg), by(rep78)</b>
    <b>. egen Rep78 = axis(meanmpg rep78), label(rep78)</b>
    <b>. tabstat mpg, by(Rep78) s(min mean max)</b>
<p>
    <b>clsst(</b><i>varname</i><b>)</b> <b>,</b> <b><u>v</u></b><b>alues(</b><i>numlist</i><b>)</b> [ <b><u>l</u></b><b>ater</b> ] returns whichever of the
        <i>numlist</i> in <b>values()</b> is closest (differs by least, disregarding sign)
        to the numeric variable <i>varname</i>. <b>later</b> specifies that in the event of
        ties values specified later in the list overwrite values specified
        earlier. If varname is 15 then 10 and 20 specified by <b>values(10 20)</b>
        are equally close. For any observation containing 15 the default is
        that 10 is reported, whereas with <b>later</b> 20 is reported. For a <i>numlist</i>
        containing an increasing sequence, <b>later</b> implies choosing the higher
        of two equally close values. (Stata 6 required.)
<p>
    <b>. egen mpgclass = clsst(mpg), v(10(5)40)</b>
<p>
    <b>egroup(</b><i>varlist</i><b>)</b> is a extension of egen's <b>group()</b> function with the extra
        option <b>label(</b><i>lblvarlist</i><b>)</b>, which will attach the original values (or
        value labels if they exist) of <i>lblvarlist</i> as value labels.  This
        option may not be combined with the <b>label</b> option.  (Stata 7 required;
        superseded by <b>axis()</b> above.)
<p>
    <b>group2(</b><i>varlist</i><b>)</b> is a generalisation of egen's <b>group()</b> with the extra
        option <b>sort(</b><i>egen_call</i><b>)</b>.  Groups of <i>varlist</i> will have values 1 upwards
        according to their values on the results of a specified <i>egen_call</i>.
        For example, <b>group2(rep78) sort(mean(mpg))</b> will produce a variable
        such that the group of <b>rep78</b> with the lowest mean of <b>mpg</b> will have
        value 1, that with the second lowest mean will have value 2, and so
        forth.  As with <b>group()</b>, the <b>label</b> option will attach the original
        values of <i>varlist</i> (or value labels if they exist) as value labels.
        The argument of <b>sort()</b> must be a valid call to an <b>egen</b> function,
        official or otherwise. (Stata 7 required; use of <b>egroup()</b> or <b>axis()</b>
        above is now considered better style.)
<p>
    <b>mlabvpos(</b><i>yvar xvar</i><b>)</b> [ <b>,</b> <b>log</b> <b><u>poly</u></b><b>nomial(</b><i>#</i><b>)</b> <b><u>mat</u></b><b>rix(</b><i>5x5 matrix</i><b>)</b> ]
        automatically generates a variable giving clock positions of marker
        labels given names of variables <i>yvar</i> and <i>xvar</i> defining the axes of a
        scatter plot. Thus the command generates a variable to be used in the
        scatter option <b>mlabvpos()</b>.
<p>
        The general idea is to pull marker labels away from the data region.
        So, marker labels in the lower left of the region are at clock
        positions 7 or 8, and those in the upper right are at clock-position
        1 or 2, etc.  More precisely, considering the following rectangle as
        the data region, then marker labels are placed as follows:
<p>
        +--------------+
        |11 12 12 12  1|
        |10 11 12  1  2| 
        | 9  9 12  3  3| 
        | 8  7  6  5  4| 
        | 7  6  6  6  5| 
        +--------------+ 
<p>
        Note that there is no attempt to prevent marker labels from
        overplotting, which is likely in any dataset with many observations.
        In such situations you might be better off simply randomizing clock
        positions with say <b>ceil(uniform() * 12)</b>.
<p>
        If <i>yvar</i> and <i>xvar</i> are highly correlated, than the clock-positions are
        generated as follows (which is however the same general idea):
<p>
        +--------------+
        |      12  1  3|
        |   12 12  3  4| 
        |11 11 12  5  5| 
        |10  9  6  6   | 
        | 9  7  6      | 
        +--------------+ 
<p>
        To calculate the positions, the x axis is first categorized into 5
        equal intervals around the mean of <i>xvar</i>. Afterwards the residuals
        from regression of <i>yvar</i> on <i>xvar</i> are categorized into 5 equal
        intervals. Both categorized variables are then used to calculate the
        positions according to the first table above.  The rule can be
        changed with the option <b>matrix()</b>.
<p>
        <b>log</b> indicates that residuals from regression are to be calculated
        using the logarithms of <i>xvar</i>. This might be useful if the scatter
        shows a strong curvilinear relationship.
<p>
        <b>polynomial(</b><i>#</i><b>)</b> indicates that residuals are to be calculated from a
        regression of <i>yvar</i> on a polynomial of <i>xvar</i>. For example, use <b>poly(2)</b>
        if the scatter shows a U-shaped relationship.
<p>
        <b>matrix(</b><i>#</i><b>)</b> is used to change the general rule for the plot positions.
        The positions are specified by a 5 x 5 matrix, in which cell [1,1]
        gives the clock position of marker labels in the upper left part of
        the data region, and so forth.  (Stata 8.2 required.)
<p>
    <b>. egen clock = mlabvpos(mpg weight)</b>
    <b>. scatter mpg weight, mlab(make) mlabvpos(clock)</b>
    <b>. egen clock2 = mlabvpos(mpg weight), matrix(11 1 12 11 1 \\ 10 2 12 10 2</b>
        <b>\\ 9 3 12 9 3 \\ 8 4 6 8 4 \\ 7 5 6 7 5)</b>
    <b>. sc mpg weight, mlab(make) mlabvpos(clock2)</b>
<p>
<p>
<b><u>Strings, numbers and conversions</u></b> 
<p>
    <b>base(</b><i>varname</i><b>)</b> [ <b>,</b> <b><u>b</u></b><b>ase(</b><i>#</i><b>)</b> ] produces a string variable containing the
        digits of a base <i>#</i> (default 2, possible values 2(1)9) representation
        of <i>varname</i>, which must contain integers. Thus if <i>varname</i> contains
        values 0, 1, 2, 3, 4, and the default base is used, then the result
        will contain the strings <b>"000"</b>, <b>"001"</b>, <b>"010"</b>, <b>"011"</b>, <b>"100"</b>.  If any
        integer values are negative, all string values will start with <b>-</b> if
        negative and <b>+</b> otherwise. See also <b>decimal()</b>. The examples show how
        to unpack this string into individual digits if desired. (Stata 6
        required.)
<p>
    <b>. egen binary = base(code)</b>
<p>
    Suppose <b>binary</b> is <b>str5</b>.  To get individual <b>str1</b> variables,
<p>
    <b>. forval i = 1/5 {</b>
    <b>.         gen str1 code`i' = substr(binary, `i',1)</b>
    <b>. }</b>
<p>
    and to get individual numeric variables,
<p>
    <b>. forval i = 1/5 {</b>
    <b>.         gen byte code`i' = real(substr(binary, `i', 1))</b>
    <b>. }</b>
<p>
    <b>decimal(</b><i>varlist</i><b>)</b> [ <b>,</b> <b><u>b</u></b><b>ase(</b><i>#</i><b>)</b> ] treats the values of <i>varlist</i> as indicating
        digits in a base <i>#</i> (default 2, possible values integers &gt;=2)
        representation of a number and produces the decimal equivalent. Thus
        if three variables are given with values in a single observation of 1
        1 0, and the default base is used, the decimal result is 1 * 2^2 + 1
        * 2^1 + 0 * 2^0 = 4 + 2 + 0 = 6.  Similarly if base 5 is used, the
        decimal equivalent of 2 3 4 is 2 * 5^2 + 3 * 5^1 + 4 * 5^0 = 50 + 15
        + 4 = 59. Note that the order of variables in <i>varlist</i> is crucial.
        (Stata 7 required.)
<p>
    <b>. egen decimal = decimal(q1-q8)</b>
<p>
    <b>incss(</b><i>strvarlist</i><b>)</b> <b>,</b> <b><u>s</u></b><b>ubstr(</b><i>substring</i><b>)</b> [ <b><u>i</u></b><b>nsensitive</b> ] indicates
        occurrences of <i>substring</i> within any of the variables in a list of
        string variables by 1 and other observations by 0. <b>insensitive</b> makes
        comparison case-insensitive. (Stata 6 required; an alternative is now
        just to use foreach.)
<p>
    <b>. egen buick = incss(make), sub(buick) i</b>
<p>
    <b>iso3166(</b><i>varname</i><b>)</b> [<b>,</b> <b><u>o</u></b><b>rigin(codes</b>|<b>names)</b> <b><u>l</u></b><b>anguage(en</b>|<b>fr)</b> <b><u>v</u></b><b>erbose</b> <b><u>u</u></b><b>pdate</b>]
        maps <i>varname</i> containing "official short country names" into a new
        variable containing the ISO 3166-1-alpha-2 code elements (e.g. DE for
        "Germany", GB for "United Kingdom" and HM for "Heard Island and
        McDonald Islands") and vice versa. The official short country names
        can be in English (default) or French. Correspondingly the function
        produces country names from ISO 3166-1-alpha-2 codes in English or
        French. (Version 9.2 required.)
<p>
        <b><u>o</u></b><b>rigin(codes</b>|<b>names)</b> declares the character of the country variable
        that is already in the data. The default is <b>names</b>, meaning that
        <i>varname</i> holds the "official short country names". This information
        may be stored as a string variable or as a numeric variable that is
        labeled accordingly. This default setting produces ISO 3166-1-alpha-2
        codes from the country names. If country names should be produced
        from the two letter codes, use <b>egen</b> <i>newvar</i> <b>= iso3166(</b><i>varname</i><b>),</b>
        <b>origin(codes)</b>.
<p>
        <b><u>l</u></b><b>anguage(en</b>|<b>fr)</b> defines the language in which the country names are
        stored, or should be produced. <b>language(en)</b> is for English names
        (default); <b>language(fr)</b> is for French names.
<p>
        <b><u>v</u></b><b>erbose</b> For the mapping from country names to ISO 3166-1-alpha2 codes
        the program expects official short country names. It cannot handle
        unofficial country names such as "Great Britain", "Taiwan" or
        "Russia". Such unofficial country names result in the generation of
        missing values for the respective countries. By default <b>iso3166()</b>
        only returns the number of missing values it has produced. With
        <b>verbose</b> Stata also provides the list of unofficial country names in
        <i>varname</i> and a clickable link to the list of official country names.
        This is convenient if one wants to correct the information stored in
        <i>varname</i> before using <b>iso3166()</b>. For the transformation of ISO
        3166-1-alpha2 codes into country names, <b>verbose</b> does something
        equivalent.
<p>
        <b><u>u</u></b><b>pdate</b> The ISO 3166-1-alpha2 codes are automaticaly looked up in
        information provided by the ISO 3166 Maintenance Agency of the
        International Organization for Standardization. The information is
        automatically downloaded from the internet when the user specifies
        <b>iso3166()</b> the first time, or whenever <b>update</b> is specified. Note:
        Updating the matching list regularly will guarantee that <b>iso3166()</b>
        always produces up-to-date country names. However, updating the match
        list may also produce missing values when running older do-files for
        data sets with countries that no longer exist (for example,
        Yugoslavia).
<p>
        Note the implications: This function will only work if your copy of
        Stata can access the internet, at least for the first time it is
        called.  The results of the function might be not fully reproducible
        in the future.
<p>
    <b>msub(</b><i>strvar</i><b>)</b> <b>,</b> <b><u>f</u></b><b>ind(</b><i>findstr</i><b>)</b> [ <b><u>r</u></b><b>eplace(</b><i>replacestr</i><b>)</b> <b>n(</b><i>#</i><b>)</b> <b><u>w</u></b><b>ord</b> ] replaces
        occurrences of the words of <i>findstr</i> by the words of <i>replacestr</i> in the
        string variable <i>strvar</i>. The words of <i>findstr</i> and of <i>replacestr</i> are
        separated by spaces or bound by <b>" "</b>: thus <b>find(a b "c d")</b> includes
        three words, in turn <b>"a"</b>, <b>"b"</b> and <b>"c d"</b>, and double quotation marks <b>"</b>
        <b>"</b> should be used to delimit any word including one or more spaces.
        The number of words in <i>findstr</i> should equal that in <i>replacestr</i>,
        except that (1) an empty <i>replacestr</i> is taken to specify deletion; (2)
        a single word in <i>replacestr</i> is taken to mean that each word of
        <i>findstr</i> is to be replaced by that word. As quotation marks are used
        for delimiting, literal quotation marks should be included in
        compound double quotation marks, as in <b>`"""'</b>.  By default all
        occurrences are changed. <b>n(</b><i>#</i><b>)</b> specifies that the first <i>#</i> occurrences
        only should be changed. <b>word</b> specifies that words in <i>findstr</i> are to
        be replaced only if they occur as separate words in <i>strvar</i>. The
        substitutions of <b>msub()</b> are made in sequence.  (Stata 6 required;
        <b>msub()</b> depends on the built-in functions subinstr() and subinword().)
<p>
    <b>. egen newstr = msub(strvar), f(A B C) r(1 2 3)</b>
    (replaces <b>"A"</b> by <b>"1"</b>, <b>"B"</b> by <b>"2"</b>, <b>"C"</b> by <b>"3"</b>)
<p>
    <b>. egen newstr = msub(strvar), f(A B C) r(1 2 3) n(1)</b>
    (replaces <b>"A"</b> by <b>"1"</b>, <b>"B"</b> by <b>"2"</b>, <b>"C"</b> by <b>"3"</b>, first occurrence only)
<p>
    <b>. egen newstr = msub(strvar), f(A B C) r(1)</b>
    (replaces <b>"A"</b> by <b>"1"</b>, <b>"B"</b> by <b>"1"</b>, <b>"C"</b> by <b>"1"</b>)
<p>
    <b>. egen newstr = msub(strvar), f(A B C)</b>
    (deletes <b>"A"</b>, <b>"B"</b>, <b>"C"</b>)
<p>
    <b>. egen newstr = msub(strvar), f(" ")</b>
    (deletes spaces)
<p>
    <b>. egen newstr = msub(strvar), f(`"""')</b>
    (deletes quotation mark <b>"</b>)
<p>
    <b>. egen newstr = msub(strvar) f(frog) w</b>
    (deletes <b>"frog"</b> only if occurring as single word)
<p>
    <b>noccur(</b><i>strvar</i><b>)</b> <b>,</b> <b><u>s</u></b><b>tring(</b><i>substr</i><b>)</b> creates a variable containing the number
        of occurrences of the string <i>substr</i> in string variable <i>strvar</i>.  Note
        that occurrences must be disjoint (non-overlapping): thus there are
        two occurrences of <b>"aa"</b> within <b>"aaaaa"</b>. (Stata 7 required.)
<p>
    <b>nss(</b><i>strvar</i><b>)</b> <b>,</b> <b><u>f</u></b><b>ind(</b><i>substr</i><b>)</b> [ <b><u>i</u></b><b>nsensitive</b> ] returns the number of
        occurrences of <i>substr</i> within the string variable <i>strvar</i>.  <b>insensitive</b>
        makes counting case-insensitive. (Stata 6 required.)
<p>
    The inclusion of <b>noccur()</b> and <b>nss()</b>, two almost identical functions, was
    an act of sheer inadvertence by the maintainer.
<p>
    <b>ntos(</b><i>numvar</i><b>)</b> <b>,</b> <b><u>f</u></b><b>rom(</b><i>numlist</i><b>)</b> <b><u>t</u></b><b>o(</b><i>list of string values</i><b>)</b> generates a string
        variable from a numeric variable <i>numvar</i>, mapping each numeric value
        in <i>numlist</i> to the corresponding string value.  The number of elements
        in each list must be the same. String values containing blanks should
        be delimited by doube quotation marks <b>" "</b>. Values not defined by the
        mapping are generated as missing. The type of the string variable is
        determined automatically. (Stata 6 required.)
<p>
    <b>. egen grade = ntos(Grade), from(1/5) to(Poor Fair Good "Very good"</b>
        <b>Excellent)</b>
<p>
    <b>nwords(</b><i>strvar</i><b>)</b> returns the number of words within the string variable
        <i>strvar</i>. Words are separated by spaces, unless bound by double
        quotation marks <b>" "</b>. (Stata 6 required; superseded by wordcount()).
<p>
    <b>repeat()</b> <b>,</b> <b><u>v</u></b><b>alues(</b><i>value_list</i><b>)</b> [ <b>by(</b><i>byvarlist</i><b>)</b> <b><u>b</u></b><b>lock(</b><i>#</i><b>)</b> ] produces a
        repeated sequence of <i>value_list</i>. The items of <i>value_list</i>, which may
        be a <i>numlist</i> or a set of string values, are assigned cyclically to
        successive observations. The order of observations is determined (1)
        after noting any <b>if</b> or <b>in</b> restrictions; (2) within groups specified
        by <b>by()</b>, if issued; (3) by the current sort order. <b>block()</b> specifies
        that values should be repeated in blocks of the specified size: the
        default is 1. The variable type is determined smartly, and need not
        be specified. (Stata 8 required.)
<p>
    <b>. egen quarter = repeat(), v(1/4) block(3)</b>
    <b>. egen months = repeat(), v(`c(Months)')</b>
    <b>. egen levels = repeat(), v(10 50 200 500)</b>
<p>
    <b>sieve(</b><i>strvar</i><b>)</b> <b>,</b> { <b>keep(</b><i>classes</i><b>)</b> | <b>char(</b><i>chars</i><b>)</b> | <b>omit(</b><i>chars</i><b>)</b> } selects
        characters from <i>strvar</i> according to a specified criterion and
        generates a new string variable containing only those characters.
        This may be done in three ways. First, characters are classified
        using the keywords <b>alphabetic</b> (any of <b>a-z</b> or <b>A-Z</b>), <b>numeric</b> (any of
        <b>0-9</b>), <b>space</b> or <b>other</b>. <b>keep()</b> specifies one or more of those classes:
        keywords may be abbreviated by as little as one letter.  Thus <b>keep(a</b>
        <b>n)</b> selects alphabetic and numeric characters and omits spaces and
        other characters. Note that keywords must be separated by spaces.
        Alternatively, <b>char()</b> specifies each character to be selected or
        <b>omit()</b> specifies each character to be omitted. Thus <b>char(0123456789.)</b>
        selects numeric characters and the stop (presumably as decimal
        point); <b>omit(" ")</b> strips spaces and <b>omit(`"""')</b> strips double
        quotation marks.  (Stata 7 required.)
<p>
    <b>ston(</b><i>strvar</i><b>)</b> <b>,</b> <b><u>f</u></b><b>rom(</b><i>list of string values</i><b>)</b> <b><u>t</u></b><b>o(</b><i>numlist</i><b>)</b> generates a
        numeric variable from a string variable <i>strvar</i>, mapping each string
        value to the corresponding numeric value in <i>numlist</i>. The number of
        elements in each list must be the same. String values containing
        blanks should be delimited by <b>" "</b>. Values not defined by the mapping
        are generated as missing. (Stata 6 required.)
<p>
    <b>. egen Grade = ston(grade), to(1/5) from(Poor Fair Good "Very good"</b>
        <b>Excellent)</b>
<p>
    <b>wordof(</b><i>strvar</i><b>)</b> <b>,</b> <b><u>w</u></b><b>ord(</b><i>#</i><b>)</b> returns the <i>#</i>th word of string variable <i>strvar</i>.
        <b>word(1)</b> is the first word, <b>word(2)</b> the second word, <b>word(-1)</b> the last
        word, and so forth. Words are separated by spaces, unless bound by
        quotation marks <b>" "</b>. (Stata 6 required; superseded by word().)
<p>
<p>
<b><u>Dates, times and time series</u></b> 
<p>
    <b>bom(</b><i>m y</i><b>)</b> [ <b>,</b> <b><u>l</u></b><b>ag(</b><i>lag</i><b>)</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> <b><u>w</u></b><b>ork</b> ] creates an elapsed date
        variable containing the date of the beginning of month <i>m</i> and year <i>y</i>.
        <i>m</i> can be a variable containing integers between 1 and 12 inclusive or
        a single integer in that range.  <i>y</i> can be a variable containing
        integers within the range covered by elapsed dates or a single
        integer within that range. Optionally <b>lag()</b> specifies a lag: the
        beginning of the month will be given for <b>lag</b> months before the
        current date. <b>lag(1)</b> refers to the previous month, <b>lag(3)</b> to 3 months
        ago and <b>lag(-3)</b> to 3 months hence. The <b>lag</b> may also be specified by a
        variable containing integers. Optionally a format, usually but not
        necessarily a date format, can be specified.  <b>work</b> specifies that the
        first day must also be one of Monday to Friday. (Stata 6 required.)
<p>
    <b>. egen bom = bom(month year), f(%dd_m_y)</b>
<p>
    <b>bomd(</b><i>datevar</i><b>)</b> [ <b>,</b> <b><u>l</u></b><b>ag(</b><i>lag</i><b>)</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> <b><u>w</u></b><b>ork</b> ] creates an elapsed date
        variable containing the date of the beginning of the month containing
        the date in an elapsed date variable <i>datevar</i>.  Optionally <b>lag()</b>
        specifies a lag: the beginning of the month will be given for <b>lag</b>
        months before the current date. <b>lag(1)</b> refers to the previous month,
        <b>lag(3)</b> to 3 months ago and <b>lag(-3)</b> to 3 months hence. The <b>lag</b> may
        also be specified by a variable containing integers. Optionally a
        format, usually but not necessarily a date format, can be specified.
        <b>work</b> specifies that the first day must also be one of Monday to
        Friday. (Stata 6 required.)
<p>
    <b>. egen bomd = bomd(date), f(%dd_m_y)</b>
<p>
    Note that <b>work</b> knows nothing about holidays or any special days.
<p>
    <b>dayofyear(</b><i>daily_date_variable</i><b>)</b> [ <b>,</b> <b><u>m</u></b><b>onth(</b><i>#</i><b>)</b> <b><u>d</u></b><b>ay(</b><i>#</i><b>)</b> ] generates the day of
        the year, counting from the start of the year, from a daily date
        variable. The start of the year is 1 January by default: <b>month()</b>
        and/or <b>day()</b> may be used to specify an alternative.  This function
        thus is a generalisation of the date function doy().  (Stata 8
        required.)
<p>
    <b>. egen dayofyear = dayofyear(date), m(10)</b>
<p>
    <b>dhms(</b><i>d h m s</i><b>)</b> [ <b>,</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> ] creates a date variable from Stata
        date variable or date <i>d</i> with a fractional part reflecting the number
        of hours, minutes and seconds past midnight.  <i>h</i> can be a variable
        containing integers between 0 and 23 inclusive or a single integer in
        that range. <i>m</i> and <i>s</i> can be variables containing integers between 0
        and 59 or single integer(s) in that range.  Optionally a format,
        usually but not necessarily a date format, can be specified. The
        resulting variable, which is by default stored as a double, may be
        used in date and time arithmetic in which the time of day is taken
        into account. (Stata 6 required.)
<p>
    <b>elap(</b><i>time</i><b>)</b> [ <b>,</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> ] creates a string variable which contains
        the number of days, hours, minutes and seconds associated with an
        integer variable containing a number of elapsed seconds. Such a
        variable might be the result of date/time arithmetic, where a time
        interval between two timestamps has been expressed in terms of
        elapsed seconds. Leading zeroes are included in the hours, minutes,
        and seconds fields. Optionally, a format can be specified. (Stata 6
        required.)
<p>
    <b>elap2(</b><i>time1 time2</i><b>)</b> [ <b>,</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> ] creates a string variable which
        contains the number of days, hours, minutes and seconds associated
        with a pair of time values, expressed as fractional days, where <i>time1</i>
        is no greater than <i>time2</i>.  Such time values may be generated by
        function <b>dhms()</b>. <b>elap2()</b> expresses the interval between these time
        values in readable form.  Leading zeroes are included in the hours,
        minutes, and seconds fields.  Optionally, a format can be specified.
        (Stata 6 required.)
<p>
    <b>eom(</b><i>m y</i><b>)</b> [ <b>,</b> <b><u>l</u></b><b>ag(</b><i>lag</i><b>)</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> <b><u>w</u></b><b>ork</b> ] creates an elapsed date
        variable containing the date of the end of month <i>m</i> and year <i>y</i>. <i>m</i> can
        be a variable containing integers between 1 and 12 inclusive or a
        single integer in that range. <i>y</i> can be a variable containing integers
        within the range covered by elapsed dates or a single integer within
        that range. Optionally <b>lag()</b> specifies a lag: the end of the month
        will be given for <b>lag</b> months before the current date. <b>lag(1)</b> refers
        to the previous month, <b>lag(3)</b> to 3 months ago and <b>lag(-3)</b> to 3 months
        hence. The <b>lag</b> may also be specified by a variable containing
        integers. Optionally a format, usually but not necessarily a date
        format, can be specified.  <b>work</b> specifies that the last day must also
        be one of Monday to Friday.  (Stata 6 required.)
<p>
    <b>. egen eom = eom(month year), f(%dd_m_y)</b>
<p>
    <b>eomd(</b><i>datevar</i><b>)</b> [ <b>,</b> <b><u>l</u></b><b>ag(</b><i>lag</i><b>)</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> <b><u>w</u></b><b>ork</b> ] creates an elapsed date
        variable containing the date of the end of the month containing the
        date in an elapsed date variable <i>datevar</i>.  Optionally <b>lag()</b> specifies
        a lag: the end of the month will be given for <b>lag</b> months before the
        current date. <b>lag(1)</b> refers to the previous month, <b>lag(3)</b> to 3 months
        ago and <b>lag(-3)</b> to 3 months hence. The <b>lag</b> may also be specified by a
        variable containing integers. Optionally a format, usually but not
        necessarily a date format, can be specified.  <b>work</b> specifies that the
        last day must also be one of Monday to Friday. (Stata 6 required.)
<p>
    Note that <b>work</b> knows nothing about holidays or any special days.
<p>
    <b>. egen eom = eomd(date), f(%dd_m_y)</b>
    <b>. egen eopm = eomd(date), f(%dd_m_y) lag(1)</b>
<p>
    <b>ewma(</b><i>timeseriesvar</i><b>)</b> <b>,</b> <b>a(</b><i>#</i><b>)</b> calculates the exponentially weighted moving
        average, which is
<p>
        <i>ewma</i> = <i>timeseriesvar</i> for the first observation
<p>
             = <b>a * </b><i>timeseriesvar</i> + <b>(1 - a) * L.</b><i>ewma</i> otherwise
<p>
        The data must have been declared time series data by tsset.
        Calculations start afresh after any gap with missing values.  (Stata
        6 required; superseded by tssmooth.)
<p>
    <b>filter(</b><i>timeseriesvar</i><b>) ,</b> <b><u>l</u></b><b>ags(</b><i>numlist</i><b>)</b> [ <b><u>c</u></b><b>oef(</b><i>numlist</i><b>)</b> { <b><u>n</u></b><b>ormalise</b> |
        <b><u>n</u></b><b>ormalize</b> } ] calculates the linear filter which is the sum of terms
<p>
        <i>coef_i</i> <b>* L</b><i>i.timeseriesvar</i> or <i>coef_i</i> <b>* F</b><i>i.timeseriesvar</i>
<p>
        <b>coef()</b> defaults to a vector the same length as <b>lags()</b> with each
        element 1.
<p>
        <b>filter(y), l(0/3) c(0.4(0.1)0.1)</b> calculates
<p>
        <b>0.4 * y + 0.3 * L1.y + 0.2 * L2.y + 0.1 * L3.y</b>
<p>
        <b>filter(y), l(0/3)</b> calculates
<p>
        <b>1 * y + 1 * L1.y + 1 * L2.y + 1 * L3.y</b> or <b>y + L1.y + L2.y + L3.y</b>
<p>
        Leads are specified as negative lags.  <b>normalise</b> (or <b>normalize</b>,
        according to taste) specifies that coefficients are to be divided by
        their sum so that they add to 1 and thus specify a weighted mean.
<p>
        <b>filter(y), l(-2/2) c(1 4 6 4 1) n</b> calculates
<p>
        <b>(1/16) * F2.y + (4/16) * F1.y + (6/16) * y</b> <b>+ (4/16) * L1.y + (1/16) *</b>
        <b>L2.y</b>
<p>
        The data must have been declared time series data by tsset.  Note
        that this may include panel data, which are automatically filtered
        separately within each panel.
<p>
        The order of terms in <b>coef()</b> is taken to be the same as that in <b>lags</b>.
        (Stata 8 required; see also tssmooth.)
<p>
    <b>. egen f2y = filter(y), l(-1/1) c(0.25 0.5 0.25)</b>
    <b>. egen f2y = filter(y), l(-1/1) c(1 2 1) n</b>
<p>
    <b>filter7(</b><i>timeseriesvar</i><b>) ,</b> <b><u>l</u></b><b>ags(</b><i>numlist</i><b>)</b> <b><u>c</u></b><b>oef(</b><i>numlist</i><b>)</b> [ { <b><u>n</u></b><b>ormalise</b> |
        <b><u>n</u></b><b>ormalize</b> } ] calculates the linear filter which is the sum of terms
<p>
        <i>coef_i</i> <b>* L</b><i>i.timeseriesvar</i> or <i>coef_i </i><b>* F</b><i>i.timeseriesvar</i>
<p>
        <b>filter7(y), l(0/3) c(0.4(0.1)0.1)</b> calculates
<p>
        <b>0.4 * y + 0.3 * L1.y + 0.2 * L2.y + 0.1 * L3.y</b>
<p>
        Leads are specified as negative lags.  <b>normalise</b> (or <b>normalize</b>,
        according to taste) specifies that coefficients are to be divided by
        their sum so that they add to 1 and thus specify a weighted mean.
<p>
        <b>filter7(y), l(-2/2) c(1 4 6 4 1) n</b> calculates
<p>
        <b>(1/16) * F2.y + (4/16) * F1.y + (6/16) * y</b> <b>+ (4/16) * L1.y + (1/16) *</b>
        <b>L2.y</b>
<p>
        The data must have been declared time series data by tsset.  Note
        that this may include panel data, which are automatically filtered
        separately within each panel.
<p>
        The order of terms in <b>coef()</b> is taken to be the same as that in
        <b>lags()</b>. (Stata 7 required; see also tssmooth.)
<p>
    <b>foy(</b><i>daily_date_variable</i><b>)</b> [ <b>,</b> <b><u>m</u></b><b>onth(</b><i>#</i><b>)</b> <b><u>d</u></b><b>ay(</b><i>#</i><b>)</b> ] generates the fraction of
        the year elapsed since the start of the year from a daily date
        variable. The start of the year is 1 January by default: <b>month()</b>
        and/or <b>day()</b> may be used to specify an alternative.  If
        <i>daily_date_variable</i> is all integers, then the result is
        (day of year - 0.5) / number of days in year. If <i>daily_date_variable</i>
        contains non-integers, then the result is (day of year - 1) / number
        of days in year.  (Stata 8 required.)
<p>
    <b>. egen frac = foy(date), m(10)</b>
<p>
    <b>hmm(</b><i>timevar</i><b>)</b> [ <b>,</b> <b><u>r</u></b><b>ound(</b><i>#</i><b>)</b> <b><u>t</u></b><b>rim</b> ] generates a string variable showing
        <i>timevar</i>, interpreted as indicating time in minutes, represented as
        hours and minutes in the form <b>"</b>[...<i>h</i>]<i>h</i><b>:</b><i>mm</i><b>"</b>.  For example, times of <b>9</b>,
        <b>90</b>, <b>900</b> and <b>9000</b> minutes would be represented as <b>"0:09"</b>,<b>"1:30"</b>,
        <b>"15:00"</b> and <b>"150:00"</b>. The option <b>round(</b><i>#</i><b>)</b> rounds the result: <b>round(1)</b>
        rounds the time to the nearest minute. The option <b>trim</b> trims the
        result of leading zeros and colons, except that an isolated <b>0</b> is not
        trimmed. With <b>trim</b> <b>"0:09"</b> is trimmed to <b>"9"</b> and <b>"0:00"</b> is trimmed to
        <b>"0"</b>.
<p>
        <b>hmm()</b> serves equally well for representing times in seconds in
        minutes and seconds in the form <b>"</b>[...<i>m</i>]<i>m</i><b>:</b><i>ss</i><b>"</b>. (Stata 6 required.)
<p>
    <b>hmmss(</b><i>timevar</i><b>)</b> [ <b>,</b> <b><u>r</u></b><b>ound(</b><i>#</i><b>)</b> <b><u>t</u></b><b>rim</b> ] generates a string variable showing
        <i>timevar</i>, interpreted as indicating time in seconds, represented as
        hours, minutes and seconds in the form <b>"</b>[...<i>h</i><b>:</b>]<i>mm</i><b>:</b><i>ss</i><b>"</b>. For example,
        times of <b>9</b>, <b>90</b>, <b>900</b> and <b>9000</b> seconds would be represented as
        <b>"00:09"</b>,<b>"01:30"</b>, <b>"15:00"</b> and <b>"2:30:00"</b>. The option <b>round(</b><i>#</i><b>)</b> rounds
        the result:  <b>round(1)</b> rounds the time to the nearest second. The
        option <b>trim</b> trims the result of leading zeros and colons, except that
        an isolated <b>0</b> is not trimmed. With <b>trim</b> <b>"00:09"</b> is trimmed to <b>"9"</b> and
        <b>"00:00"</b> is trimmed to <b>"0"</b>. (Stata 6 required.)
<p>
    <b>hms(</b><i>h m s</i><b>)</b> [ <b>,</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> ] creates an elapsed time variable
        containing the number of seconds past midnight. <i>h</i> can be a variable
        containing integers between 0 and 23 inclusive or a single integer in
        that range. <i>m</i> and <i>s</i> can be variables containing integers between 0
        and 59 or single integer(s) in that range.  Optionally a format can
        be specified. (Stata 6 required.)
<p>
    <b>minutes(</b><i>strvar</i><b>)</b> [ <b>,</b> <b>maxhour(</b><i>#</i><b>)</b> ] returns time in minutes given a string
        variable <i>strvar</i> containing a time in hours and minutes in the form
        <b>"</b>[..<i>h</i>]<i>hh</i>:<i>mm</i><b>"</b>.  In particular, minutes are given as two digits between
        00 and 59 and hours by default are given as two digits between 00 and
        23. The <b>maxhour()</b> option may be used to change the (unreachable)
        limit: its default is 24. Note that, strange though it may seem, this
        function rather than <b>seconds()</b> is appropriate for converting times in
        the form <b>"</b><i>mm</i>:<i>ss</i><b>"</b> to seconds.  The maximum number of minutes
        acceptable may need then to be specified by <b>maxhour()</b> [sic].  (Stata
        8 required.)
<p>
    <b>ncyear(</b><i>datevar</i><b>)</b> <b>,</b> <b><u>m</u></b><b>onth(</b><i>#</i><b>)</b> [ <b><u>d</u></b><b>ay(</b><i>#</i><b>)</b> ] returns an integer variable
        labelled with labels such as <b>"1952/53"</b> for non-calendar years
        starting on the specified month and day.  The day defaults to 1.
        <i>datevar</i> is treated as indicating elapsed dates. For more on dates,
        see help on dates. (Stata 6 required.)
<p>
    <b>. egen wtryear = ncyear(date), m(10)</b>
    (years starting on 1 October)
<p>
    <b>. egen wwgyear = ncyear(date), m(1) d(21)</b>
    (years starting on 21 January)
<p>
    <b>record(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b>min</b> <b>order(</b><i>varlist</i><b>)</b> ] produces the maximum
        (with <b>min</b> the minimum) value observed "to date" of the specified <i>exp</i>.
        Thus <b>record(wage), by(id) order(year)</b> produces the maximum wage so
        far in worker's career, calculations being separate for each <b>id</b> and
        records being determined within each <b>id</b> in <b>year</b> order. Although
        explanation and example here refer to dates, nothing in <b>record()</b>
        restricts its use to data ordered in time. If not otherwise specified
        with <b>by()</b> and/or <b>order()</b>, records are determined with respect to the
        current order of observations. No special action is required for
        missing values, as internally <b>record()</b> uses either the <b>max()</b> or the
        <b>min()</b> function, both of which return results of missing only if all
        values are missing. (Stata 6 required.)
<p>
    <b>. egen hiwage = record(exp(lwage)), by(id) order(year)</b>
    <b>. egen lowage = record(exp(lwage)), by(id) order(year) min</b>
<p>
    <b>seconds(</b><i>strvar</i><b>)</b> [ <b>,</b> <b>maxhour(</b><i>#</i><b>)</b> ] returns time in seconds given a string
        variable containing a time in hours, minutes and seconds in the form
        <b>"</b>[..<i>h</i>]<i>hh</i><b>:</b><i>mm</i><b>:</b><i>ss</i><b>"</b>.  In particular, minutes and seconds are each given
        as two digits between 00 and 59 and hours by default are given as two
        digits between 00 and 23. The <b>maxhour()</b> option may be used to change
        the (unreachable) limit: its default is 24.  (Stata 8 required.)
<p>
    <b>tod(</b><i>time</i><b>)</b> [ <b>,</b> <b><u>f</u></b><b>ormat(</b><i>format</i><b>)</b> ] creates a string variable which contains
        the number of hours, minutes and seconds associated with an integer
        in the range 0 to 86399, one less than the number of seconds in a
        day. Such a variable is produced by <b>hms()</b>, which see above. Leading
        zeroes are included in the hours, minutes, and seconds fields. Colons
        are used as separators.  Optionally a format can be specified.
        (Stata 6 required.)
<p>
<p>
<b><u>Summaries and estimates</u></b> 
<p>
    <b>adjl(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b><u>fact</u></b><b>or(</b><i>#</i><b>)</b> ] calculates adjacent lower
        values. These are the smallest values within <b>factor()</b> times the
        interquartile range of the lower quartile.  By default <b>factor()</b> is
        1.5, defining the default lower value of a so-called whisker on a
        Stata box plot. (Stata 8 required.)
<p>
    <b>adju(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b><u>fact</u></b><b>or(</b><i>#</i><b>)</b> ] calculates adjacent upper
        values. These are the largest values within <b>factor()</b> times the
        interquartile range of the upper quartile.  By default <b>factor()</b> is
        1.5, defining the default upper value of a so-called whisker on a
        Stata box plot. (Stata 8 required.)
<p>
    <b>. egen adjl = adjl(mpg), by(foreign)</b>
    <b>. egen adju = adju(mpg), by(foreign)</b>
<p>
    <b>corr(</b><i>varname1 varname2</i><b>)</b> [ <b>,</b> <b><u>c</u></b><b>ovariance</b> <b><u>s</u></b><b>pearman</b> <b>taua</b> <b>taub</b> <b>by(</b><i>byvarlist</i><b>)</b> ]
        returns the correlation of <i>varname1</i> with <i>varname2</i>.  By default, this
        returns the Pearson correlation coefficient.  <b>covariance</b> indicates
        that covariances should be calculated; <b>spearman</b> indicates that
        Spearman's rank correlation coefficient should be calculated; <b>taua</b>
        and <b>taub</b> return Kendall's tau-A and tau-B, respectively. (Stata 8
        required.)
<p>
    <b>density(</b><i>varname</i><b>)</b> [ <b>,</b> <b><u>w</u></b><b>idth(</b><i>#</i><b>)</b> <b><u>st</u></b><b>art(</b><i>#</i><b>)</b> <b><u>freq</u></b><b>uency</b> <b>percent</b> <b><u>frac</u></b><b>tion</b>
        <b>by(</b><i>byvarlist</i><b>)</b> ] calculates the density (or optionally the <b>frequency</b>,
        <b>fraction</b> or <b>percent</b>) of values in bins of width <b>width()</b> (default 1)
        starting at <b>start()</b> (default minimum of the data). Note that each
        value produced will be identical for all observations in the same
        bin. Commonly for further use it will be desired to select one value
        from each bin, say by using egen's <b>tag()</b> function. (Stata 8
        required.)
<p>
    <b>gmean(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] returns the geometric mean of <i>exp</i>. (Stata
        6 required.)
<p>
    <b>. egen gmean = gmean(mpg), by(rep78)</b>
<p>
    <b>hmean(</b><i>exp</i><b>)</b> [ <b>, by(</b><i>byvarlist</i><b>)</b> ] returns the harmonic mean of <i>exp</i>. (Stata 6
        required.)
<p>
    <b>. egen hmean = hmean(mpg), by(rep78)</b>
<p>
    <b>nmiss(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] returns the number of missing values in
        <i>exp</i>. (Stata 6 required.) Remark: Why this was written is a mystery.
        The one-line command <b>egen nmiss = sum(missing(</b><i>exp</i><b>)</b> (in Stata 9 <b>egen</b>
        <b>nmiss = total(missing(</b><i>exp</i><b>)</b>) shows that it is unnecessary.
<p>
    <b>. egen nmiss = nmiss(rep78), by(foreign)</b>
<p>
    <b>nvals(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b><u>miss</u></b><b>ing</b> ] returns the number of distinct
        values in <i>varname</i>. Missing values are ignored unless <b>missing</b> is
        specified.  Remark: Much can be done by using egen function <b>tag()</b> and
        then summing values as desired. (Stata 6 required.)
<p>
    <b>outside(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b><u>fact</u></b><b>or(</b><i>#</i><b>)</b> ] calculates outside values.
        These are any values more than <b>factor()</b> times the interquartile range
        from the nearer quartile, that is above the upper quartile or below
        the lower quartile.  By default <b>factor()</b> is 1.5, defining the default
        outside values, those plotted separately, on a Stata box plot.
        Values not outside are returned as missing.  (Stata 8 required.)
<p>
    <b>ridit(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> <b><u>miss</u></b><b>ing</b> <b><u>perc</u></b><b>ent</b> <b><u>rev</u></b><b>erse</b> ] calculates the
        ridit for <i>varname</i>, which is
<p>
        (1/2) count at this value + SUM counts in values below 
        ------------------------------------------------------
                       SUM counts of all values               
<p>
        With terminology from Tukey (1977, pp.496-497), this could be called
        a `split fraction below'. The name `ridit' was used by Bross (1958):
        see also Fleiss (1981, pp.150-7) or Flora (1988). The numerator is a
        `split count'.
<p>
        <b>missing</b> specifies that observations for which values of <i>byvarlist</i> are
        missing will be included in calculations if <b>by()</b> is specified. The
        default is to exclude them. <b>percent</b> scales the numbers to percents by
        multiplying by 100.  <b>reverse</b> specifies the use of reverse cumulative
        probabilities (1 - fraction above). (Stata 6 required.)
<p>
    <b>semean(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] calculates the standard error of the mean
        of <i>exp</i>. (Stata 6 required.)
<p>
    <b>sumoth(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] returns the sum of the other values of
        <i>exp</i> in the same group. If <b>by()</b> is specified, distinct combinations of
        <i>byvarlist</i> define groups; otherwise all observations define one group.
        (Stata 6 required.)
<p>
    <b>var(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] creates a constant (within <i>byvarlist</i>)
        containing the variance of <i>exp</i>.  Note also the egen function <b>sd()</b>.
        (Stata 6 required.)
<p>
    <b>wpctile(</b><i>varname</i><b>)</b> [ <b>,</b> <b>p(</b><i>#</i><b>)</b> <b><u>w</u></b><b>eights(</b><i>varname</i><b>)</b> <b><u>alt</u></b><b>def</b> <b>by(</b><i>byvarlist</i><b>)</b> ] is a
        hack on official Stata's <b>egen</b> function <b>pctile()</b> allowing
        specification of weights in the calculation of percentiles. By
        default, the function creates a constant (within <i>byvarlist</i>)
        containing the <i>#</i>th percentile of <i>varname</i>. If <b>p()</b> is not specified, 50
        is assumed, meaning medians. <b>weights()</b> requests weighted calculation
        of percentiles. <b>altdef</b> uses an alternative formula for calculating
        percentiles, which is not applicable with weights present. <b>by()</b>
        requests calculation by groups.  You may also use the <b>by:</b> construct.
        (Stata 8.2 required.)
<p>
    <b>wtfreq(</b><i>exp</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] creates a constant (within <i>byvarlist</i>)
        containing the weighted frequency using <i>exp</i> as weights. (Such
        frequencies sum to <b>_N</b>.) (Stata 6 required.)
<p>
    <b>xtile(</b><i>varname</i><b>)</b> [ <b>,</b> <b><u>p</u></b><b>ercentiles(</b><i>numlist</i><b>)</b> <b><u>n</u></b><b>quantiles(</b><i>#</i><b>)</b> <b><u>w</u></b><b>eights(</b><i>varname</i><b>)</b>
        <b><u>alt</u></b><b>def</b> <b>by(</b><i>byvarlist</i><b>)</b> ] categorizes <i>varname</i> by specific percentiles.
        The function works like xtile. By default <i>varname</i> is dichotomized at
        the median. <b>percentiles()</b> requests percentiles corresponding to
        <i>numlist</i>: for example, <b>p(25(25)75)</b> is used to create a variable
        according to quartiles. Alternatively you also may have specified
        <b>n(4)</b>: to create a variable according to quartiles.  <b>weights()</b>
        requests weighted calculation of percentiles.  <b>altdef</b> uses an
        alternative formula for calculating percentiles.  See xtile. <b>by()</b>
        requests calculation by groups.  You may also use the <b>by:</b> construct.
        (Stata 8.2 required.)
<p>
    <b>. egen mpg4 = xtile(mpg), by(foreign) p(25(25)75)</b>
    <b>. egen mpg10 = xtile(mpg), by(foreign) nq(10)</b>
<p>
<p>
<b><u>First and last</u></b> 
<p>
    <b>first(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] returns the first non-missing value of
        <i>varname</i>. `First' depends on the existing order of observations.
        <i>varname</i> may be numeric or string.  (Stata 6 required.)
<p>
    <b>ifirst(</b><i>numvar</i><b>)</b> <b>,</b> <b><u>v</u></b><b>alue(</b><i>#</i><b>)</b> [ { <b><u>be</u></b><b>fore</b> | <b><u>a</u></b><b>fter</b> } <b>by(</b><i>byvarlist</i><b>)</b> ] indicates
        the first occurrence of integer <i>#</i> within <i>numvar</i> by 1 and other
        observations by 0.
<p>
        <b>before</b> indicates observations before the first occurrence by 1 and
        other observations by 0.  <b>after</b> indicates observations after the
        first occurrence by 1 and other observations by 0.  The default, the
        value <b>before</b> and the value <b>after</b> always sum to 1 for observations
        analysed.
<p>
        First occurrence is determined as follows: (1) if <b>if</b> or <b>in</b> is
        specified, any observations excluded are ignored; (2) if <b>by()</b> is
        specified, first is determined separately for each distinct group of
        observations; (3) first is first in current sort order.  If <i>#</i> does
        not occur, all observations are before the first occurrence. (Stata 6
        required.)
<p>
    <b>. gen warm = celstemp &gt; 20</b>
    <b>. egen fwarm = ifirst(warm), v(1) by(year)</b>
<p>
    <b>ilast(</b><i>numvar</i><b>)</b> <b>,</b> <b><u>v</u></b><b>alue(</b><i>#</i><b>)</b> [ { <b><u>be</u></b><b>fore</b> | <b><u>a</u></b><b>fter</b> } <b>by(</b><i>byvarlist</i><b>)</b> ] indicates
        the last occurrence of integer <i>#</i> within <i>numvar</i> by 1 and other
        observations by 0.
<p>
        <b>before</b> indicates observations before the last occurrence by 1 and
        other observations by 0.  <b>after</b> indicates observations after the last
        occurrence by 1 and other observations by 0.  The default, the value
        <b>before</b> and the value <b>after</b> always sum to 1 for observations analysed.
<p>
        Last occurrence is determined as follows: (1) if <b>if</b> or <b>in</b> is
        specified, any observations excluded are ignored; (2) if <b>by()</b> is
        specified, last is determined separately for each distinct group of
        observations; (3) last is last in current sort order.  If <i>#</i> does not
        occur, all observations are before the last occurrence. (Stata 6
        required.)
<p>
    <b>lastnm(</b><i>varname</i><b>)</b> [ <b>,</b> <b>by(</b><i>byvarlist</i><b>)</b> ] returns the last non-missing value of
        <i>varname</i>. `Last' depends on the existing order of observations.
        <i>varname</i> may be numeric or string. Remark: <b>lastnm()</b> would have been
        better called <b>last()</b>, except that an <b>egen</b> program with that name for
        selecting the last `word' in a string was published in STB-50.
        (Stata 6 required.)
<p>
<p>
<b><u>Random numbers</u></b> 
    
    <b>mixnorm()</b> [ <b>,</b> <b>frac(</b><i>#</i><b>)</b> <b>mu1(</b><i>#</i><b>)</b> <b>mu2(</b><i>#</i><b>)</b> <b>var1(</b><i>#</i><b>)</b> <b>var2(</b><i>#</i><b>)</b> ] generates a new
        variable of specified type as a mixture of two Normal distributions,
        with the fraction <b>frac(</b><i>#</i><b>)</b> of the observations defined by the first
        distribution.  Both options for means <b>mu1(</b><i>#</i><b>)</b> and <b>mu2(</b><i>#</i><b>)</b> default to 0;
        both options for variances <b>var1(</b><i>#</i><b>)</b> and <b>var2(</b><i>#</i><b>)</b> default to 1, while
        <b>frac(</b><i>#</i><b>)</b> defaults to 0.5. Only non-default parameters of the desired
        mixture need be specified. (Stata 8 required.)
<p>
    <b>. egen mixture = mixnorm(), frac(0.9) mu2(10) var2(4)</b>
<p>
    <b>rndint()</b> <b>,</b> <b><u>ma</u></b><b>x(</b><i>#</i><b>)</b> [ <b><u>mi</u></b><b>n(</b><i>#</i><b>)</b> ] generates random integers from a uniform
        distribution on <b>min()</b> to <b>max()</b>, inclusive. <b>min(1)</b> is the default.
        Remark: Note that <b>ceil(uniform() * </b><i>#</i><b>)</b> is a direct way to get random
        integers from 1 to <i>#</i>. (Stata 6 required.)
<p>
    <b>. egen integ = rndint(), min(100) max(199)</b>
<p>
    <b>rndsub()</b> [ <b>,</b> <b><u>ng</u></b><b>roup(</b><i>#</i><b>)</b> { <b><u>f</u></b><b>rac(</b><i>#</i><b>)</b> | <b><u>p</u></b><b>ercent(</b><i>#</i><b>)</b> } <b>by(</b><i>byvarlist</i><b>)</b> ] randomly
        splits observations into groups or subsamples. The result is a
        categorical variable taking values from 1 upward labelling distinct
        groups.
<p>
        <b>ngroup(</b><i>#</i><b>)</b> (default 2) defines the number of groups.
<p>
        <b>frac(</b><i>#</i><b>)</b>, which is only allowed with <b>ngroup(2)</b>, specifies that the
        first group should contain 1 / <i>#</i> of the observations and thus that
        the second group should contain the remaining observations.
<p>
        <b>percent(</b><i>#</i><b>)</b>, which is only allowed with <b>ngroup(2)</b>, specifies that the
        first group should contain <i>#</i>% of the observations and thus that the
        second group should contain the remaining observations.
<p>
        <b>frac()</b> and <b>percent()</b> may not be specified together.  (Stata 6
        required.)
<p>
    <b>. egen group = rndsub(), by(foreign)</b>
<p>
    <b>. egen group = rndsub(), by(foreign) f(3)</b>
    (first group contains 1/3 of observations, second group contains 2/3)
<p>
    <b>. egen group = rndsub(), by(foreign) p(25)</b>
    (first group contains 25% of observations, second group contains 75%)
<p>
    For reproducible results, set the seed of the random number generator
    beforehand and document your choice.
<p>
    Note that to generate <i>#</i> random numbers the number of observations must be
    at least <i>#</i>. If there are no data in memory and you want 100 random
    numbers, type <b>set obs 100</b> before using these functions.
<p>
<p>
<b><u>Row operations</u></b> 
    
    <b>rall(</b><i>varlist</i><b>)</b> <b>,</b> <b><u>c</u></b><b>ond(</b><i>condition</i><b>)</b> [ <b><u>sy</u></b><b>mbol(</b><i>symbol</i><b>)</b> ] returns 1 for
        observations for which the condition specified is true for all
        variables in <i>varlist</i> and 0 otherwise. The condition should be
        specified using <b>symbol()</b>, by default <b>@</b>, as a placeholder for each
        variable.  Thus, for example, <b>rall(</b><i>varlist</i><b>), c(@ &gt; 0 &amp; @ &lt; .)</b> tests
        whether all variables in <i>varlist</i> are positive and non-missing. Note
        that conditions typically make sense only if variables are either all
        numeric or all string: one exception is <b>missing(@)</b>.  (Stata 6
        required.)
<p>
    <b>rany(</b><i>varlist</i><b>)</b> <b>,</b> <b><u>c</u></b><b>ond(</b><i>condition</i><b>)</b> [ <b><u>sy</u></b><b>mbol(</b><i>symbol</i><b>)</b> ] returns 1 for
        observations for which the condition specified is true for any
        variable in <i>varlist</i> and 0 otherwise. The condition should be
        specified using <b>symbol()</b>, by default <b>@</b>, as a placeholder for each
        variable.  Thus, for example, <b>rany(</b><i>varlist</i><b>), c(@ &gt; 0 &amp; @ &lt; .)</b> tests
        whether any variable in <i>varlist</i> is positive and non-missing.  Note
        that conditions typically make sense only if variables are either all
        numeric or all string: one exception is <b>missing(@)</b>.  (Stata 6
        required.)
<p>
    <b>rcount(</b><i>varlist</i><b>)</b> <b>,</b> <b><u>c</u></b><b>ond(</b><i>condition</i><b>)</b> [ <b><u>sy</u></b><b>mbol(</b><i>symbol</i><b>)</b> ] returns the number
        of variables in <i>varlist</i> for which the condition specified is true.
        The condition should be specified using <b>symbol()</b>, by default <b>@</b>, as a
        placeholder for each variable. Thus, for example, <b>rcount(</b><i>varlist</i><b>),</b>
        <b>c(@ &gt; 0 &amp; @ &lt; .)</b> counts for each observation how many variables in
        <i>varlist</i> are positive and non-missing. Note that conditions typically
        make sense only if variables are either all numeric or all string:
        one exception is <b>missing(@)</b>.  More precisely, <b>rcount()</b> gives the sum
        across <i>varlist</i> of condition, evaluated in turn for each variable.
        (Stata 6 required.)
<p>
    For <b>rall()</b>, <b>rany()</b>, and <b>rcount()</b>, the <b>symbol()</b> option may be used to set
    an alternative to <b>@</b> whenever the latter is inappropriate. For example, if
    string variables were being searched for literal occurrences of <b>"@"</b>, some
    other symbol not appearing in text or in variable names should be used.
<p>
    <b>. egen any = rany(b c d e f) , c(@ == a)</b>
    <b>. egen all = rall(b c d e f) , c(@ == a)</b>
    <b>. egen count = rcount(b c d e f) , c(@ == a)</b>
    (values of <b>b c d e f</b> matched by (equal to) those of <b>a</b>?)
<p>
    <b>. egen anyw1 = rany(b c d e f) , c(abs(@ - a) &lt;= 1)</b>
    <b>. egen allw1 = rall(b c d e f) , c(abs(@ - a) &lt;= 1)</b>
    <b>. egen countw1 = rcount(b c d e f) , c(abs(@ - a) &lt;= 1)</b>
    (values of <b>b c d e f</b> within 1 of those of <b>a</b>?)
<p>
    From Stata 7, foreach provides an alternative that would now be
    considered better style:
<p>
    <b>. gen any = 0</b>
    <b>. gen all = 1</b>
    <b>. gen count = 0</b>
    <b>. foreach v of var a b c d e f {</b>
    <b>.         replace any = max(any, inrange(`v', 0, .))</b>
    <b>.         replace all = min(all, inrange(`v', 0, .))</b>
    <b>.         replace count = count + inrange(`v', 0, .)</b>
    <b>. }</b>
<p>
    <b>rowmedian(</b><i>varlist</i><b>)</b> returns the median across observations of the
        variables in <i>varlist</i>.  (Stata 9 required.)
<p>
    <b>rsum2(</b><i>varlist</i><b>)</b> is a generalisation of egen's <b>rsum()</b> (from Stata 9:
        <b>rowtotal()</b>) function with the extra options <b><u>allm</u></b><b>iss</b> and <b><u>anym</u></b><b>iss</b>.  As
        with <b>rsum()</b>, it creates the (row) sum of the variables in <i>varlist</i>,
        treating missing as 0.  However, if the option <b>allmiss</b> is selected,
        the (row) sum for any observation for which all variables in <i>varlist</i>
        are missing is set equal to missing. Similarly, if the option <b>anymiss</b>
        is selected the (row) sum for any observation for which any variable
        in <i>varlist</i> is missing is set equal to missing. (Stata 6 required.)
<p>
<p>
<b><u>References</u></b>
<p>
    Bross, I.D.J. 1958. How to use ridit analysis. <i>Biometrics</i> 14: 38-58.
<p>
    Fleiss, J.L. 1981. <i>Statistical Methods for Rates and Proportions.</i>  New
        York: John Wiley.
<p>
    Flora, J.D. 1988. Ridit analysis. In Kotz, S. and Johnson, N.L. (eds)
        <i>Encyclopedia of Statistical Sciences.</i> New York: John Wiley. 8:
        136-139.
<p>
    Tukey, J.W. 1977. <i>Exploratory Data Analysis.</i> Reading, MA: Addison-Wesley.
<p>
<p>
<b><u>Maintainer</u></b> 
<p>
    Nicholas J. Cox, Durham University, U.K.
    n.j.cox@durham.ac.uk
<p>
<p>
<b><u>Acknowledgements</u></b>
<p>
    Kit Baum (baum@bc.edu) is the first author of <b>record()</b> and the author of
    <b>dhms()</b>, <b>elap()</b>, <b>elap2()</b>, <b>hms()</b>, <b>tod()</b> and <b>mixnorm()</b>.
<p>
    Ulrich Kohler (kohler@wzb.eu) is the author of <b>xtile()</b>, <b>mlabvpos()</b>,
    <b>iso3166()</b> and <b>wpctile()</b>.
<p>
    Steven Stillman (s.stillman@verizon.net) is the author of <b>rsum2()</b>.
<p>
    Nick Winter (njw3x@virginia.edu) is the author of <b>corr()</b> and <b>noccur()</b>.
<p>
    Kit Baum, Sascha Becker, Ronn Conroy, William Gould, Syed Islam, John
    Moran, Stephen Soldz, Richard Williams, Fred Wolfe and Gerald Wright
    provided stimulating and helpful comments.
<p>
<p>
<b><u>Also see</u></b>
<p>
    STB: STB-50 dm70 for <b>atan2()</b>, <b>pp()</b>, <b>rev()</b>, <b>rindex()</b>, <b>rmed()</b>, <b>rotate()</b>
<p>
    Manual: [D] egen (before Stata 9 [R] egen)
<p>
    On-line: help for egen, dates, functions, means, numlist, seed, tsset, 
             varlist (timeseries operators), circular (if installed), 
             ntimeofday (if installed), stimeofday (if installed)
<p>
</pre>