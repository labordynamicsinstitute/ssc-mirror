cls;
/*******************************************************************************************************************************************/
/*	READ ME FIRST:																						*/
/*	This code includes the following six sections:																			 */
/*	SecA: About this code & accreditations,																		 */
/*	SecB: Declaration and initialisation of variables,																 */
/*	SecC: Setting parameters,																				 */
/*	SecD: Processing data,																					 */
/*	SecE: Printing results,																					 */
/*	SecF: Procedures.																						 */
/********************************************************************************************************************************************/

/*==========================================================================================================*/
/*================		Section A: ABOUT THIS CODE AND ACCREDITATIONS - START 			=======================*/
/*==========================================================================================================*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*	Comments:																							*/
/*	Application short title: DASCT01 																			*/
/*	Application full title: Gauss Module for Estimating the Dynamic Asymmetric and Symmetric Causality Tests				*/
/*	Version: 1.0																							*/
/*	Authors: Abdulnasser Hatemi-J and Alan Mustafa																*/
/*	The UAE University and the IEEE																			*/
/*	E-mails: (AHatemi@uaeu.ac.ae) and (alan.mustafa@ieee.org)													*/
/*																										*/
/*	This Gauss module estimates the dynamic asymmetric causality tests developed by Hatemi-J (2012, 2021). 				*/
/*	The subsamples can be determined by (a) the fixed rolling window or by (b) the recursive rolling window anchored to the start.*/
/*	The dynamic tests are estimated along with the bootstrap critical values with leverage adjustments for both 5% and		*/
/*	10% 	significance levels. It also estimates the dynamic symmetric causality tests developed by Hacker and 				*/
/*	Hatemi-J (2006, 2012). For technical details see the following:													*/
/*      -(1) Hatemi-J A. (2021) Dynamic Asymmetric Causality Tests with an Application, Papers 2106.07612, arXiv.org.			*/
/*	-(2) Hatemi-J A. (2012) Asymmetric Causality Tests with an Application, Empirical Economics, 43, 447-456. 				*/																	
/*	-(3) Hacker S. and Hatemi-J A. (2006) Tests for causality between integrated variables using asymptotic and bootstrap 		*/
/*	distributions: theory and application, Applied Economics, 38(13), 1489-1500.							 			*/
/*	-(4) Hacker S. and Hatemi-J A. (2012) A bootstrap test for causality with endogenous lag length choice: theory and			*/
/*	 application in finance, Journal of Economic Studies, 39(2), 144-160. 												*/
/*																										*/
/*	This program code is the copyright of the authors. Applications are allowed only if proper reference						*/
/*	and acknowledgments are provided. For non-Commercial applications only. No performance							*/
/*	guarantee is made. Bug reports are welcome. If this code is used for research or in any other							*/
/*	code, proper attribution needs to be included.																*/
/*																										*/
/*																										*/
/*	© 2021 Prof. Abdulnasser Hatemi-J and Dr. Alan Mustafa														*/
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*==========================================================================================================*/
/*================		Section A: ABOUT THIS CODE AND ACCREDITATIONS -   END  			=======================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		Section B: DECLARATION AND INITIALISATION OF VARIABLES - START 		===================*/
/*==========================================================================================================*/

rndseed 30540; 
declare s, T, col_no, ssg, ssg_start, ssg_end, ssg_values,ssg_All_values,z,theRatio;
declare s_1, ssg_c, ending_loop, last_index_in_loop, type_sample_sizing, print_er, toc;

/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/                                        
bootsimmax = 1000;    @the maximum # of simulations for computing bootstrapped critical values. It should be a multiple of 20 @
infocrit = 5; 	  @ Information criterion used: 1=AIC, 2=AICC, 3=SBC, 4=HQC, 5=HJC, 6=use maxlags @

maxlags = ?;	@Maximum lag order in the VAR model (without additional lags for unit roots)@
intorder =?;	@Integration order. 0 zero means stationary variables, 1 means one unit root, 2 means two unit roots.@


/*==========================================================================================================*/
/*================		Section B: DECLARATION AND INITIALISATION OF VARIABLES -  END 		===================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		Section C: SETTING PARAMETERS - START 		===========================================*/
/*==========================================================================================================*/

/*--------------------------------		SELECTION OF TYPE OF CAUSALITY 	--------------------------------------------------------------------------------------------------------*/
/*	Select the Type Of Causality (toc) you require for testing, below:	*/
/*	toc = 1 => Dynamic Symmetric Causality Tests (DSCT)			*/
/*	toc = 2 => Dynamic Asymmetric Causality Tests (DACT)			*/
toc = 2;

/*--------------------------------		DATASET SELECTION		 		--------------------------------------------------------------------------------------------------------*/
/*	Please enter the DataSet file name in *.txt format, below:		*/
dataSet_ = "?.txt";

/*--------------------------------		DEFINING NUMBER OF VARIABLES (COLUMNS) IN THE DATASET	--------------------------------------------------------*/
/*	Enter the number of variables (columns) in your dataset below:	*/
Numvars = ?;

/*--------------------------------		TYPE OF SAMPLE SIZING 	-----------------------------------------------------------------------------------------------------------------------*/
/*	1: Fixed Rolling Window Approach (constant sample sizing)	= (css_1)	*/
/*	2: Recursive Rolling Window Approach (increased sample sizing)	= (iss_2)	*/
type_sample_sizing = 2;		/* Adjust this number as listed above so to select the type of sample sizing*/

/*--------------------------------		SELECT POSITIVE / NEGATIVE FOR CAUSALITY 	---------------------------------------------------------------------------------------*/
/*	1: If causality for positive changes is under investigaton	*/
/*	2: If causality for negative changes is under investigaton	*/
cpn = 2;

/*--------------------------------		PRINTING DETAILS	--------------------------------------------------------------------------------------------------------------------------------------*/
/*	1: Printing all 'Estimation Results' (calculations for AhatTU, AhatTR, Wstat, Wcriticalvalues and few other variables		      */
/*	2: Print only the Time-Varying Causality Test Results and ignore printing the 'Estimation Results'						      */
print_er = 1;	/*	print_er: Print Estimation Results	*/

/*==========================================================================================================*/
/*================		Section C: SETTING PARAMETERS -   END 		===========================================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		Section D: PROCESSING DATA - START 		===========================================*/
/*==========================================================================================================*/

/*--------------	DATASET MANIPULATION	---------------------------------*/
load YZlevel[]  = ^dataSet_; 					/* The data file. */

Levnumobs = (rows(YZlevel)/Numvars);
YZlevel = Reshape(YZlevel, Levnumobs, Numvars);

/*--------------	PROCESS OF DATASET MANIPULATION BASED ON THE TYPE OF DYNAMIC CAUSALITY TEST		------------------------------*/

if toc == 1;		/*Dynamic Symmetric Causality Tests (DSCT)*/

	M = YZlevel;

else;			/*Dynamic Asymmetric Causality Tests (DACT)*/
	
	dYZ = YZlevel[2:Levnumobs,.] -  YZlevel[1:(Levnumobs-1),.];
	numobs = Levnumobs - 1;
	
	notpositive = DYZ .le 0;
	notnegative= DYZ .ge 0;
	
	DYZpc = zeros(numobs,Numvars);
	DYZnc = zeros(numobs,Numvars);
	
	colnum = 1;
	do until colnum > Numvars;
		DYZpc[.,colnum] = recode(DYZ[.,colnum],notpositive[.,colnum],0);
	 	DYZnc[.,colnum] = recode(DYZ[.,colnum],notnegative[.,colnum],0);
		colnum = colnum + 1;
	endo;

	CumDYZpc = cumsumc(DYZpc);
	CumDYZnc = cumsumc(DYZnc);
	
	if cpn == 1;				/*	cpn =1 => positives		*/
		z=CUMDYZpc;
	else; 					/*	cpn = 2 => negatives	*/
		z=CUMDYZnc;
	endif;
	
	M=z;

endif;

/*==========================================================================================================*/
/*================		DATASET SELECTION -  END  		===================================================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		START OF LOOP 	===================================================================*/	
/*==========================================================================================================*/

T = rows(M);
col_no = cols(M);

/*---------------		CALCULATING 's'		--------------------------------*/
s = ceil(T * (0.01 + (1.8 / sqrt(T))));
/*------------------------------------------------------------------------------------------------------*/

s_1 = T;
ssg_ = zeros(s_1,1);
no_ssg = T-s+1;			/*no_ssg = number of groups of sub-samples*/

Wstat_ = zeros(s_1,1);
WcriticalvalsS_ = zeros(s_1,1);
theRatio = zeros(s_1,1);
WcriticalvalsS_10 = zeros(s_1,1);
theRatio_10 = zeros(s_1,1);

/*--------------		Printing explanatory informaton on the report 	---------------------------------*/

print "This Gauss module estimates the dynamic asymmetric causality tests developed by Hatemi-J (2012, 2021).";
print "The subsamples can be determined by (a) the fixed rolling window or by (b) the recursive rolling window anchored to the start.";
print "The dynamic tests are estimated along with the bootstrap critical values with leverage adjustments for both 5% and";
print "10% 	significance levels. It also estimates the dynamic symmetric causality tests developed by Hacker and";
print "Hatemi-J (2006, 2021). For technical details see the following:";
print "-(1) Hatemi-J A. (2021) Dynamic Asymmetric Causality Tests with an Application, Papers 2106.07612, arXiv.org.";
print "-(2) Hatemi-J A. (2012) Asymmetric Causality Tests with an Application, Empirical Economics, 43, 447-456.";
print "-(3) Hacker S. and Hatemi-J A. (2006) Tests for causality between integrated variables using asymptotic and bootstrap";
print "distributions: theory and application, Applied Economics, 38(13), 1489-1500.";
print "-(4) Hacker S. and Hatemi-J A. (2012) A bootstrap test for causality with endogenous lag length choice: theory and";
print "application in finance, Journal of Economic Studies, 39(2), 144-160.";
print "";
print "This program code is the copyright of the authors. Applications are allowed only if proper reference";
print "and acknowledgments are provided. For non-Commercial applications only. No performance";
print "guarantee is made. Bug reports are welcome. If this code is used for research or in any other";
print "code, proper attribution needs to be included.";
print "";
print "===============================================================================================";
print "";

if print_er == 1;
	print "-------------------------------------------------------------------------";
	print "\t\tESTIMATION RESULTS";
	print "-------------------------------------------------------------------------";
endif;
/*-----------------------------------------------------------------------------------------------*/
/*--------------	INITIALIZATION OF LOOP - START		---------*/
/*----------------------------------------------------------------------------------------------*/

if type_sample_sizing == 1;
	if print_er == 1;
		print "Number of records in each Sub-Samples = " s;
	endif;
endif;
if print_er == 1;
	print "Number of groups of Sub-Samples = " no_ssg;
	print "-------------------------------------------------------------------------";
endif;

ssg = 1;
if type_sample_sizing == 2;
	ssg_c = 1;
endif;

last_index_in_loop = ssg+s-1;	/*last_index_in_loop = the last record of the group of sub-samples for the loop*/

/*-----------------------------------------------------------------------------------------------*/
/*--------------	INITIALIZATION OF LOOP -  END 		---------*/
/*----------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------			START OF SAMPLE SIZING LOOP	 		-------------------------------------------------------*/

do until last_index_in_loop > T;

	rndseed 300540;
	ssg_[ssg,1] = ssg;

	if type_sample_sizing == 1;		/*	CSS_1	*/
		ssg_start=ssg;
	else;						/*	ISS_2	*/
		if print_er == 1;
			print "Sub-Sample Size = " last_index_in_loop;
		endif;
		ssg_start=ssg_c;			/*_c: means keep the ssg_c constant*/
	endif;
	
	ssg_end = ssg + s-1;
	if print_er == 1;
		print "\ssg_start - ssg_end => ";; print ssg_start;; print ssg_end;;
		print "";
		print "-------------------------------------------------------------------------";
	endif;

	ssg_values=zeros(s,col_no);

	if type_sample_sizing == 1;		/*	CSS_1	*/
		z=zeros(s,col_no);
	else;						/*	ISS_2	*/
		z=zeros(ssg_end,col_no);
	endif;

	x = 1;

	for ssg_index (ssg_start, ssg_end, 1);
		for c (1,col_no,1);
			z[x,c] = M[ssg_index,c];
		endfor;
		x = x + 1;
	endfor;

	if print_er == 1;
		print "";
	endif;

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*--------------------------------		START OF Decision Maker Unit (DMU)			------------------------------------------------------------------------------*/
	/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	addlags = intorder;
	numvars = cols(z);
	
        {aiclag, aicclag, sbclag, hqclag, hjiclag, aicA, aiccA, sbcA, hqcA, hjicA, onelA, nocando} = lag_length2(z,1,maxlags);
	
	If infocrit == 1;
 	    ICOrder = aiclag;
	elseif infocrit == 2;
 	    ICOrder = aicclag;
        elseif infocrit == 3;
	    ICOrder = sbclag;
 	elseif infocrit == 4; 
	    ICOrder = hqclag;
 	elseif infocrit == 5; 
	    ICOrder = hjiclag;
 	elseif infocrit == 6; 
	    ICOrder = maxlags;
	endif;	
	
        {yT, ylags} = varlags(z, (ICorder + addlags));
        numobs = rows(yT);
        xT = ones(numobs,1)~ylags;
	
        {yS, ylags} = varlags(z, ICorder);
        numobs = rows(yS);
        xS = ones(numobs,1)~ylags;                     
	
	{Rvector1, Rmatrix1} = rstrctvm(numvars, ICorder, addlags);
	
 	{AhatTU,leverageTU} = estvar_params(yT, XT,0,0,ICorder,addlags);
        {AhatTR,leverageTR} = estvar_params(yT, XT,1,Rvector1,ICorder,addlags);
        {AhatSR,leverageSR} = estvar_params(yS, XS,1,Rvector1[.,1:(1+numvars*ICorder)],ICorder,0);
        If addlags > 0;
            AhatSR  = AhatSR~zeros(numvars,numvars*addlags);
        endif;
	
	if print_er == 1;
		"AhatTU=";;AhatTU;
		"AhatTR=";;AhatTR;
	endif;
	
	{Wstat} = W_Test(yT, XT, AhatTU, Rmatrix1);
	{WcriticalvalsS} = Bootstrap_Toda(yT, XT, z[1:(ICorder + addlags),.], AhatSR,leverageSR,ICorder,addlags,bootsimmax,Rmatrix1);
	rejectnullchi= (cdfchic(Wstat,ICorder).<0.01) | (cdfchic(Wstat,ICorder).<0.05) | (cdfchic(Wstat,ICorder).<0.10);
	rejectnullbootS=(Wstat.>WcriticalvalsS[1,.]) | (Wstat.>WcriticalvalsS[2,.]) | (Wstat.>WcriticalvalsS[3,.]); 
                      
	if print_er == 1;
		print "-------------------------------------------------------------------------";
	endif;

	{Azdsys} = Azd(ICorder);
	format /rd 5,3;
	
	if print_er == 1;
		"Information criterion used; lags based on that =";;
	endif;
	If infocrit == 1;
		if print_er == 1;
			"AIC ";;aiclag;
		endif;
	elseif infocrit == 2; 
		if print_er == 1;
			"AICC ";;aicclag;
		endif;
	elseif infocrit ==3;
		if print_er == 1;
			"SBC ";;sbclag;
		endif;
	elseif infocrit ==4;
		if print_er == 1;
			"HQC ";;hqclag;
		endif;
	elseif infocrit ==5;
		if print_er == 1;
			"Hatemi-J Criterion (HJC) ";;hjiclag;
		endif;
	elseif infocrit ==6;
		if print_er == 1;
			"user given:";;maxlags;
		endif;
	endif;

	if print_er == 1;
		"Varorder chosen by information criterion (excluding augmentation lag(s)) is ";;ICorder;
		"Additional lags=";;addlags;
		"Wstat = ";; Wstat;
		"Wcriticalvals=";;WcriticalvalsS;
		/*"rejectnullchi=";;rejectnullchi;
		"rejectnullbootS=";;rejectnullbootS; */
	endif;

	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*--------------------------------		 END  OF Decision Maker Unit (DMU)			-------------------------------------------------------------------------------*/
	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	ssg_[ssg] = ssg;
	Wstat_[ssg] = Wstat;
	WcriticalvalsS_[ssg] = WcriticalvalsS[2];
	theRatio[ssg] = Wstat/WcriticalvalsS[2];
	
	WcriticalvalsS_10[ssg] = WcriticalvalsS[3];
	theRatio_10[ssg] = Wstat/WcriticalvalsS[3];
	
	if print_er == 1;
		print "\t\t\t\t\t\t\t\t        Test Value per Critical Value = " theRatio[ssg];
		if theRatio > 1;
			print "\t\t\t\t\t\t\tThe null hypothesis of no causality is rejected.";
		else;
			print "\t\t\t\t\t         The null hypothesis of no causality is not rejected.";
		endif;
	endif;
	ssg = ssg+1;
	last_index_in_loop = last_index_in_loop + 1;
	
	if print_er == 1;
		print "=================================================================";
		print "";
	endif;
endo;

/*------------------------------------------------------------			 END  OF SAMPLE SIZING LOOP	 		--------------------------------------------------------------*/

/*==========================================================================================================*/
/*================		Section D: PROCESSING DATA -  END  		===============================================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		Section E: PRINTING RESULTS - START 		===========================================*/
/*==========================================================================================================*/

print "\t\t\tTime-Varying Causality Test Results (5%)";

if type_sample_sizing ==1;
	print "\t\t\t\tfor Fixed Rolling Window Approach";
else;
	print"\t\t\t\tfor Recursive Rolling Window Approach";
endif;

print "\t---------------------------------------------------------------------------------------------";
print "\tSSP\t\tTest Value\t5% Bootstrap CV\tTVpCV";
print "\t---------------------------------------------------------------------------------------------";

for table (1,no_ssg,1);

	format /rd 1,0;
	print " \t" ssg_[table];;
	format /rd 1,3;

	print "\t\t" Wstat_[table];; print "\t\t" WcriticalvalsS_[table];; print "\t\t\t" theRatio[table];
endfor;

print "=======================================================";
print "";

/*---------------------------------------------*/
print "\t\t\tTime-Varying Causality Test Results (10%)";

if type_sample_sizing ==1;
	print "\t\t\t\tfor Rolling Window Approach";
else;
	print"\t\t\t\tfor Recursive Approach";
endif;

print "\t---------------------------------------------------------------------------------------------";
print "\tSSP\t\tTest Value\t10% Bootstrap CV\tTVpCV";
print "\t---------------------------------------------------------------------------------------------";

for table (1,no_ssg,1);

	format /rd 1,0;
	print " \t" ssg_[table];;
	format /rd 1,3;

	print "\t\t" Wstat_[table];; print "\t\t" WcriticalvalsS_10[table];; print "\t\t\t" theRatio_10[table];
endfor;

/*------------------------------------------------------------			START OF PRINGINT REFERENCES	 		------------------------------------------------------*/

print "";
print "DENOTATIONS";
print "------------------------";
print "SSP: Sub-Sample Period";
print "CV: Critical Value";
print "TVpCV: Test Value per Critical Value";
print "TVpCV = (Test Value) / (Bootstrap Critical Value at the given significant level)";
print "If the value of TVpCV > 1 it implies that the null hypothesis of no causality is rejected at the given significant level.";
print "";
print "REFERENCES:";
print "------------------------";
print "Hatemi-J A. (2021) Dynamic Asymmetric Causality Tests with an Application, Papers 2106.07612, arXiv.org.";
print "Hatemi-J A. (2012) Asymmetric Causality Tests with an Application, Empirical Economics, 43, 447-456.";
print "Hatemi-J A. (2003) A new method to choose optimal lag order in stable and unstable VAR models, Applied Economics";
print "Letters, 10(3), 135-137.";
print "Hacker S. and Hatemi-J A. (2006) Tests for causality between integrated variables using asymptotic and bootstrap ";
print "distributions: theory and application, Applied Economics, 38(13), 1489-1500.";
print "Hacker S. and Hatemi-J A. (2012) A bootstrap test for causality with endogenous lag length choice: theory and ";
print "application in finance, Journal of Economic Studies, 39(2), 144-160.";
print "--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
print "";

/*------------------------------------------------------------			 END  OF PRINGINT REFERENCES	 		------------------------------------------------------*/

/*==========================================================================================================*/
/*================		Section E: PRINTING RESULTS -  END  		===============================================*/
/*==========================================================================================================*/

/*==========================================================================================================*/
/*================		Section F: PROCEDURES - START 			===============================================*/
/*==========================================================================================================*/

/**********************  PROC RSTRCTVM *****************************
----PROC rstrctvm
----AUTHOR: Scott Hacker (in cooperation with A. Hatemi-J)
----INPUT:     
      numvars: number of variables in VAR sytem
      varorder: order of the VAR system
      addlags: number of additional lags 
----OUTPUT: 
     Rvector1: a row vector corresponding to the coefficients in the the first row of a VAR system,
                      with 1 indicating where a 0 restriction is placed and 0 indicating not.
     Rmatrix1: a matrix with each row indicating where one constraint is placed on
                      a vectorization of the coefficients in a VAR system. A 1 indicates which coefficient is
                      restricted to zero; 0 is given otherwise.
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: none
----NB: none.
**********************************************************************/
proc(2)=rstrctvm(numvars, varorder, addlags);
    local rvector1, rmatrix1, restnum, ordrcntr, varcntr;

    rvector1 = zeros(1,1+numvars*(varorder + addlags));
    rmatrix1 = zeros(varorder,(1+numvars*(varorder+addlags))*numvars);

    ordrcntr = 1;
    do until ordrcntr > varorder;
        rvector1[1,1+(ordrcntr-1)*numvars+2] = 1;
        rmatrix1[ordrcntr,1+((ordrcntr-1)*numvars+2)*numvars]=1;
        ordrcntr = ordrcntr +1;
    endo;

    retp(rvector1,rmatrix1);
endp;


/**********************  PROC Azd *****************************
----PROC azd
----AUTHOR: Scott Hacker
----INPUT:     
       Addlags
----NB: none.
**********************************************************************/
proc(1)=azd(addlags);
    local indx;
    indx= 1;
    do until indx > 2;
         indx = indx+1;
    endo; 
  retp(indx);
endp;

/**********************  PROC VARLAGS  *****************************
**   Author: Alan G. Isaac
**   last update: 5 Dec 95      previous: 15 June 94
**   FORMAT
**          { x,xlags } = varlags(var,lags)
**   INPUT
**        var  - T x K matrix
**        lags - scalar, number of lags of var (a positive integer)
**   OUTPUT
**          x -     (T - lags) x K matrix, the last T-lags rows of var
**          xlags - (T - lags) x lags*cols(var) matrix,
**                  being the 1st through lags-th
**                  values of var corresponding to the values in x
**                  i.e, the appropriate rows of x(-1)~x(-2)~etc.
**   GLOBAL VARIABLES: none
**********************************************************************/
proc(2)=varlags(var,lags);
    local xlags;
    xlags = shiftr((ones(1,lags) .*. var)',seqa(1-lags,1,lags)
                                            .*. ones(cols(var),1),miss(0,0))';
    retp(trimr(var,lags,0),trimr(xlags,0,lags));
endp;


/*************************************************************************
----PROC EstVar_Params
----AUTHOR: Scott Hacker
----INPUT:      
      y  - data matrix adjusted for lags. Each column is a vector of observations on one
             endogenous variable. Currently only works for 2 endog. variables.
      X - a column of ones appended to a matrix of lagged values for y.
      restrict - 1 means restrict the coefficient estimates so there is no Granger causality
                    0 means don't do that restriction
      rvector1 - row vector noting which variable coefficients are restricted to zero (1 indicates
                       where the restriction is);
      order  - order of var system. This should be = 1 or 2.
      addlags - additional lags (should be equal to maximum integration order);
----OUTPUT: 
     Ahat - estimated matrix of coefficient parameters
      leverage - this is calculated appropriately only for restricted cases (for bootstraps)
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: Insrtzero
----NB: none.
************************************************************************/

proc (2) = estvar_params (y, X, restrict, rvector1, order, addlags);
   local numvars, maxlag, T, Xrestr1, Ahatrestr1, INVXTXXT2, H2, leverage2, INVXTXXTrest1,  Hrestr1, leverage, Ahat, Ahat2,i;
    numvars = cols(y);                 		@ # endog vars- currently this program only works for 2 @
     maxlag = order + addlags;
       T=rows(y);
     If restrict == 1;
        INVXTXXT2 = Inv(X'*X)*X';
        Ahat2 = (INVXTXXT2*Y[.,2:numvars])';
     /*   H2 = X*INVXTXXT2;
        leverage2 = diag(H2); */
        leverage2= zeros(rows(X),1);
        i = 1;
        do until i > rows(X);
            leverage2[i,1] = X[i,.]*INVXTXXT2[.,i];
            i = i+1;
        endo;
        Xrestr1 = (delif(X',rvector1'))';
        INVXTXXTrest1 =  Inv(Xrestr1'*Xrestr1)*Xrestr1';
        Ahatrestr1 =  (INVXTXXTrest1*Y[.,1])';
/*        Hrestr1 = Xrestr1*INVXTXXTrest1;
         leverage = diag(Hrestr1)~leverage2;*/
  
        leverage= zeros(rows(Xrestr1),1);
        i = 1;
        do until i > rows(Xrestr1);
            leverage[i,1] = Xrestr1[i,.]*INVXTXXTrest1[.,i];
            i = i+1;
        endo;
        leverage = leverage~leverage2;
        
        Ahat = (Insrtzero(Ahatrestr1',rvector1'))'|Ahat2;
       
   else;
       Ahat = (Inv(X'*X)*(X'*Y))';
       leverage = ones(1,2);  /* this statement just provides some arbitrary (meaningless) values for the leverage;
                                               leverage is not expected to be used under these circumstances (the unrestricted case). */
   endif;
   retp(Ahat, leverage);
endp;        

/**********************  PROC INSRTZERO *****************************
----PROC insrtzero
----AUTHOR: Scott Hacker
----INPUT:     
      orig: the original vector in which zeros will be placed.
      pattern: a vector denoting which elements in the new vector will have the inserted zeros
----OUTPUT: 
      new: the new vector with zeros inserted according the pattern vector
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: none
----NB: none.
**********************************************************************/
proc(1)=insrtzero(orig, pattern);
    local indx, newv, insrtpts;
    insrtpts = indexcat(pattern,1);
    newv = orig;
    indx= 1;
    do until indx > rows(insrtpts);
         if insrtpts[indx] == 1;
             newv = 0;
             else;
             if insrtpts[indx] > rows(newv);
                 newv = newv|0;
                 else;
                     newv = newv[1:(insrtpts[indx]-1),.]|0|newv[insrtpts[indx]:rows(newv),.];
             endif;
         endif;
         indx = indx+1;
    endo; 
    retp(newv);
endp;


/*************************************************************************
----PROC W_test
----AUTHOR: Scott Hacker
----INPUT:      
      Y  - data matrix adjusted for lags. Each column is a vector of observations on one
             endogenous variable. 
      X - a column of ones appended to a matrix of lagged values for y.
      Ahat - matrix of unrestricted coefficient estimates
      Rmatrix1 - matrix of restrictions
----OUTPUT: 
     Wstat - vector of Wald statistics
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: none
----NB: none.
************************************************************************/
proc (1) = W_test(Y, X, Ahat, Rmatrix1);
   local RESunrestr, Estvarcov, zerosvector, vecAhat, f1, f2, InvXprX, Wstat;


     RESunrestr = Y - X*Ahat';
     Estvarcov = (RESunrestr'RESunrestr)/(rows(Y)-cols(Ahat));
     vecAhat = (vecr(Ahat'));
     InvXprX = Inv(X'X);
     f1 = (Rmatrix1*vecAhat);

     Wstat = f1'(inv(Rmatrix1*(InvXprX.*.Estvarcov)*Rmatrix1'))*f1;

   retp(Wstat);
endp;        

/*************************************************************************
----PROC Bootstrap_Toda
----AUTHOR: Scott Hacker
----INPUT:      
      y  - data matrix adjusted for lags. Each column is a vector of observations on one
             endogenous variable. 
      X - ones column vector appended to a matrix of lagged values for y.
      zlags - first elements of original data matrix up to the number of lags.
      order  - order of var system. 
      Ahat - estimated coefficient matrix for the VAR system
      leverage
      addlags - additional lags (should be equal to maximum integration order);
      order  - order of var system. This should be = 1 or 2.
      addlags - additional lags (should be equal to maximum integration order);
      bootsimmax - number of simulations for bootstrapping critical values
      Rmatrix1, Rmatrix2 - matrices of restrictions, tested separately
----OUTPUT: 
     Wcriticalvals - matrix of critical values for Wald statistics
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: estvar_params, W_test;
----NB: none.
************************************************************************/
 proc(1) = Bootstrap_Toda(y, X, zlags, Ahat, leverage, order, addlags,bootsimmax, Rmatrix1);
 local RES, adjRES, bootsim, numobs, maxlag, Wstatv, yhatrow, Xhat, obspull, index, 
          simerr, zhat, yhat, AhatTU, Wstat, randomnumbers,
          onepct_index, fivepct_index, tenpct_index, critical_W, critical_Wpl1,
          Wcriticalvals, unneededleverage,numvars,varindx,adjuster;

 rndseed 300540;
 numobs = rows(y);
 numvars = cols(y);
 maxlag = order + addlags;
 RES = Y - X*Ahat';

/*ones(numobs,2);
leverage[1,2];
sqrt(ones(numobs,1) - leverage[1,1])~sqrt(ones(numobs,1) - leverage[1,2]);
RES;
*/
 adjuster =  sqrt(ones(numobs,1) - leverage[1,1]);
 varindx = 2;
 do until varindx > numvars; 
      adjuster = adjuster~sqrt(ones(numobs,1) - leverage[1,2]);  /*leverage the same (leverage[1,2]) for all variables except first */
      varindx = varindx + 1;
 endo;
 adjRES = RES ./adjuster;
 Wstatv = zeros(bootsimmax,1);
 bootsim = 1;  
 simerr=zeros(numobs,numvars);

 do until bootsim > bootsimmax;
       
       obspull = 1;
       do until obspull > numobs;
          randomnumbers = rndu(1,numvars);
          index = 1+ trunc(numobs*randomnumbers);
          simerr[obspull,1] = adjRES[index[1,1],1];
          varindx = 2;
          do until varindx > numvars;
                simerr[obspull,varindx] = adjRES[index[1,varindx],varindx];
                 varindx = varindx +1;
          endo;
          obspull = obspull +1;
       endo;
       varindx = 1;
       do until varindx > numvars;
             simerr[.,varindx] = simerr[.,varindx] - (meanc(simerr[.,varindx])) ;
             varindx = varindx + 1;
       endo;
 
       /* Method 1 for creating Wstat and Yhat: Xhat derived*/
      Xhat = X[1,.];
      obspull = 1;
      do until obspull > numobs;
          yhatrow = Xhat[obspull,.]*Ahat' + simerr[obspull,.];
          If maxlag > 1;
             Xhat= Xhat|(1~yhatrow~Xhat[obspull,2:1+numvars*(maxlag-1)]);
          else;
             Xhat= Xhat|(1~yhatrow);
          endif;
          obspull = obspull + 1;
      endo;     
      yhat = Xhat[2:rows(Xhat), 2:(numvars + 1)];
      Xhat = Xhat[1:rows(Xhat)-1,.];


      {AhatTU,unneededleverage} = estvar_params(yhat, Xhat,0, 0, order,addlags);
      {Wstat} = W_Test(yhat, Xhat, AhatTU, Rmatrix1); 

      Wstatv[bootsim, 1] = Wstat;
      bootsim = bootsim + 1;
 endo;

 Wstatv=SORTMC(Wstatv[.,1],1);
 onepct_index = bootsimmax - trunc(bootsimmax/100);
 fivepct_index = bootsimmax - trunc(bootsimmax/20);
 tenpct_index = bootsimmax - trunc(bootsimmax/10);




 critical_W = Wstatv[onepct_index,.]|Wstatv[fivepct_index,.]|Wstatv[tenpct_index,.];
 critical_Wpl1 = Wstatv[onepct_index+minc(1|trunc(bootsimmax/100)),.]|
                          Wstatv[fivepct_index+minc(1|trunc(bootsimmax/20)),.]|
                          Wstatv[tenpct_index+minc(1|trunc(bootsimmax/10)),.];

 Wcriticalvals = (critical_W + critical_Wpl1)/2; 

    
 retp(Wcriticalvals);
endp;

/*************************************************************************
----PROC lag_length2 
----AUTHOR: Scott Hacker
----ATTRIBUTION: Parts of this code are taken from proc LR_LAG
    written by David Rapach (may 27 1996 version).
----INPUT:      
      Z  - data matrix. Each column is a vector of observations on one
             endogenous variable
      minlag - minimum lag length
      p  - maximum lag length. This should be >= 2

----OUTPUT: aiclag  - Lag length suggested by Akaike info criterion.
                    aicclag - Lag length suggessted by corrected Akaike infoc criterion
                    sbclag -  Lag length suggested by Schwarz-Bayesian criterion.
                    hqclag - Lag length suggested by Hannon-Quinn criterion.
                    hjclag - Lag length suggested by Hatemi-J criterion.
                    aicA - Matrix of coefficient estimates based on aiclag.
                    aiccA - Matrix of coefficient estimates based on aicclag.
                    scbA - Matrix of coefficient estimates based on sblag.
                    hqcA - Matrix of coefficient estimates based on hqlag.
		    hjcA - Matrix of coefficient estimates based on hjlag.
                    actlA - Matrix of coefficient estimates based on actual lag.
                    onelA -Matrix of coefficient estimates based on one lag.
      nocando - 1 if not possible to find suggested lag lengths for the given Z,
                       0 otherwise. 
----GLOBAL VARIABLES: none
----EXTERNAL PROCEDURES: VARLAGS, by Alan G. Isaac
----NB: none.
************************************************************************/

proc (12) = lag_length2(z, minlag, p);
   local M, Y, ylags, T,i, j, lag_guess,X, Ahat, RES, VARCOV,
            aic, aicc, sbc, hqc, hjc, aicmin, aiclag, aiccmin, aicclag, sbcmin, sbclag, hqcmin, hqclag, hjcmin, hjclag, HJCA,
            aicfnd;
    M = cols(z);                 		@ # endog vars @
      {Y, ylags} = varlags(z,p);
       T=rows(y);
    lag_guess = p;				@ initialization  of lag_guess @
    j = 0;
    aicfnd = 0;
    do until (lag_guess < minlag);
       if (lag_guess > 0);
          X = ones (T,1) ~ylags[ . , 1:lag_guess*M];
       else;
          X = ones (T,1);
       endif;
/*If abs(Z[T,1]) > 100000000000000000 or abs(Z[T,2]) > 100000000000000000; 
     print "Z(T,.)=";Z[T,1]; Z[T,2];
     print "det(X'X)";;det(X'X);
endif; */
 /*    If ((det(X'X)) > 100000000000000000 or (det(X'X)) < -100000000000000000); */
  /*  If ((det(X'X)/10000) >  99999999999999999 or (det(X'X)/10000) <   -99999999999999999); */
/*   print "Z(T,.)=";Z[T,1]; Z[T,2]; 
   print "det(X'X)";;det(X'X); */
    If 2 < 1;                    /*    never true of course--I'm just commenting out the above if statements */
         nocando = 1;
         aiclag = -1;
         aicclag = -1;
         sbclag = -1;
         hqclag = -1;
         hjclag = -1;
         lag_guess = -1;
    else;
         nocando = 0;
          Ahat = (Y/X)';
          RES = Y - X*Ahat';
          VARCOV = RES'RES/T;
          aic =   ln(det(VARCOV)) + (2/T)*(M*M*lag_guess +M)+ M*(1+ln(2*pi));  /* Original AIC definition used */
          aicc =   ln(det(VARCOV)) + ((T + (1+lag_guess*M))*M)/(T - (1+lag_guess*M) - M -1); /* AICC*/
          sbc = ln(det(VARCOV)) + (1/T)*(M*M*lag_guess+M)*ln(T)+ M*(1+ln(2*pi)); 
          hqc = ln(det(VARCOV)) + (2/T)*(M*M*lag_guess+M)*ln(ln(T))+ M*(1+ln(2*pi));
          hjc = (sbc + hqc)/2;

    /* print "aic=";; aic;; print "lag_guess=";; lag_guess; 
     print "sbc=";; sbc;; print "lag_guess=";; lag_guess; 
     print "hqc=";; hqc;; print "lag_guess=";; lag_guess; */
          if (lag_guess==p);
             aicmin = aic; 
             aiclag = lag_guess;
             aicA = Ahat;      
             aiccmin = aic; 
             aicclag = lag_guess;
             aiccA = Ahat;     
             sbcmin = sbc;  
             sbclag = lag_guess;
             sbcA = Ahat;     
             hqcmin = hqc;
             hqclag = lag_guess;
             hqcA = Ahat;   
             hjcmin = hjc;
             hjclag = lag_guess;
             hjcA = Ahat;   
          else;
             if (aic <= aicmin);
                aicmin = aic; 
                aiclag = lag_guess; 
                aicA = Ahat;  
             endif; 

             if (aicc <= aiccmin);
                aiccmin = aicc; 
                aicclag = lag_guess; 
                aiccA = Ahat;  
             endif; 


          /*   aicfnd;;" ";;aic;;" ";;aicmin; */
          /*   if ((aicfnd == 0) and (aic > aicmin));
                aiclag = lag_guess +1;
                aicA = Ahat;
                aicfnd = 1;
             else;
                aicmin = aic;
             endif;
       */

             if (sbc <= sbcmin);
                sbcmin = sbc;
                sbclag = lag_guess;
             sbcA = Ahat;  
             endif;

             if (hqc <= hqcmin);
                hqcmin = hqc;
                hqclag = lag_guess;
                hqcA = Ahat;  
             endif;

             if (hjc <= hjcmin);
                hjcmin = hjc;
                hjclag = lag_guess;
                hjcA = Ahat;  
             endif;
          endif;
      /*    if (lag_guess == lags);
               actlA = Ahat;  
          endif; */
          if (lag_guess == 1);
               onelA = Ahat; 
          endif; 
          lag_guess = lag_guess - 1; 
       endif;
   endo;
   retp(aiclag, aicclag, sbclag, hqclag, hjclag, aicA, aiccA, sbcA, hqcA, hjcA, onelA, nocando);
endp;
/*==========================================================================================================*/
/*================		Section F: PROCEDURES -  END  			===============================================*/
/*==========================================================================================================*/
