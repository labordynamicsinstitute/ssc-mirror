<pre>
<p>
<b>help filtertrace</b>
-------------------------------------------------------------------------------
<p>
<b><u>Title</u></b>
<p>
     <b>filtertrace</b> -- Trace filter or contingency questions
<p>
<b><u>Syntax</u></b>
<p>
     Define filters
<p>
        <b>filtertrace</b> <b><u>d</u></b><b>efine</b> [<i>varlist</i> <b>:</b>] <i>exp</i> [<b>;</b> <i>exp ...</i>] [<i>if</i>] [<i>in</i>] [<b>, </b><i>options</i>]
<p>
     Check filters
<p>
        <b>filtertrace</b> <b><u>c</u></b><b>heck</b> <i>vfe</i> [<b>;</b> <i>vfe ...</i>] [<b>, </b><i>options</i>]
<p>
<p>
     where
<p>
        <i>vfe</i> is [<i>list</i> <b>:</b>] <b>v</b>arlist <b>(</b>[T] <b>f</b>ilter#<b>)</b> [<b>e</b>xp]
<p>
     in <i>vfe</i>
<p>
        (filter#) is a numlist indicating the filters for which <i>exp</i> is checked.
           Note that parenthesis must be used. The optional <i>T</i> indicates that
           <i>exp</i> is to be checked, only if the filters are true. The optional
           <i>list</i> is a list with as many elements as filters are specified, and
           indicates that filter 1 will be used checking <i>exp</i> for the first
           variable in varlist, filter 2 for the second and so on.
<p>
     See filtertrace define and filtertrace check for detailed
        explanations. Also see Workflow examples.
<p>
<p>
     List defined filters
<p>
        <b>filtertrace</b>
<p>
     Drop or clear filters and flags
<p>
        <b>filtertrace</b> {<b>drop</b>|<b>clear</b>} [<b>all</b>]
<p>
     Reimport filters from variables or create variables
<p>
        <b>filtertrace</b> {<b><u>i</u></b><b>mport</b>|<b><u>e</u></b><b>xport</b>} <i>name</i>
<p>
<p>
    <i>options</i>                Description
    -------------------------------------------------------------------------
    <i>main</i>
      <b><u>g</u></b><b>enerate(</b><i>stub</i><b>)</b>       create variables <i>stub#</i>
    <i>define options</i>
      <b><u>a</u></b><b>dd</b>                  add filter/s
      <b>replace(</b><i>numlist</i><b>)</b>     replace filter/s
    <i>check options</i>
      <b><u>full</u></b><b>exp</b>              use complete expression as (flag) variable labels
      <b><u>nof</u></b><b>lag</b>               do not create variables tagging contradictions
    -------------------------------------------------------------------------
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>filtertrace</b> is used to trace filter or contingency questions. In social
    research questionnaires often contain <i>contingency</i> questions, i.e.
    questions respondents are asked contingent on their answer to a previous
    <i>filter</i> question. <b>filtertrace</b> allows to detect (coding) errors in
    contingency questions in a two-step approach.
<p>
    In a first step filter questions are reconstructed (see define). In a
    second step contingency questions are checked and errors are tagged (see
    check).
<p>
    To learn about other subcommands see here.
<p>
<p>
<b><u>Options</u></b>
<p>
        +---------+
    ----+ Options +----------------------------------------------------------
<p>
    <b>generate(</b><i>stub</i><b>)</b> creates filter variables <i>stub1, ..., stubk</i>, tagging
        observations for which <i>exp</i> is true, when used with <b>filtertrace</b>
        <b>define</b>. Default is not to create filter variables. When used with
        <b>filtertrace check</b>, it creates indicator variables <i>stub#</i>, tagging
        contradictions. If not specified, <i>stub</i> defaults to <i>_con</i>.
<p>
    <b>add</b> adds new filters.
<p>
    <b>replace(</b><i>numlist</i><b>)</b> replaces all filters addressed by <i>numlist</i>.
<p>
    <b>fullexp</b> uses full expressions as variable labels for flags. Default is to
        use filter number and expression. Any <i>if</i> and <i>in</i> qualifiers used when
        defining the filters are omitted.
<p>
    <b>noflag</b> suppresses the creation of flag variables tagging contradictions.
        The summary report is also suppressed.
<p>
<p>
<b><u>Remarks</u></b>
<a name="def"></a><p>
    <b>filtertrace define</b> is used to reconstruct filter questions in the
    questionnaire. It saves <i>exp</i> in <b>s(</b><i>_fltrflg#_</i><b>)</b>. Here <i>exp</i> refers to an
    expression as used in <b>if</b> statements. Thus <i>exp</i> usually contains at least
    one variable (e.g. var1 &lt;= 42 &amp; var1 &gt;= 27). One expression represents
    one filter question. Use <b>;</b> to separate multiple expressions. You do not
    specify names for filters. Once defined filters are later addressed using
    their number. If option <b>generate()</b> is specified, variables indicating
    observations for which <i>exp</i> is true, are created.
<p>
    <u>Helpful hint</u>
<p>
    Note that <b>filtertrace define</b> allows an optional <i>varlist</i>.  Placeholders <i>@</i>
    are used to refer to variables in <i>varlist</i>.  Specifying
<p>
        <b>filtertrace define var1-var3 : @ == 1</b>
<p>
    is equal to
<p>
        <b>filtertrace define var1 == 1 ; var2 == 1 ; var3 == 1</b>
<p>
    Both lines will define three filters (1, 2 and 3). You may omit
    placeholder <i>@</i> in the first command, since a <i>basic</i> expression is used (see
    Placeholders).
<p>
<a name="chk"></a><p>
    <b>filtertrace check</b> is used to detect errors in contingency questions.
    Each <i>vfe</i> specified (and separated by <b>;</b>) is checked separately. A <i>vfe</i>
    consists of a <i>varlist</i> a list of filter numbers (<i>filter#</i>) and an
    expression (<i>exp</i>). For each variable specified in <i>varlist</i>, <i>exp</i> is checked
    for observations identified by the filters in <i>filter#</i>. Each {filter#} is
    checked separatly. A flag variable is created, tagging observations for
    which <i>filter#</i> is true but <i>exp</i> is <b>not</b> true. Use placeholders to refer to
    variables in <i>varlist</i> (see  Placeholders). If <i>exp</i> is not specified it
    defaults to <b>!= .</b> (i.e. not system missing).
<p>
    <u>Helpful hints</u>
<p>
    Note that
<p>
        <b>filtertrace check var1 (1) != .</b>
<p>
    does not only check whether all observations, for which filter 1 is true,
    do not have system missing values in var1, but also checks the condition
    the other way round. That is, it also checks
<p>
        <b>filtertrace check var1 !(1) == .</b>
<p>
    To suppress the second check, type
<p>
        <b>filtertrace check var1 (T 1) != .</b>
<p>
    Also note the use of the optional <i>list</i>
<p>
        <b>filtertrace check 1/3 : var@ (1/3) != .</b>
<p>
    is equal to
<p>
        <b>filtertrace check var1 (1) != . ; var2 (2) != . ; var3 (3) != .</b>
<p>
<a name="oth"></a><p>
    <b>filtertrace</b> typed without subcommand lists and describes all defined
    filters.
<p>
<p>
    <b>filtertrace drop</b> drops created filter variables. If <b>all</b> is specified, all
    flag variables, indicating observations with errors in contingency
    questions are also dropped. Note that it is not necessary to drop flag
    variables, since they are replaced each time<b> filtertrace check</b> is used.
<p>
<p>
    <b>filtertrace clear</b> clears defined filters. If <b>all</b> is also specified, any
    user defined <i>stub</i> is cleared from <b>s()</b>. This is similar to specifying 
    sreturn clear.
<p>
<p>
    <b>filtertrace import</b> reconstructs filters from variables previously created
    using <b>filtertrace define</b> with option <b>generate()</b>.  Filters may only be
    imported if there are no filters defined yet.
<p>
<p>
    <b>filtertrace export</b> creates flag variables <i>name#</i> from defined filters.
<p>
<a name="plc"></a><p>
    <b><u>Placeholders</u></b>
<p>
    <u>Placeholders in expressions</u>
<p>
    <b>filtertrace</b> knows two types of expressions. An expression is considered
    <i>basic</i> if it has only one variable and one relational operator.
    Expressions with at least one of the <i>logical operators</i> <b>&amp;</b> or <b>|</b> are
    considered <i>complex</i>.  Therefore <i>var1 &lt;= 42</i> is a <i>basic</i> expression, while
    <i>var1 &lt;=42 &amp; var1 &gt;= 27</i> is a <i>complex</i> expression. Note that the latter
    expression can be rewritten as a inrange() function, e.g.<i>  inrange(var1,</i>
    <i>27, 42)</i>. Functions are also considered <i>complex expressions</i>.
<p>
    In <i>complex expressions</i> placeholder/s <b>@</b> must be used to refer to variables
    in <i>varlist</i>. The use of placeholders is not required in <i>basic</i> expressions.
    Thus typing
<p>
        <b>filtertrace check var1 var2 (1) &gt; 42</b> 
<p>
    is ok, as is
<p>
        <b>filtertrace check var1 var2 (1) !inlist(@, 1, 2, 4)</b>
<p>
    <u>Placeholders in (</u><i><u>var</u></i><u>)</u><i><u>list</u></i><u> (</u><b><u>filtertrace check</u></b><u> only)</u>
<p>
    <b>filtertrace check</b> allows an optional <i>list</i>. This <i>list</i> indicates, that <i>exp</i>
    is to be checked for all variables, but contingent on different filters.
    Use placeholders to indicate which filter is to be used with which
    variable. The line
<p>
        <b>filtertrace check a b : var1@ var2@ var3@ (1/2) inlist(@, 1, 2, 4)</b>
 
    is equal to
<p>
        <b>filtertrace check var1a var2a var3a (1) inlist(@, 1, 2, 4) ; ///</b>
        <b>var1b var2b var3b (2) inlist(@, 1, 2, 4)</b>
<p>
    Note that <i>list</i> must have as many elements as filter numbers are
    specified. Also note that the placeholder in the <b>inlist()</b> function
    (<i>complex</i> expression) does not have anything to do with the specified
    <i>list</i>.
<p>
<p>
<b><u>Examples</u></b>
<p>
        . sysuse nlsw88 ,clear
<p>
        <b>. filtertrace define age &gt; 40 ; inrange(wage, 10, 25)</b>
<p>
    defines two filters. Filter one is true for all observations older than
    40, filter two is true for all observations with wages between 10 and 25.
<p>
        <b>. filtertrace</b>
<p>
    lists the (two) defined filters.
<p>
        <b>. filtertrace export filter</b>
<p>
    creates dummy variables <i>filter1</i> and <i>filter2</i>, indicating observations
    older than 40 and with wages between 10 and 25.
<p>
        <b>. filtertrace check married (1 2) == 1</b>
<p>
    checks whether all observations older than 40 are married and all
    observations age 40 and younger are not married. It also checks whether
    all observations with wages between 10 and 25 are married and all
    observations with wages outside this range are single. There will be
    contradictions.
<p>
<a name="ex"></a><p>
<b><u>Workflow examples</u></b>
<p>
    I will start with a simple example. Suppose a questionnaire containing
    the question <i>Are you pregnant?</i>. Obviously this (contingency) question
    should only be asked, if the respondent was female. Therefore it is
    preceded by a question about the respondent's gender. In our dataset we
    have two variables <i>gender</i> (with value 1 for women) and <i>pregnancy</i>.  All
    male respondents are expected to have a (system) missing value in
    <i>pregnancy</i>. To check, we first reconstruct the filter.
<p>
        <b>filtertrace define gender == 0</b>
<p>
    The syntax should be self-explanatory. It saves one condition (that is:
    one filter) in <b>s(</b><i>_fltrflg1_</i><b>)</b>. Next we will check, whether <i>pregnancy</i> is
    missing for all male respondents.
<p>
        <b>filtertrace check pregnancy (1) == .</b>
<p>
    Here we specified three arguments. We first specify the variable we want
    to check: <i>pregnancy</i>. The second argument is the filter's number, for
    which we want to check the (basic) expression specified as the third
    argument. The output we get will be something like
<p>
        variable: pregnancy
<p>
              (1)
                  checking (pregnancy == .)
                  no contradictions
             !(1)
                  checking !((pregnancy == .))
                  no contradictions
<p>
                 
<p>
        Contradictions
<p>
                  no contradictions
<p>
    It tells us that there are no male respondents who answered the pregnancy
    question. The output also tells us, that there are no females who did not
    answer the question.
<p>
    The above example is very simple, and we would probably be faster using
    tabulate and look at the cross tabulation of <i>gender</i> and <i>pregnancy</i>
    (however we would not be able to identify observations contradicting the
    condition, if there were any). We will see more complex examples below.
<p>
    For the moment pretend we did not have checked filter 1 yet. In our
    questionnaire we asked respondents of all ages. However we only asked the
    pregnancy question if respondents were female and age 14-55. All women
    younger than 14 or older than 55 are not supposed to have answered this
    question. To check we first add a second filter.
<p>
        <b>filtertrace define age : @ &lt; 14 | @ &gt; 55 ///</b>
        <b>if gender == 1 ,generate(filter) add</b>
<p>
    We used a varlist (containing only the one variable <i>age</i>) so we can refer
    to this variable using placeholders in the <i>complex</i> expression.  It is
    also ok to code
<p>
        <b>filtertrace define age &lt; 14 | age &gt; 55 ///</b>
        <b>if gender == 1 ,generate(filter) add</b>
<p>
    Note that <i>age</i> is not considered a <i>varlist</i> or <i>variable</i> here, but is part
    of exp. Also note the <i>if</i> qualifier (used in both cases) to restrict <i>exp</i>
    to women. All male respondents will have system missing values in
    variable <i>filter2</i>. Coding
<p>
        <b>filtertrace define age : (@ &lt; 14 | @ &gt; 55) ///</b> 
        <b>&amp; gender == 1 ,generate(filter) add</b>
<p>
    will assign value 0 to all male respondents, as well as to all females
    aged 14-55, but we do not want that. We can now check for (coding) errors
    in the pregnancy question.
<p>
        <b>filtertrace check pregnancy (T 1) == . ; pregnancy (2) == .</b>
<p>
    In this example we used the optional <i>T</i> in <i>filter1</i> to suppress checking
    <i>exp</i> the other way round. We did so, because we do no longer expect <i>all</i>
    females to have answered the pregnancy question. We check <i>filter2</i> both
    ways because all females younger than 14 and older than 55 are expected
    to have missing values, while <i>all</i> females between age 14 and 55 must have
    answered the pregnancy question.
<p>
    In a last example, suppose we used a position generator (Lin and Dumnin
    1986) in our questionnaire. We presented respondents a list of 10
    occupations asking them to indicate whether they knew anyone having these
    occupations. If so, we asked them about this person's gender age and
    education. The position generator leaves us with 40 variables in our
    dataset (occ1-occ10, gender1-gender10, age1-age10, edu1-edu10).
    Respondents who do not know anyone having occupation 1 are expected to
    have missing values in gender1, age1 and edu1. Respondents knowing
    someone with occupation <i>x</i> must not have (system) missings. We check this
    by defining ten (more) filters -- one for each occupation.
<p>
        <b>filtertrace define occ1-occ10 : == 1 ,add</b>
<p>
    This line creates 10 filters (filters 3 to 12). Next we check the
    contingency questions.
<p>
        <b>filtertrace check gender1 age1 edu1 (1) != . ; ///</b>
        <b>gender2 age2 edu2 (2) != . ; [...] ; ///</b>
        <b>gender10 age10 edu10 (10) != .</b>
<p>
    These lines will work fine, but are sure a lot of typing. It might be
    more convenient to type
<p>
        <b>filtertrace check 1/10 : gender@ age@ edu@ (3/12) != .</b> 
<p>
    You may also create a simple forvalues loop. The advantage of the line
    given is, that there will only be one summary report instead of 10 with
    the <b>forvalues</b> loop.
<p>
<p>
<b><u>Acknowledgments</u></b>
<p>
    The idea for <b>filtertrace</b> is partly inspired by Krishnan Bhaskaran's
    <b>datacheck</b>.
<p>
    See Bill Rising's <b>ckvar</b> for a more sophisticated approach to data
    validation.
<p>
<b><u>References</u></b>
<p>
    Lin, N and Dumnin, M (1986). Access to Occupations through Social Ties.
    Social Networks, 8. 365-385
<p>
<p>
<b><u>Author</u></b>
<p>
    Daniel Klein, University of Bamberg, klein.daniel.81@gmail.com
<p>
<b><u>Also see</u></b>
<p>
    Online: assert, mi(), inlist(), inrange(), forvalues
<p>
    if installed: datacheck, ckvar
</pre>