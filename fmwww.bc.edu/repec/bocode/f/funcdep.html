<pre>
<p>
-------------------------------------------------------------------------------
help for <b>funcdep</b>
-------------------------------------------------------------------------------
<p>
<p>
<b><u>Test whether a set of variables is functionally dependent on a specified set of</u></b>
<b><u>&gt;  basis variables</u></b>
<p>
        <b>funcdep</b> [<i>varlist</i>] [<b>if</b> <i>exp</i>] [<b>in</b> <i>range</i>] [, <b>basis(</b><i>basisvars</i><b>)</b> <b>assert key</b>
                 <b>testsep</b> <b>gen(</b><i>genvars</i><b>)</b> <b>sortpreserve</b>]
<p>
<p>
<b><u>Description</u></b>
<p>
    <b>funcdep</b> will test whether <i>varlist</i> is functionally dependent on <i>basisvars</i>,
    which means that observations with equal values of <i>basisvars</i> also have
    equal values of <i>varlist</i>.  If we use the term "basis groups" to mean the
    sets of observations having the same values in <i>basisvars</i>, then functional
    dependency is the property that <i>varlist</i> has constant values within basis
    groups.  See more on this subject under <b><u>Additional Remarks</u></b>, below.
<p>
    <b>funcdep</b> first tests whether <i>basisvars</i> is a key for the dataset - whether
    every observation has a unique value (or tuple of values) in <i>basisvars</i>.
    If this condition is satisfied, then no further testing is performed, as
    this condition implies functional dependency, regardless of what <i>varlist</i>
    is composed of.  If <i>basisvars</i> is not a key, then a functional dependency
    test is performed on <i>varlist</i> with respect to <i>basisvars</i>.
<p>
    The following r() values will be returned:
        r(funcdep)
        r(key)
    These are numeric 0/1 indicators of, respectively, whether functional
    dependency holds and whether <i>basisvars</i> is a key.  (If the functional
    dependency test is skipped due to <i>basisvars</i> being a key, then r(funcdep)
    is still set appropriately, to 1).  These return values are provided to
    enable you write programs or do-files whose actions depend on the results
    of a functional dependency test.  But if your intent is to proceed only
    if the test is successful, it may be more convenient to just use the
    <b>assert</b> option.
<p>
<p>
<b><u>Options</u></b>
<p>
    <b>basis(</b><i>basisvars</i><b>)</b> specifies the set of basis variables on which you are
        testing for functional dependency.  This can be absent, in which case
        <b>funcdep</b> tests whether <i>varlist</i> is constant within the entire dataset.
<p>
    <b>assert</b> asserts that the functional dependency condition holds.  That is,
        it invokes an error condition if the test fails.
<p>
    <b>key</b> additionally asserts that <i>basisvars</i> is a key; it only takes effect if
        <b>assert</b> is also specified.
<p>
    <b>testsep</b> causes the functional dependency test to be done separately for
        each variable in <i>varlist</i>.  The default is to test the whole of
        <i>varlist</i> all at once.  The utility of this option is that, if the test
        fails, and if <i>varlist</i> is composed of several variables, then you will
        be able to tell which of the variables is causing the failure.  (Note
        that <i>varlist</i> is functionally dependent on <i>basisvars</i> if and only if
        each variable in <i>varlist</i> is, separately, functionally dependent on
        <i>basisvars</i>.)
<p>
    <b>gen(</b><i>genvars</i><b>)</b> specifies one or more new variables to be generated that
        indicate where functional dependency fails; they are constant within
        basis groups. This may be useful for finding cases where functional
        dependency fails, or for just determining whether a variable varies
        within basis groups.
<p>
        If <b>testsep</b> is specified along with <b>gen(</b><i>genvars</i><b>)</b>, then there must be
        as many names in <i>genvars</i> as in <i>varlist</i>, and the names in <i>genvars</i> will
        correspond to those in <i>varlist</i> in the order given. If <b>testsep</b> is not
        specified, then there must be just one name in <i>genvars</i>, and it will
        represent all variables in <i>varlist</i> collectively.
<p>
        If the functional dependency test is skipped due to <i>basisvars</i> being a
        key, and <b>gen(</b><i>genvars</i><b>)</b> is specified, then <i>genvars</i> are set to 0.
<p>
    <b>sortpreserve</b> turns on the sortpreserve feature; the sort order of the
        dataset will not be affected.  By default, the data will be sorted by
        <i>basisvars</i>.
<p>
<p>
<b><u>Remarks</u></b>
<p>
    Both <i>varlist</i> and <b>basis(</b><i>basisvars</i><b>)</b> are optional.  If <i>varlist</i> is absent
    then functional dependency is necesarily true.  That is, an empty <i>varlist</i>
    is functionally dependent on any <i>basisvars</i>.  If <b>basis(</b><i>basisvars</i><b>)</b> is
    absent, then <b>funcdep</b> tests whether <i>varlist</i> is constant over the entire
    dataset.  (Note that an empty <i>basisvars</i> is a key only if there are &lt;=1
    observations.)
<p>
    The <b>if</b> and <b>in</b> qualifiers would presumably be rarely used.  Usually you
    would want to test functional dependency on an entire dataset, but there
    may be occasions where it fails on the entire set, but you would want to
    see if it passes on a specific subset.
<p>
<p>
<b><u>Examples</u></b>
<p>
      <b>. funcdep state county, basis(family year)</b>
<p>
      <b>. funcdep msa if ~newengland, basis(state county) assert</b>
<p>
      <b>. funcdep name yearborn, basis(id) assert</b>
<p>
      <b>. funcdep name, basis(id) gen(k1)</b>
      <b>. list id name if k1, sepby(id)</b>
        /* shows id values that have multiple names */
<p>
      <b>. funcdep jobcode, basis(id) gen(k2)</b>
        /* k2 indicates that the person had more than one jobcode */
<p>
<p>
<b><u>Additional Remarks</u></b>
<p>
    To say that <i>varlist</i> is functionally dependent on <i>basisvars</i> means that
    values in <i>varlist</i> are uniquely determined by those of <i>basisvars</i>.
    Equivalently, within basis groups, the values of <i>varlist</i> are constant.
    Yet another charaterization is that the relationship of <i>basisvars</i> values
    to <i>varlist</i> values is either one-to-one or many-to-one.  An example may
    help to illustrate:
<p>
. list, noobs
<p>
  +-----------+
  | a   b   c |
  |-----------|
  | 6   4   7 |
  | 9   4   7 |
  | 1   6   5 |
  | 2   6   5 |
  | 4   6   5 |
  | 2   8   5 |
  +-----------+
<p>
    In this example, c is functionally dependent on b, but not vice-versa.
<p>
    Functional dependency is a condition that is usually considered as an
    intrinsic property of the construction of a dataset.  That is, there is a
    logical reason why one variable must be functionally dependent on
    another.  One should be careful however, as there are situations where
    functional dependency arises as an accident of the content of the data
    (usually in a small sample), rather than the logic behind the
    construction of the dataset.  The same can be said of whether a set of
    variables forms a key.
<p>
    It is generally accepted wisdom that tables that serve as primamry
    storage of information should not have functional dependency between
    non-key variables.  This is the idea behind <i>database normalization</i>; see 
    collapseunique for more on this subject.  (You can use <b>collapseunique</b> to
    "factor out" such internal functional dependencies.) However, it is often
    acceptable and convenient to allow functional dependency between non-key
    variables in datasets for analysis.  One use of <b>funcdep</b> is to test
    whether these expected functional dependencies do indeed hold.
<p>
<p>
<b><u>Author</u></b>
<p>
    David Kantor.  Email kantor.d@att.net if you observe any problems.
<p>
<p>
<b><u>Also see</u></b>
<p>
    varlist, isid, duplicates;
<p>
</pre>